<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Theoretica: theoretica Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Theoretica
   </div>
   <div id="projectbrief">Mathematical Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacetheoretica.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">theoretica Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Main namespace of the library which contains all functions and objects.  
<a href="namespacetheoretica.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetheoretica_1_1algebra" id="r_namespacetheoretica_1_1algebra"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html">algebra</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1algebra"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear algebra routines. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetheoretica_1_1autodiff" id="r_namespacetheoretica_1_1autodiff"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1autodiff.html">autodiff</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1autodiff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Differential operators with automatic differentiation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetheoretica_1_1distribution" id="r_namespacetheoretica_1_1distribution"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1distribution.html">distribution</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1distribution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probability distribution functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetheoretica_1_1ode" id="r_namespacetheoretica_1_1ode"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1ode.html">ode</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1ode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical methods for ordinary differential equations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetheoretica_1_1parallel" id="r_namespacetheoretica_1_1parallel"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1parallel.html">parallel</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1parallel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelized element-wise evaluation of functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetheoretica_1_1regression" id="r_namespacetheoretica_1_1regression"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1regression.html">regression</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1regression"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regression to a model. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetheoretica_1_1signal" id="r_namespacetheoretica_1_1signal"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1signal.html">signal</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1signal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal processing module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetheoretica_1_1special" id="r_namespacetheoretica_1_1special"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1special.html">special</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1special"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetheoretica_1_1stats" id="r_namespacetheoretica_1_1stats"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1stats.html">stats</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1stats"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistical functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetheoretica_1_1tables" id="r_namespacetheoretica_1_1tables"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1tables.html">tables</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1tables"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tabulated values. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetheoretica_1_1taylor" id="r_namespacetheoretica_1_1taylor"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1taylor.html">taylor</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1taylor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Taylor series expansions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1complex.html">complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex number in algebraic form \(a + ib\).  <a href="classtheoretica_1_1complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1dual.html">dual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual number class.  <a href="classtheoretica_1_1dual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1dual2.html">dual2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second order dual number class.  <a href="classtheoretica_1_1dual2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1histogram.html">histogram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Histogram class with running statistics, can be constructed from the parameters of the bins or from a dataset.  <a href="classtheoretica_1_1histogram.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1mat.html">mat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic matrix with a fixed number of rows and columns.  <a href="classtheoretica_1_1mat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1mat_3_01_type_00_010_00_010_01_4.html">mat&lt; Type, 0, 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic matrix with a variable number of rows and columns.  <a href="classtheoretica_1_1mat_3_01_type_00_010_00_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1mat__iterator.html">mat_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequential iterator for matrices.  <a href="classtheoretica_1_1mat__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multidual number algebra for functions of the form \(f: \mathbb{R}^n \rightarrow \mathbb{R}\).  <a href="classtheoretica_1_1multidual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheoretica_1_1pdf__sampler.html">pdf_sampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A probability density function sampler which generates pseudorandom numbers following asymptotically a given distribution \(f(x; \vec \theta)\).  <a href="structtheoretica_1_1pdf__sampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1phasor.html">phasor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex number in exponential form \(\rho e^{i \theta}\).  <a href="classtheoretica_1_1phasor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A polynomial of arbitrary order.  <a href="classtheoretica_1_1polynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pseudorandom number generator.  <a href="classtheoretica_1_1_p_r_n_g.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1quat.html">quat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quaternion class in the form \(a + bi + cj + dk\).  <a href="classtheoretica_1_1quat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1ratio.html">ratio</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">representing a ratio between two objects, like a fraction or a rational polynomial.  <a href="classtheoretica_1_1ratio.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1spline.html">spline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A natural cubic spline interpolation class.  <a href="classtheoretica_1_1spline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheoretica_1_1spline__node.html">spline_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cubic splines node for a given x interval.  <a href="structtheoretica_1_1spline__node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1vec.html">vec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A statically allocated N-dimensional vector with elements of the given type.  <a href="classtheoretica_1_1vec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1vec__iterator.html">vec_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequential iterator for traversing vector-like containers.  <a href="classtheoretica_1_1vec__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a721dc79a0eca4b349c67a746c26b26a4" id="r_a721dc79a0eca4b349c67a746c26b26a4"><td class="memItemLeft" align="right" valign="top"><a id="a721dc79a0eca4b349c67a746c26b26a4" name="a721dc79a0eca4b349c67a746c26b26a4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mat2</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, 2, 2 &gt;</td></tr>
<tr class="memdesc:a721dc79a0eca4b349c67a746c26b26a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x2 matrix with real entries. <br /></td></tr>
<tr class="separator:a721dc79a0eca4b349c67a746c26b26a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7eff567887e9025d2edd9870a31311" id="r_afb7eff567887e9025d2edd9870a31311"><td class="memItemLeft" align="right" valign="top"><a id="afb7eff567887e9025d2edd9870a31311" name="afb7eff567887e9025d2edd9870a31311"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mat3</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, 3, 3 &gt;</td></tr>
<tr class="memdesc:afb7eff567887e9025d2edd9870a31311"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x3 matrix with real entries. <br /></td></tr>
<tr class="separator:afb7eff567887e9025d2edd9870a31311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac380be159592259cb223e6190e504197" id="r_ac380be159592259cb223e6190e504197"><td class="memItemLeft" align="right" valign="top"><a id="ac380be159592259cb223e6190e504197" name="ac380be159592259cb223e6190e504197"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mat4</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, 4, 4 &gt;</td></tr>
<tr class="memdesc:ac380be159592259cb223e6190e504197"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x4 matrix with real entries. <br /></td></tr>
<tr class="separator:ac380be159592259cb223e6190e504197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6802641e18b86a3022282d01b1ce25de" id="r_a6802641e18b86a3022282d01b1ce25de"><td class="memItemLeft" align="right" valign="top"><a id="a6802641e18b86a3022282d01b1ce25de" name="a6802641e18b86a3022282d01b1ce25de"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cmat</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt; &gt;</td></tr>
<tr class="memdesc:a6802641e18b86a3022282d01b1ce25de"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable size matrix with complex entries. <br /></td></tr>
<tr class="separator:a6802641e18b86a3022282d01b1ce25de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c414bd3969089ec91fa95cfc94390cf" id="r_a9c414bd3969089ec91fa95cfc94390cf"><td class="memItemLeft" align="right" valign="top"><a id="a9c414bd3969089ec91fa95cfc94390cf" name="a9c414bd3969089ec91fa95cfc94390cf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cmat2</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;, 2, 2 &gt;</td></tr>
<tr class="memdesc:a9c414bd3969089ec91fa95cfc94390cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x2 matrix with real entries. <br /></td></tr>
<tr class="separator:a9c414bd3969089ec91fa95cfc94390cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec5ec1cfb9d9d79780881e02e5d11b0" id="r_a2ec5ec1cfb9d9d79780881e02e5d11b0"><td class="memItemLeft" align="right" valign="top"><a id="a2ec5ec1cfb9d9d79780881e02e5d11b0" name="a2ec5ec1cfb9d9d79780881e02e5d11b0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cmat3</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;, 3, 3 &gt;</td></tr>
<tr class="memdesc:a2ec5ec1cfb9d9d79780881e02e5d11b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x3 matrix with real entries. <br /></td></tr>
<tr class="separator:a2ec5ec1cfb9d9d79780881e02e5d11b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ec29d91ae6c6a21a09cdaf95a85045" id="r_ae1ec29d91ae6c6a21a09cdaf95a85045"><td class="memItemLeft" align="right" valign="top"><a id="ae1ec29d91ae6c6a21a09cdaf95a85045" name="ae1ec29d91ae6c6a21a09cdaf95a85045"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cmat4</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;, 4, 4 &gt;</td></tr>
<tr class="memdesc:ae1ec29d91ae6c6a21a09cdaf95a85045"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x4 matrix with real entries. <br /></td></tr>
<tr class="separator:ae1ec29d91ae6c6a21a09cdaf95a85045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f21bd68ba64b172c29d9fce15c8712d" id="r_a1f21bd68ba64b172c29d9fce15c8712d"><td class="memItemLeft" align="right" valign="top"><a id="a1f21bd68ba64b172c29d9fce15c8712d" name="a1f21bd68ba64b172c29d9fce15c8712d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vec2</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, 2 &gt;</td></tr>
<tr class="memdesc:a1f21bd68ba64b172c29d9fce15c8712d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2-dimensional vector with real elements. <br /></td></tr>
<tr class="separator:a1f21bd68ba64b172c29d9fce15c8712d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac512b7e62a96d6b2a94a64e642a34910" id="r_ac512b7e62a96d6b2a94a64e642a34910"><td class="memItemLeft" align="right" valign="top"><a id="ac512b7e62a96d6b2a94a64e642a34910" name="ac512b7e62a96d6b2a94a64e642a34910"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vec3</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, 3 &gt;</td></tr>
<tr class="memdesc:ac512b7e62a96d6b2a94a64e642a34910"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3-dimensional vector with real elements. <br /></td></tr>
<tr class="separator:ac512b7e62a96d6b2a94a64e642a34910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9f34d374aba86cc459926c45825030" id="r_a4c9f34d374aba86cc459926c45825030"><td class="memItemLeft" align="right" valign="top"><a id="a4c9f34d374aba86cc459926c45825030" name="a4c9f34d374aba86cc459926c45825030"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vec4</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, 4 &gt;</td></tr>
<tr class="memdesc:a4c9f34d374aba86cc459926c45825030"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4-dimensional vector with real elements. <br /></td></tr>
<tr class="separator:a4c9f34d374aba86cc459926c45825030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cf1314a448f23b10e74302550ed77f" id="r_a83cf1314a448f23b10e74302550ed77f"><td class="memItemLeft" align="right" valign="top"><a id="a83cf1314a448f23b10e74302550ed77f" name="a83cf1314a448f23b10e74302550ed77f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cvec</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt; &gt;</td></tr>
<tr class="memdesc:a83cf1314a448f23b10e74302550ed77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable size vector with complex elements. <br /></td></tr>
<tr class="separator:a83cf1314a448f23b10e74302550ed77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429fe8925be98f943d69ad693e24c1bb" id="r_a429fe8925be98f943d69ad693e24c1bb"><td class="memItemLeft" align="right" valign="top"><a id="a429fe8925be98f943d69ad693e24c1bb" name="a429fe8925be98f943d69ad693e24c1bb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cvec2</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;, 2 &gt;</td></tr>
<tr class="memdesc:a429fe8925be98f943d69ad693e24c1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2-dimensional vector with complex elements. <br /></td></tr>
<tr class="separator:a429fe8925be98f943d69ad693e24c1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfc48b27b17470d8ac001a9f2008c4a" id="r_a9bfc48b27b17470d8ac001a9f2008c4a"><td class="memItemLeft" align="right" valign="top"><a id="a9bfc48b27b17470d8ac001a9f2008c4a" name="a9bfc48b27b17470d8ac001a9f2008c4a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cvec3</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;, 3 &gt;</td></tr>
<tr class="memdesc:a9bfc48b27b17470d8ac001a9f2008c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3-dimensional vector with complex elements. <br /></td></tr>
<tr class="separator:a9bfc48b27b17470d8ac001a9f2008c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a30c2b68e61ebe0ede42b20f3354145" id="r_a0a30c2b68e61ebe0ede42b20f3354145"><td class="memItemLeft" align="right" valign="top"><a id="a0a30c2b68e61ebe0ede42b20f3354145" name="a0a30c2b68e61ebe0ede42b20f3354145"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cvec4</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;, 4 &gt;</td></tr>
<tr class="memdesc:a0a30c2b68e61ebe0ede42b20f3354145"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4-dimensional vector with complex elements. <br /></td></tr>
<tr class="separator:a0a30c2b68e61ebe0ede42b20f3354145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f1da297b159938c8b3fb2dc9121e0d" id="r_a23f1da297b159938c8b3fb2dc9121e0d"><td class="memTemplParams" colspan="2"><a id="a23f1da297b159938c8b3fb2dc9121e0d" name="a23f1da297b159938c8b3fb2dc9121e0d"></a>
template&lt;typename Type  = real&gt; </td></tr>
<tr class="memitem:a23f1da297b159938c8b3fb2dc9121e0d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bicomplex</b> = <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; Type &gt; &gt;</td></tr>
<tr class="memdesc:a23f1da297b159938c8b3fb2dc9121e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bi-complex number. <br /></td></tr>
<tr class="separator:a23f1da297b159938c8b3fb2dc9121e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049966946220f1f7e5eae57293703066" id="r_a049966946220f1f7e5eae57293703066"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> = double</td></tr>
<tr class="memdesc:a049966946220f1f7e5eae57293703066"><td class="mdescLeft">&#160;</td><td class="mdescRight">A real number, defined as a floating point type.  <br /></td></tr>
<tr class="separator:a049966946220f1f7e5eae57293703066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60d62492ac4137c837c50b1fdc8a904" id="r_ad60d62492ac4137c837c50b1fdc8a904"><td class="memItemLeft" align="right" valign="top"><a id="ad60d62492ac4137c837c50b1fdc8a904" name="ad60d62492ac4137c837c50b1fdc8a904"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>real_function</b> = std::function&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)&gt;</td></tr>
<tr class="memdesc:ad60d62492ac4137c837c50b1fdc8a904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to a real function of real variable. <br /></td></tr>
<tr class="separator:ad60d62492ac4137c837c50b1fdc8a904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7620593d89c6c46fc98e488683382d1" id="r_ae7620593d89c6c46fc98e488683382d1"><td class="memItemLeft" align="right" valign="top"><a id="ae7620593d89c6c46fc98e488683382d1" name="ae7620593d89c6c46fc98e488683382d1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>complex_function</b> = std::function&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;(<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;)&gt;</td></tr>
<tr class="memdesc:ae7620593d89c6c46fc98e488683382d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to a complex function of complex variable. <br /></td></tr>
<tr class="separator:ae7620593d89c6c46fc98e488683382d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a0bafb035970e4921b84f75661e2b1" id="r_ac7a0bafb035970e4921b84f75661e2b1"><td class="memItemLeft" align="right" valign="top"><a id="ac7a0bafb035970e4921b84f75661e2b1" name="ac7a0bafb035970e4921b84f75661e2b1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>stat_function</b> = std::function&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;)&gt;</td></tr>
<tr class="memdesc:ac7a0bafb035970e4921b84f75661e2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to a probability distribution function where the first argument is the variable and the second argument is a vector of the parameters of the distribution. <br /></td></tr>
<tr class="separator:ac7a0bafb035970e4921b84f75661e2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb53498374f76292a3da8bb8c785341" id="r_adcb53498374f76292a3da8bb8c785341"><td class="memItemLeft" align="right" valign="top"><a id="adcb53498374f76292a3da8bb8c785341" name="adcb53498374f76292a3da8bb8c785341"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>polyn_recurr_formula</b> = std::function&lt; <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;(<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;, unsigned int)&gt;</td></tr>
<tr class="memdesc:adcb53498374f76292a3da8bb8c785341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial sequence recurrence formula type Used for computing orthogonal polynomial basis elements. <br /></td></tr>
<tr class="separator:adcb53498374f76292a3da8bb8c785341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f8bd44356f8184466e4cc0d6986fe5" id="r_a99f8bd44356f8184466e4cc0d6986fe5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a99f8bd44356f8184466e4cc0d6986fe5">pseudorandom_function</a> = uint64_t(*)(uint64_t, std::vector&lt; uint64_t &gt; &amp;)</td></tr>
<tr class="memdesc:a99f8bd44356f8184466e4cc0d6986fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer which wraps a pseudorandom generator, taking as input the previous generated value (or seed) and the current state of the algorithm.  <br /></td></tr>
<tr class="separator:a99f8bd44356f8184466e4cc0d6986fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17352cbe273b80ae0f08eac818eba84e" id="r_a17352cbe273b80ae0f08eac818eba84e"><td class="memItemLeft" align="right" valign="top"><a id="a17352cbe273b80ae0f08eac818eba84e" name="a17352cbe273b80ae0f08eac818eba84e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pdf_sampling_function</b> = <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;)</td></tr>
<tr class="memdesc:a17352cbe273b80ae0f08eac818eba84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A p.d.f sampling function taking as input the parameters of the distribution and a pseudorandom number generator. <br /></td></tr>
<tr class="separator:a17352cbe273b80ae0f08eac818eba84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a47d8f770edb576685f4b8752f2eb9760" id="r_a47d8f770edb576685f4b8752f2eb9760"><td class="memItemLeft" align="right" valign="top"><a id="a47d8f770edb576685f4b8752f2eb9760" name="a47d8f770edb576685f4b8752f2eb9760"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a47d8f770edb576685f4b8752f2eb9760">MATH_ERRCODE</a> </td></tr>
<tr class="memdesc:a47d8f770edb576685f4b8752f2eb9760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Math error enumeration. <br /></td></tr>
<tr class="separator:a47d8f770edb576685f4b8752f2eb9760"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8fe375758727a9f9a510a0898d69aaf4" id="r_a8fe375758727a9f9a510a0898d69aaf4"><td class="memTemplParams" colspan="2">template&lt;typename ElementType , typename Type , typename ... Args&gt; </td></tr>
<tr class="memitem:a8fe375758727a9f9a510a0898d69aaf4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a8fe375758727a9f9a510a0898d69aaf4">make_vec</a> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; ElementType &gt; &amp;v, size_t index, Type last)</td></tr>
<tr class="memdesc:a8fe375758727a9f9a510a0898d69aaf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates a vector with a single element at the specified index.  <br /></td></tr>
<tr class="separator:a8fe375758727a9f9a510a0898d69aaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac93661f565556c9740402f262e9a80" id="r_aaac93661f565556c9740402f262e9a80"><td class="memTemplParams" colspan="2">template&lt;typename ElementType , typename Type , typename ... Args&gt; </td></tr>
<tr class="memitem:aaac93661f565556c9740402f262e9a80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aaac93661f565556c9740402f262e9a80">make_vec</a> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; ElementType &gt; &amp;v, size_t index, Type first, Args... elements)</td></tr>
<tr class="memdesc:aaac93661f565556c9740402f262e9a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates a vector with multiple elements using variadic arguments.  <br /></td></tr>
<tr class="separator:aaac93661f565556c9740402f262e9a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5822f6ae7c03a023f79361f9dbb3118b" id="r_a5822f6ae7c03a023f79361f9dbb3118b"><td class="memTemplParams" colspan="2"><a id="a5822f6ae7c03a023f79361f9dbb3118b" name="a5822f6ae7c03a023f79361f9dbb3118b"></a>
template&lt;typename Type , typename ... Args&gt; </td></tr>
<tr class="memitem:a5822f6ae7c03a023f79361f9dbb3118b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_vec</b> (Type first, Args... elements)</td></tr>
<tr class="memdesc:a5822f6ae7c03a023f79361f9dbb3118b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a dynamically allocated vector of type vec&lt;Type&gt; using variadic templates. <br /></td></tr>
<tr class="separator:a5822f6ae7c03a023f79361f9dbb3118b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6629ddaf5a84d7a8f3159b749ef4db0" id="r_ae6629ddaf5a84d7a8f3159b749ef4db0"><td class="memItemLeft" align="right" valign="top"><a id="ae6629ddaf5a84d7a8f3159b749ef4db0" name="ae6629ddaf5a84d7a8f3159b749ef4db0"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>square</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:ae6629ddaf5a84d7a8f3159b749ef4db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of a second order dual number. <br /></td></tr>
<tr class="separator:ae6629ddaf5a84d7a8f3159b749ef4db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6bc324bd8ae6bbd91b89c7491fe988" id="r_afd6bc324bd8ae6bbd91b89c7491fe988"><td class="memItemLeft" align="right" valign="top"><a id="afd6bc324bd8ae6bbd91b89c7491fe988" name="afd6bc324bd8ae6bbd91b89c7491fe988"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cube</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:afd6bc324bd8ae6bbd91b89c7491fe988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cube of a second order dual number. <br /></td></tr>
<tr class="separator:afd6bc324bd8ae6bbd91b89c7491fe988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d712fc2f7470e40f65fd470cbb6982" id="r_a60d712fc2f7470e40f65fd470cbb6982"><td class="memItemLeft" align="right" valign="top"><a id="a60d712fc2f7470e40f65fd470cbb6982" name="a60d712fc2f7470e40f65fd470cbb6982"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>conjugate</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a60d712fc2f7470e40f65fd470cbb6982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the conjugate of a second order dual number. <br /></td></tr>
<tr class="separator:a60d712fc2f7470e40f65fd470cbb6982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce493c565b387c0496eff49e137edb6" id="r_afce493c565b387c0496eff49e137edb6"><td class="memItemLeft" align="right" valign="top"><a id="afce493c565b387c0496eff49e137edb6" name="afce493c565b387c0496eff49e137edb6"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pow</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x, int n)</td></tr>
<tr class="memdesc:afce493c565b387c0496eff49e137edb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th power of a second order dual number. <br /></td></tr>
<tr class="separator:afce493c565b387c0496eff49e137edb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dd33456cffdbba3f29d85061779e7c" id="r_a19dd33456cffdbba3f29d85061779e7c"><td class="memItemLeft" align="right" valign="top"><a id="a19dd33456cffdbba3f29d85061779e7c" name="a19dd33456cffdbba3f29d85061779e7c"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sqrt</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a19dd33456cffdbba3f29d85061779e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of a second order dual number. <br /></td></tr>
<tr class="separator:a19dd33456cffdbba3f29d85061779e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a34ba6bb56c26ba50c1b2c21d2da7e" id="r_ad7a34ba6bb56c26ba50c1b2c21d2da7e"><td class="memItemLeft" align="right" valign="top"><a id="ad7a34ba6bb56c26ba50c1b2c21d2da7e" name="ad7a34ba6bb56c26ba50c1b2c21d2da7e"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sin</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:ad7a34ba6bb56c26ba50c1b2c21d2da7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of a second order dual number. <br /></td></tr>
<tr class="separator:ad7a34ba6bb56c26ba50c1b2c21d2da7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97cec74fe963806729cbdd0d43de5cd3" id="r_a97cec74fe963806729cbdd0d43de5cd3"><td class="memItemLeft" align="right" valign="top"><a id="a97cec74fe963806729cbdd0d43de5cd3" name="a97cec74fe963806729cbdd0d43de5cd3"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cos</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a97cec74fe963806729cbdd0d43de5cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of a second order dual number. <br /></td></tr>
<tr class="separator:a97cec74fe963806729cbdd0d43de5cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81dcde719b69b4d63ecd3127cb289d9" id="r_ac81dcde719b69b4d63ecd3127cb289d9"><td class="memItemLeft" align="right" valign="top"><a id="ac81dcde719b69b4d63ecd3127cb289d9" name="ac81dcde719b69b4d63ecd3127cb289d9"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tan</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:ac81dcde719b69b4d63ecd3127cb289d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of a second order dual number. <br /></td></tr>
<tr class="separator:ac81dcde719b69b4d63ecd3127cb289d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5fed4cfa9af5d148c59a6005422edc" id="r_a9d5fed4cfa9af5d148c59a6005422edc"><td class="memItemLeft" align="right" valign="top"><a id="a9d5fed4cfa9af5d148c59a6005422edc" name="a9d5fed4cfa9af5d148c59a6005422edc"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cot</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a9d5fed4cfa9af5d148c59a6005422edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cotangent of a second order dual number. <br /></td></tr>
<tr class="separator:a9d5fed4cfa9af5d148c59a6005422edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3def790003197bb019f5933b4db45c44" id="r_a3def790003197bb019f5933b4db45c44"><td class="memItemLeft" align="right" valign="top"><a id="a3def790003197bb019f5933b4db45c44" name="a3def790003197bb019f5933b4db45c44"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>exp</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a3def790003197bb019f5933b4db45c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of a second order dual number. <br /></td></tr>
<tr class="separator:a3def790003197bb019f5933b4db45c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec5b4f8c9f0d58d65415cec30915d16" id="r_a1ec5b4f8c9f0d58d65415cec30915d16"><td class="memItemLeft" align="right" valign="top"><a id="a1ec5b4f8c9f0d58d65415cec30915d16" name="a1ec5b4f8c9f0d58d65415cec30915d16"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ln</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a1ec5b4f8c9f0d58d65415cec30915d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a second order dual number. <br /></td></tr>
<tr class="separator:a1ec5b4f8c9f0d58d65415cec30915d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e46804be47f0c4865014a4a763cf76" id="r_a29e46804be47f0c4865014a4a763cf76"><td class="memItemLeft" align="right" valign="top"><a id="a29e46804be47f0c4865014a4a763cf76" name="a29e46804be47f0c4865014a4a763cf76"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>log2</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a29e46804be47f0c4865014a4a763cf76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a second order dual number. <br /></td></tr>
<tr class="separator:a29e46804be47f0c4865014a4a763cf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5101414a44ee9cfda63aea95ea40ef97" id="r_a5101414a44ee9cfda63aea95ea40ef97"><td class="memItemLeft" align="right" valign="top"><a id="a5101414a44ee9cfda63aea95ea40ef97" name="a5101414a44ee9cfda63aea95ea40ef97"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>log10</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a5101414a44ee9cfda63aea95ea40ef97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a second order dual number. <br /></td></tr>
<tr class="separator:a5101414a44ee9cfda63aea95ea40ef97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29720d3e71b280bb3ea048aa71bc3655" id="r_a29720d3e71b280bb3ea048aa71bc3655"><td class="memItemLeft" align="right" valign="top"><a id="a29720d3e71b280bb3ea048aa71bc3655" name="a29720d3e71b280bb3ea048aa71bc3655"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>abs</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a29720d3e71b280bb3ea048aa71bc3655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of a second order dual number. <br /></td></tr>
<tr class="separator:a29720d3e71b280bb3ea048aa71bc3655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3761005d81ac85b7297426bfc3f62ea2" id="r_a3761005d81ac85b7297426bfc3f62ea2"><td class="memItemLeft" align="right" valign="top"><a id="a3761005d81ac85b7297426bfc3f62ea2" name="a3761005d81ac85b7297426bfc3f62ea2"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>asin</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a3761005d81ac85b7297426bfc3f62ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcsine of a second order dual number. <br /></td></tr>
<tr class="separator:a3761005d81ac85b7297426bfc3f62ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf13d7437b2dbea2212cbff3d519b9e5" id="r_acf13d7437b2dbea2212cbff3d519b9e5"><td class="memItemLeft" align="right" valign="top"><a id="acf13d7437b2dbea2212cbff3d519b9e5" name="acf13d7437b2dbea2212cbff3d519b9e5"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>acos</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:acf13d7437b2dbea2212cbff3d519b9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcosine of a second order dual number. <br /></td></tr>
<tr class="separator:acf13d7437b2dbea2212cbff3d519b9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0493013e208bb00505abbc4ca37f292" id="r_af0493013e208bb00505abbc4ca37f292"><td class="memItemLeft" align="right" valign="top"><a id="af0493013e208bb00505abbc4ca37f292" name="af0493013e208bb00505abbc4ca37f292"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>atan</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:af0493013e208bb00505abbc4ca37f292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arctangent of a second order dual number. <br /></td></tr>
<tr class="separator:af0493013e208bb00505abbc4ca37f292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f05865ec8d49e6abf889d81e1cd428" id="r_ad5f05865ec8d49e6abf889d81e1cd428"><td class="memItemLeft" align="right" valign="top"><a id="ad5f05865ec8d49e6abf889d81e1cd428" name="ad5f05865ec8d49e6abf889d81e1cd428"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>square</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:ad5f05865ec8d49e6abf889d81e1cd428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of a dual number. <br /></td></tr>
<tr class="separator:ad5f05865ec8d49e6abf889d81e1cd428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab28b5c479cfd017f81b9806aa27838e" id="r_aab28b5c479cfd017f81b9806aa27838e"><td class="memItemLeft" align="right" valign="top"><a id="aab28b5c479cfd017f81b9806aa27838e" name="aab28b5c479cfd017f81b9806aa27838e"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cube</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:aab28b5c479cfd017f81b9806aa27838e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cube of a dual number. <br /></td></tr>
<tr class="separator:aab28b5c479cfd017f81b9806aa27838e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7b08c40c17a7b35ba2b1e3c6c3357b" id="r_aec7b08c40c17a7b35ba2b1e3c6c3357b"><td class="memItemLeft" align="right" valign="top"><a id="aec7b08c40c17a7b35ba2b1e3c6c3357b" name="aec7b08c40c17a7b35ba2b1e3c6c3357b"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>conjugate</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:aec7b08c40c17a7b35ba2b1e3c6c3357b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the conjugate of a dual number. <br /></td></tr>
<tr class="separator:aec7b08c40c17a7b35ba2b1e3c6c3357b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad063ce053e951e9183799584090c0e" id="r_a4ad063ce053e951e9183799584090c0e"><td class="memItemLeft" align="right" valign="top"><a id="a4ad063ce053e951e9183799584090c0e" name="a4ad063ce053e951e9183799584090c0e"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pow</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x, int n)</td></tr>
<tr class="memdesc:a4ad063ce053e951e9183799584090c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th power of a dual number. <br /></td></tr>
<tr class="separator:a4ad063ce053e951e9183799584090c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e64e0c5a3452708528e6fb46f97b84e" id="r_a6e64e0c5a3452708528e6fb46f97b84e"><td class="memItemLeft" align="right" valign="top"><a id="a6e64e0c5a3452708528e6fb46f97b84e" name="a6e64e0c5a3452708528e6fb46f97b84e"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sqrt</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a6e64e0c5a3452708528e6fb46f97b84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of a dual number. <br /></td></tr>
<tr class="separator:a6e64e0c5a3452708528e6fb46f97b84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8369c63cfe1b787c3916865de1ac534b" id="r_a8369c63cfe1b787c3916865de1ac534b"><td class="memItemLeft" align="right" valign="top"><a id="a8369c63cfe1b787c3916865de1ac534b" name="a8369c63cfe1b787c3916865de1ac534b"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sin</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a8369c63cfe1b787c3916865de1ac534b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of a dual number. <br /></td></tr>
<tr class="separator:a8369c63cfe1b787c3916865de1ac534b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39630b09f7294762464b1eb5301b508f" id="r_a39630b09f7294762464b1eb5301b508f"><td class="memItemLeft" align="right" valign="top"><a id="a39630b09f7294762464b1eb5301b508f" name="a39630b09f7294762464b1eb5301b508f"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cos</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a39630b09f7294762464b1eb5301b508f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of a dual number. <br /></td></tr>
<tr class="separator:a39630b09f7294762464b1eb5301b508f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef33e5920ccf4cfe7f79c70ebc9dfbb" id="r_afef33e5920ccf4cfe7f79c70ebc9dfbb"><td class="memItemLeft" align="right" valign="top"><a id="afef33e5920ccf4cfe7f79c70ebc9dfbb" name="afef33e5920ccf4cfe7f79c70ebc9dfbb"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tan</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:afef33e5920ccf4cfe7f79c70ebc9dfbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of a dual number. <br /></td></tr>
<tr class="separator:afef33e5920ccf4cfe7f79c70ebc9dfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf17b1485bdfb0f967caee134136b6" id="r_aacdf17b1485bdfb0f967caee134136b6"><td class="memItemLeft" align="right" valign="top"><a id="aacdf17b1485bdfb0f967caee134136b6" name="aacdf17b1485bdfb0f967caee134136b6"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cot</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:aacdf17b1485bdfb0f967caee134136b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cotangent of a dual number. <br /></td></tr>
<tr class="separator:aacdf17b1485bdfb0f967caee134136b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21974bc022495f59a7702ce937f4544c" id="r_a21974bc022495f59a7702ce937f4544c"><td class="memItemLeft" align="right" valign="top"><a id="a21974bc022495f59a7702ce937f4544c" name="a21974bc022495f59a7702ce937f4544c"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>exp</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a21974bc022495f59a7702ce937f4544c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of a dual number. <br /></td></tr>
<tr class="separator:a21974bc022495f59a7702ce937f4544c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acf40b0d2b7e4f62d95dd4bec0b169d" id="r_a8acf40b0d2b7e4f62d95dd4bec0b169d"><td class="memItemLeft" align="right" valign="top"><a id="a8acf40b0d2b7e4f62d95dd4bec0b169d" name="a8acf40b0d2b7e4f62d95dd4bec0b169d"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ln</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a8acf40b0d2b7e4f62d95dd4bec0b169d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a dual number. <br /></td></tr>
<tr class="separator:a8acf40b0d2b7e4f62d95dd4bec0b169d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d6466e16b24bd1dfac49fd0c50ed79" id="r_a30d6466e16b24bd1dfac49fd0c50ed79"><td class="memItemLeft" align="right" valign="top"><a id="a30d6466e16b24bd1dfac49fd0c50ed79" name="a30d6466e16b24bd1dfac49fd0c50ed79"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>log2</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a30d6466e16b24bd1dfac49fd0c50ed79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a dual number. <br /></td></tr>
<tr class="separator:a30d6466e16b24bd1dfac49fd0c50ed79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254b955eacdab15792dcb9d871559499" id="r_a254b955eacdab15792dcb9d871559499"><td class="memItemLeft" align="right" valign="top"><a id="a254b955eacdab15792dcb9d871559499" name="a254b955eacdab15792dcb9d871559499"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>log10</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a254b955eacdab15792dcb9d871559499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a dual number. <br /></td></tr>
<tr class="separator:a254b955eacdab15792dcb9d871559499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3796818092440b5f1745c67b1162ddcf" id="r_a3796818092440b5f1745c67b1162ddcf"><td class="memItemLeft" align="right" valign="top"><a id="a3796818092440b5f1745c67b1162ddcf" name="a3796818092440b5f1745c67b1162ddcf"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>abs</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a3796818092440b5f1745c67b1162ddcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of a dual number. <br /></td></tr>
<tr class="separator:a3796818092440b5f1745c67b1162ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892e7542b82c516e65023555a0e30f6b" id="r_a892e7542b82c516e65023555a0e30f6b"><td class="memItemLeft" align="right" valign="top"><a id="a892e7542b82c516e65023555a0e30f6b" name="a892e7542b82c516e65023555a0e30f6b"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>asin</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a892e7542b82c516e65023555a0e30f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcsine of a dual number. <br /></td></tr>
<tr class="separator:a892e7542b82c516e65023555a0e30f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7f07a4d7a0abca49824b5926f259f1" id="r_abd7f07a4d7a0abca49824b5926f259f1"><td class="memItemLeft" align="right" valign="top"><a id="abd7f07a4d7a0abca49824b5926f259f1" name="abd7f07a4d7a0abca49824b5926f259f1"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>acos</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:abd7f07a4d7a0abca49824b5926f259f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arccosine of a dual number. <br /></td></tr>
<tr class="separator:abd7f07a4d7a0abca49824b5926f259f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9ae8cb187999582be3db40cf149f43" id="r_a6b9ae8cb187999582be3db40cf149f43"><td class="memItemLeft" align="right" valign="top"><a id="a6b9ae8cb187999582be3db40cf149f43" name="a6b9ae8cb187999582be3db40cf149f43"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>atan</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a6b9ae8cb187999582be3db40cf149f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arctangent of a dual number. <br /></td></tr>
<tr class="separator:a6b9ae8cb187999582be3db40cf149f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8c95ef4ed4e4da6af87e9eee675f82" id="r_a1f8c95ef4ed4e4da6af87e9eee675f82"><td class="memItemLeft" align="right" valign="top"><a id="a1f8c95ef4ed4e4da6af87e9eee675f82" name="a1f8c95ef4ed4e4da6af87e9eee675f82"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sinh</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a1f8c95ef4ed4e4da6af87e9eee675f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic sine of a dual number. <br /></td></tr>
<tr class="separator:a1f8c95ef4ed4e4da6af87e9eee675f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8d81973a127a1e66c180cba58d08ee" id="r_a1b8d81973a127a1e66c180cba58d08ee"><td class="memItemLeft" align="right" valign="top"><a id="a1b8d81973a127a1e66c180cba58d08ee" name="a1b8d81973a127a1e66c180cba58d08ee"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cosh</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a1b8d81973a127a1e66c180cba58d08ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic cosine of a dual number. <br /></td></tr>
<tr class="separator:a1b8d81973a127a1e66c180cba58d08ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf2c5dcfac28891e1e8a3accdf7dd21" id="r_afbf2c5dcfac28891e1e8a3accdf7dd21"><td class="memItemLeft" align="right" valign="top"><a id="afbf2c5dcfac28891e1e8a3accdf7dd21" name="afbf2c5dcfac28891e1e8a3accdf7dd21"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tanh</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:afbf2c5dcfac28891e1e8a3accdf7dd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic tangent of a dual number. <br /></td></tr>
<tr class="separator:afbf2c5dcfac28891e1e8a3accdf7dd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab864254bd5f629822f3d1fcee3cff6b7" id="r_ab864254bd5f629822f3d1fcee3cff6b7"><td class="memTemplParams" colspan="2"><a id="ab864254bd5f629822f3d1fcee3cff6b7" name="ab864254bd5f629822f3d1fcee3cff6b7"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ab864254bd5f629822f3d1fcee3cff6b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>square</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ab864254bd5f629822f3d1fcee3cff6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of a multidual number. <br /></td></tr>
<tr class="separator:ab864254bd5f629822f3d1fcee3cff6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae356adeb60d93c78bd5d27ddf49a6c66" id="r_ae356adeb60d93c78bd5d27ddf49a6c66"><td class="memTemplParams" colspan="2"><a id="ae356adeb60d93c78bd5d27ddf49a6c66" name="ae356adeb60d93c78bd5d27ddf49a6c66"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ae356adeb60d93c78bd5d27ddf49a6c66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cube</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ae356adeb60d93c78bd5d27ddf49a6c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cube of a multidual number. <br /></td></tr>
<tr class="separator:ae356adeb60d93c78bd5d27ddf49a6c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab554a86db7527158fdd4f3fa000989af" id="r_ab554a86db7527158fdd4f3fa000989af"><td class="memTemplParams" colspan="2"><a id="ab554a86db7527158fdd4f3fa000989af" name="ab554a86db7527158fdd4f3fa000989af"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ab554a86db7527158fdd4f3fa000989af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conjugate</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ab554a86db7527158fdd4f3fa000989af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the conjugate of a multidual number. <br /></td></tr>
<tr class="separator:ab554a86db7527158fdd4f3fa000989af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb716c77e812d83d2aed787ff39b62e" id="r_adfb716c77e812d83d2aed787ff39b62e"><td class="memTemplParams" colspan="2"><a id="adfb716c77e812d83d2aed787ff39b62e" name="adfb716c77e812d83d2aed787ff39b62e"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:adfb716c77e812d83d2aed787ff39b62e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pow</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x, int n)</td></tr>
<tr class="memdesc:adfb716c77e812d83d2aed787ff39b62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th power of a multidual number. <br /></td></tr>
<tr class="separator:adfb716c77e812d83d2aed787ff39b62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaa215522430587c6c8dc7971269fb5" id="r_a8aaa215522430587c6c8dc7971269fb5"><td class="memTemplParams" colspan="2"><a id="a8aaa215522430587c6c8dc7971269fb5" name="a8aaa215522430587c6c8dc7971269fb5"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a8aaa215522430587c6c8dc7971269fb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sqrt</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a8aaa215522430587c6c8dc7971269fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of a multidual number. <br /></td></tr>
<tr class="separator:a8aaa215522430587c6c8dc7971269fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1444ff9faf0b4b247468462d7b7cb01" id="r_af1444ff9faf0b4b247468462d7b7cb01"><td class="memTemplParams" colspan="2"><a id="af1444ff9faf0b4b247468462d7b7cb01" name="af1444ff9faf0b4b247468462d7b7cb01"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:af1444ff9faf0b4b247468462d7b7cb01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sin</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:af1444ff9faf0b4b247468462d7b7cb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of a multidual number. <br /></td></tr>
<tr class="separator:af1444ff9faf0b4b247468462d7b7cb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ac8631aae8f4c3ae5dc63cbabc57c8" id="r_ac8ac8631aae8f4c3ae5dc63cbabc57c8"><td class="memTemplParams" colspan="2"><a id="ac8ac8631aae8f4c3ae5dc63cbabc57c8" name="ac8ac8631aae8f4c3ae5dc63cbabc57c8"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ac8ac8631aae8f4c3ae5dc63cbabc57c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cos</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ac8ac8631aae8f4c3ae5dc63cbabc57c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of a multidual number. <br /></td></tr>
<tr class="separator:ac8ac8631aae8f4c3ae5dc63cbabc57c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe9ca76dc4db09890a618a1d77da20b" id="r_aafe9ca76dc4db09890a618a1d77da20b"><td class="memTemplParams" colspan="2"><a id="aafe9ca76dc4db09890a618a1d77da20b" name="aafe9ca76dc4db09890a618a1d77da20b"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aafe9ca76dc4db09890a618a1d77da20b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tan</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:aafe9ca76dc4db09890a618a1d77da20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of a multidual number. <br /></td></tr>
<tr class="separator:aafe9ca76dc4db09890a618a1d77da20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8839aa97612a40db14f1c8818b463d0" id="r_ac8839aa97612a40db14f1c8818b463d0"><td class="memTemplParams" colspan="2"><a id="ac8839aa97612a40db14f1c8818b463d0" name="ac8839aa97612a40db14f1c8818b463d0"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ac8839aa97612a40db14f1c8818b463d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cot</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ac8839aa97612a40db14f1c8818b463d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cotangent of a multidual number. <br /></td></tr>
<tr class="separator:ac8839aa97612a40db14f1c8818b463d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311ed7edb65295b9284b3f10e5fa5f90" id="r_a311ed7edb65295b9284b3f10e5fa5f90"><td class="memTemplParams" colspan="2"><a id="a311ed7edb65295b9284b3f10e5fa5f90" name="a311ed7edb65295b9284b3f10e5fa5f90"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a311ed7edb65295b9284b3f10e5fa5f90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exp</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a311ed7edb65295b9284b3f10e5fa5f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of a multidual number. <br /></td></tr>
<tr class="separator:a311ed7edb65295b9284b3f10e5fa5f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecb01797f9cac464a6dea02d5a73e34" id="r_adecb01797f9cac464a6dea02d5a73e34"><td class="memTemplParams" colspan="2"><a id="adecb01797f9cac464a6dea02d5a73e34" name="adecb01797f9cac464a6dea02d5a73e34"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:adecb01797f9cac464a6dea02d5a73e34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ln</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:adecb01797f9cac464a6dea02d5a73e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a multidual number. <br /></td></tr>
<tr class="separator:adecb01797f9cac464a6dea02d5a73e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84cf28a3ec07fef45f28617946e62961" id="r_a84cf28a3ec07fef45f28617946e62961"><td class="memTemplParams" colspan="2"><a id="a84cf28a3ec07fef45f28617946e62961" name="a84cf28a3ec07fef45f28617946e62961"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a84cf28a3ec07fef45f28617946e62961"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log2</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a84cf28a3ec07fef45f28617946e62961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a multidual number. <br /></td></tr>
<tr class="separator:a84cf28a3ec07fef45f28617946e62961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace737cd7c21a314c33915adf9956a640" id="r_ace737cd7c21a314c33915adf9956a640"><td class="memTemplParams" colspan="2"><a id="ace737cd7c21a314c33915adf9956a640" name="ace737cd7c21a314c33915adf9956a640"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ace737cd7c21a314c33915adf9956a640"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log10</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ace737cd7c21a314c33915adf9956a640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a multidual number. <br /></td></tr>
<tr class="separator:ace737cd7c21a314c33915adf9956a640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb87636665493a0584655ad754e4c53" id="r_a4eb87636665493a0584655ad754e4c53"><td class="memTemplParams" colspan="2"><a id="a4eb87636665493a0584655ad754e4c53" name="a4eb87636665493a0584655ad754e4c53"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a4eb87636665493a0584655ad754e4c53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a4eb87636665493a0584655ad754e4c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of a multidual number. <br /></td></tr>
<tr class="separator:a4eb87636665493a0584655ad754e4c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9fac1b91317d696fc2b4ea479b30b9" id="r_a5b9fac1b91317d696fc2b4ea479b30b9"><td class="memTemplParams" colspan="2"><a id="a5b9fac1b91317d696fc2b4ea479b30b9" name="a5b9fac1b91317d696fc2b4ea479b30b9"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a5b9fac1b91317d696fc2b4ea479b30b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>asin</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a5b9fac1b91317d696fc2b4ea479b30b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcsine of a multidual number. <br /></td></tr>
<tr class="separator:a5b9fac1b91317d696fc2b4ea479b30b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf0ac356621f93c30fc6bdd9a1977a3" id="r_afcf0ac356621f93c30fc6bdd9a1977a3"><td class="memTemplParams" colspan="2"><a id="afcf0ac356621f93c30fc6bdd9a1977a3" name="afcf0ac356621f93c30fc6bdd9a1977a3"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:afcf0ac356621f93c30fc6bdd9a1977a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>acos</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:afcf0ac356621f93c30fc6bdd9a1977a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arccosine of a multidual number. <br /></td></tr>
<tr class="separator:afcf0ac356621f93c30fc6bdd9a1977a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f31ace8ee7a5730ba7f0b1a60df5835" id="r_a0f31ace8ee7a5730ba7f0b1a60df5835"><td class="memTemplParams" colspan="2"><a id="a0f31ace8ee7a5730ba7f0b1a60df5835" name="a0f31ace8ee7a5730ba7f0b1a60df5835"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a0f31ace8ee7a5730ba7f0b1a60df5835"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>atan</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a0f31ace8ee7a5730ba7f0b1a60df5835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arctangent of a multidual number. <br /></td></tr>
<tr class="separator:a0f31ace8ee7a5730ba7f0b1a60df5835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c71523f7f9d97e48c2de258ef952500" id="r_a8c71523f7f9d97e48c2de258ef952500"><td class="memTemplParams" colspan="2"><a id="a8c71523f7f9d97e48c2de258ef952500" name="a8c71523f7f9d97e48c2de258ef952500"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a8c71523f7f9d97e48c2de258ef952500"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sinh</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a8c71523f7f9d97e48c2de258ef952500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic sine of a multidual number. <br /></td></tr>
<tr class="separator:a8c71523f7f9d97e48c2de258ef952500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b0ad9b86faf6ab2d308f9f76d31010" id="r_ae2b0ad9b86faf6ab2d308f9f76d31010"><td class="memTemplParams" colspan="2"><a id="ae2b0ad9b86faf6ab2d308f9f76d31010" name="ae2b0ad9b86faf6ab2d308f9f76d31010"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ae2b0ad9b86faf6ab2d308f9f76d31010"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cosh</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ae2b0ad9b86faf6ab2d308f9f76d31010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic cosine of a multidual number. <br /></td></tr>
<tr class="separator:ae2b0ad9b86faf6ab2d308f9f76d31010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa990eeebdd5fb8e93c96c4ed6ff91317" id="r_aa990eeebdd5fb8e93c96c4ed6ff91317"><td class="memTemplParams" colspan="2"><a id="aa990eeebdd5fb8e93c96c4ed6ff91317" name="aa990eeebdd5fb8e93c96c4ed6ff91317"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aa990eeebdd5fb8e93c96c4ed6ff91317"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tanh</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:aa990eeebdd5fb8e93c96c4ed6ff91317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic tangent of a multidual number. <br /></td></tr>
<tr class="separator:aa990eeebdd5fb8e93c96c4ed6ff91317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae231f0ed7d65026e95d86dad20498113" id="r_ae231f0ed7d65026e95d86dad20498113"><td class="memTemplParams" colspan="2">template&lt;typename Field  = real&gt; </td></tr>
<tr class="memitem:ae231f0ed7d65026e95d86dad20498113"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; Field &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ae231f0ed7d65026e95d86dad20498113">deriv</a> (const <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; Field &gt; &amp;p)</td></tr>
<tr class="memdesc:ae231f0ed7d65026e95d86dad20498113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exact derivative of a polynomial function.  <br /></td></tr>
<tr class="separator:ae231f0ed7d65026e95d86dad20498113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6a820d42c7b057384b9eb88fc312f3" id="r_a6e6a820d42c7b057384b9eb88fc312f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6e6a820d42c7b057384b9eb88fc312f3">deriv</a> (const <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;p, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a6e6a820d42c7b057384b9eb88fc312f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exact derivative of a polynomial function at the given point.  <br /></td></tr>
<tr class="separator:a6e6a820d42c7b057384b9eb88fc312f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f7dff89fe2dd3e8124c10ff19bd0ed" id="r_aa6f7dff89fe2dd3e8124c10ff19bd0ed"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction  = std::function&lt;real(real)&gt;, enable_real_func&lt; RealFunction &gt;  = true&gt; </td></tr>
<tr class="memitem:aa6f7dff89fe2dd3e8124c10ff19bd0ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa6f7dff89fe2dd3e8124c10ff19bd0ed">deriv_central</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=<a class="el" href="namespacetheoretica.html#a6041e735f753a4888a2eec14a79ebc09">CALCULUS_DERIV_STEP</a>)</td></tr>
<tr class="memdesc:aa6f7dff89fe2dd3e8124c10ff19bd0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the first derivative of a real function using the central method.  <br /></td></tr>
<tr class="separator:aa6f7dff89fe2dd3e8124c10ff19bd0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383ecbb074d735f5b5e8a2f45e5eb291" id="r_a383ecbb074d735f5b5e8a2f45e5eb291"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction  = std::function&lt;real(real)&gt;, enable_real_func&lt; RealFunction &gt;  = true&gt; </td></tr>
<tr class="memitem:a383ecbb074d735f5b5e8a2f45e5eb291"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a383ecbb074d735f5b5e8a2f45e5eb291">deriv_forward</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=<a class="el" href="namespacetheoretica.html#a6041e735f753a4888a2eec14a79ebc09">CALCULUS_DERIV_STEP</a>)</td></tr>
<tr class="memdesc:a383ecbb074d735f5b5e8a2f45e5eb291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the first derivative of a real function using the forward method.  <br /></td></tr>
<tr class="separator:a383ecbb074d735f5b5e8a2f45e5eb291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef217e4310f467330d0a18986f70d84" id="r_acef217e4310f467330d0a18986f70d84"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction  = std::function&lt;real(real)&gt;, enable_real_func&lt; RealFunction &gt;  = true&gt; </td></tr>
<tr class="memitem:acef217e4310f467330d0a18986f70d84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#acef217e4310f467330d0a18986f70d84">deriv_backward</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=<a class="el" href="namespacetheoretica.html#a6041e735f753a4888a2eec14a79ebc09">CALCULUS_DERIV_STEP</a>)</td></tr>
<tr class="memdesc:acef217e4310f467330d0a18986f70d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the first derivative of a real function using the backward method.  <br /></td></tr>
<tr class="separator:acef217e4310f467330d0a18986f70d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c49b5e16e7366e0299972a87e3eb641" id="r_a9c49b5e16e7366e0299972a87e3eb641"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction  = std::function&lt;real(real)&gt;, enable_real_func&lt; RealFunction &gt;  = true&gt; </td></tr>
<tr class="memitem:a9c49b5e16e7366e0299972a87e3eb641"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a9c49b5e16e7366e0299972a87e3eb641">deriv_ridders2</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=<a class="el" href="namespacetheoretica.html#a6041e735f753a4888a2eec14a79ebc09">CALCULUS_DERIV_STEP</a>)</td></tr>
<tr class="memdesc:a9c49b5e16e7366e0299972a87e3eb641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the first derivative of a real function using Ridder's method of second degree.  <br /></td></tr>
<tr class="separator:a9c49b5e16e7366e0299972a87e3eb641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989e6f0a6fd6fe05664b6d5de8aaaaf5" id="r_a989e6f0a6fd6fe05664b6d5de8aaaaf5"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction  = std::function&lt;real(real)&gt;, enable_real_func&lt; RealFunction &gt;  = true&gt; </td></tr>
<tr class="memitem:a989e6f0a6fd6fe05664b6d5de8aaaaf5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a989e6f0a6fd6fe05664b6d5de8aaaaf5">deriv_ridders</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=0.01, unsigned int degree=3)</td></tr>
<tr class="memdesc:a989e6f0a6fd6fe05664b6d5de8aaaaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the first derivative of a real function using Ridder's method of arbitrary degree.  <br /></td></tr>
<tr class="separator:a989e6f0a6fd6fe05664b6d5de8aaaaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69edeaa0ec50e54eeaf1473f83582a68" id="r_a69edeaa0ec50e54eeaf1473f83582a68"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction  = std::function&lt;real(real)&gt;, enable_real_func&lt; RealFunction &gt;  = true&gt; </td></tr>
<tr class="memitem:a69edeaa0ec50e54eeaf1473f83582a68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a69edeaa0ec50e54eeaf1473f83582a68">deriv</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=<a class="el" href="namespacetheoretica.html#a6041e735f753a4888a2eec14a79ebc09">CALCULUS_DERIV_STEP</a>)</td></tr>
<tr class="memdesc:a69edeaa0ec50e54eeaf1473f83582a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the first derivative of a real function using the best available algorithm.  <br /></td></tr>
<tr class="separator:a69edeaa0ec50e54eeaf1473f83582a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac470f622545e9f044b6099d96222532f" id="r_ac470f622545e9f044b6099d96222532f"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction  = std::function&lt;real(real)&gt;, enable_real_func&lt; RealFunction &gt;  = true&gt; </td></tr>
<tr class="memitem:ac470f622545e9f044b6099d96222532f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac470f622545e9f044b6099d96222532f">deriv2</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=<a class="el" href="namespacetheoretica.html#a6041e735f753a4888a2eec14a79ebc09">CALCULUS_DERIV_STEP</a>)</td></tr>
<tr class="memdesc:ac470f622545e9f044b6099d96222532f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the second derivative of a real function using the best available algorithm.  <br /></td></tr>
<tr class="separator:ac470f622545e9f044b6099d96222532f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3ddf8709dd260dcaee46719dc7f648" id="r_aaf3ddf8709dd260dcaee46719dc7f648"><td class="memTemplParams" colspan="2">template&lt;typename Field  = real&gt; </td></tr>
<tr class="memitem:aaf3ddf8709dd260dcaee46719dc7f648"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; Field &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aaf3ddf8709dd260dcaee46719dc7f648">integral</a> (const <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; Field &gt; &amp;p)</td></tr>
<tr class="memdesc:aaf3ddf8709dd260dcaee46719dc7f648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the indefinite integral of a polynomial.  <br /></td></tr>
<tr class="separator:aaf3ddf8709dd260dcaee46719dc7f648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0e87bfeb1a4e484de143465a263465" id="r_a9f0e87bfeb1a4e484de143465a263465"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a9f0e87bfeb1a4e484de143465a263465">integral</a> (const <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;p, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:a9f0e87bfeb1a4e484de143465a263465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the definite integral of a polynomial over an interval.  <br /></td></tr>
<tr class="separator:a9f0e87bfeb1a4e484de143465a263465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48153156a44ef0245d23491aed11f81" id="r_ae48153156a44ef0245d23491aed11f81"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:ae48153156a44ef0245d23491aed11f81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ae48153156a44ef0245d23491aed11f81">integral_midpoint</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int steps=<a class="el" href="namespacetheoretica.html#a92f59d0debe6a7cbdee72b28d4d53f16">CALCULUS_INTEGRAL_STEPS</a>)</td></tr>
<tr class="memdesc:ae48153156a44ef0245d23491aed11f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the definite integral of an arbitrary function using the midpoint method.  <br /></td></tr>
<tr class="separator:ae48153156a44ef0245d23491aed11f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a89464c8faa686a7c8ade2df812493" id="r_aa4a89464c8faa686a7c8ade2df812493"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:aa4a89464c8faa686a7c8ade2df812493"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa4a89464c8faa686a7c8ade2df812493">integral_trapezoid</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int steps=<a class="el" href="namespacetheoretica.html#a92f59d0debe6a7cbdee72b28d4d53f16">CALCULUS_INTEGRAL_STEPS</a>)</td></tr>
<tr class="memdesc:aa4a89464c8faa686a7c8ade2df812493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the definite integral of an arbitrary function using the trapezoid method.  <br /></td></tr>
<tr class="separator:aa4a89464c8faa686a7c8ade2df812493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1c46c8f4022243fe207b05518c2740" id="r_acc1c46c8f4022243fe207b05518c2740"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:acc1c46c8f4022243fe207b05518c2740"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#acc1c46c8f4022243fe207b05518c2740">integral_simpson</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int steps=<a class="el" href="namespacetheoretica.html#a92f59d0debe6a7cbdee72b28d4d53f16">CALCULUS_INTEGRAL_STEPS</a>)</td></tr>
<tr class="memdesc:acc1c46c8f4022243fe207b05518c2740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the definite integral of an arbitrary function using Simpson's method.  <br /></td></tr>
<tr class="separator:acc1c46c8f4022243fe207b05518c2740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6c51cd5ff6287130ab25a6efbbe2e5" id="r_a8f6c51cd5ff6287130ab25a6efbbe2e5"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a8f6c51cd5ff6287130ab25a6efbbe2e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a8f6c51cd5ff6287130ab25a6efbbe2e5">integral_romberg</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int iter=8)</td></tr>
<tr class="memdesc:a8f6c51cd5ff6287130ab25a6efbbe2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the definite integral of an arbitrary function using Romberg's method accurate to the given order.  <br /></td></tr>
<tr class="separator:a8f6c51cd5ff6287130ab25a6efbbe2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8715f45961d756064be2c06ba4784d4" id="r_aa8715f45961d756064be2c06ba4784d4"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:aa8715f45961d756064be2c06ba4784d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa8715f45961d756064be2c06ba4784d4">integral_romberg_tol</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=CALCULUS_INTEGRAL_TOL)</td></tr>
<tr class="memdesc:aa8715f45961d756064be2c06ba4784d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the definite integral of an arbitrary function using Romberg's method to the given tolerance.  <br /></td></tr>
<tr class="separator:aa8715f45961d756064be2c06ba4784d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bf598b39c148bddb7ceebd7aa9b446" id="r_a96bf598b39c148bddb7ceebd7aa9b446"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a96bf598b39c148bddb7ceebd7aa9b446"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a96bf598b39c148bddb7ceebd7aa9b446">integral_gauss</a> (RealFunction f, const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x, const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;w)</td></tr>
<tr class="memdesc:a96bf598b39c148bddb7ceebd7aa9b446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gaussian quadrature using the given points and weights.  <br /></td></tr>
<tr class="separator:a96bf598b39c148bddb7ceebd7aa9b446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72ca0802148fca511bdb53d2cf958a8" id="r_aa72ca0802148fca511bdb53d2cf958a8"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:aa72ca0802148fca511bdb53d2cf958a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa72ca0802148fca511bdb53d2cf958a8">integral_gauss</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *w, unsigned int n)</td></tr>
<tr class="memdesc:aa72ca0802148fca511bdb53d2cf958a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gaussian quadrature using the given points and weights.  <br /></td></tr>
<tr class="separator:aa72ca0802148fca511bdb53d2cf958a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500bb7c67e29e96e7f6c3655b8f7d3b3" id="r_a500bb7c67e29e96e7f6c3655b8f7d3b3"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a500bb7c67e29e96e7f6c3655b8f7d3b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a500bb7c67e29e96e7f6c3655b8f7d3b3">integral_gauss</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *w, unsigned int n, <a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> Winv)</td></tr>
<tr class="memdesc:a500bb7c67e29e96e7f6c3655b8f7d3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gaussian quadrature using the given points and weights.  <br /></td></tr>
<tr class="separator:a500bb7c67e29e96e7f6c3655b8f7d3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2038787a4650a9610cdf4639901677a" id="r_ad2038787a4650a9610cdf4639901677a"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:ad2038787a4650a9610cdf4639901677a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad2038787a4650a9610cdf4639901677a">integral_legendre</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *w, unsigned int n)</td></tr>
<tr class="memdesc:ad2038787a4650a9610cdf4639901677a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gauss-Legendre quadrature of arbitrary degree to approximate a definite integral providing the roots of the n degree Legendre polynomial.  <br /></td></tr>
<tr class="separator:ad2038787a4650a9610cdf4639901677a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ca5edbbdee0a51f8c0bfddb4c71f69" id="r_a62ca5edbbdee0a51f8c0bfddb4c71f69"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a62ca5edbbdee0a51f8c0bfddb4c71f69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a62ca5edbbdee0a51f8c0bfddb4c71f69">integral_legendre</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x, const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;w)</td></tr>
<tr class="memdesc:a62ca5edbbdee0a51f8c0bfddb4c71f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gauss-Legendre quadrature of arbitrary degree to approximate a definite integral providing the roots of the n degree Legendre polynomial.  <br /></td></tr>
<tr class="separator:a62ca5edbbdee0a51f8c0bfddb4c71f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f79a7b3f80ff901eba3340d1ba14a5" id="r_ad3f79a7b3f80ff901eba3340d1ba14a5"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:ad3f79a7b3f80ff901eba3340d1ba14a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad3f79a7b3f80ff901eba3340d1ba14a5">integral_legendre</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:ad3f79a7b3f80ff901eba3340d1ba14a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gauss-Legendre quadrature of arbitrary degree to approximate a definite integral providing the roots of the n degree Legendre polynomial.  <br /></td></tr>
<tr class="separator:ad3f79a7b3f80ff901eba3340d1ba14a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8406b9711bb256a289bb656c4c52e39" id="r_aa8406b9711bb256a289bb656c4c52e39"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:aa8406b9711bb256a289bb656c4c52e39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa8406b9711bb256a289bb656c4c52e39">integral_legendre</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int n=16)</td></tr>
<tr class="memdesc:aa8406b9711bb256a289bb656c4c52e39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gauss-Legendre quadrature of degree 2, 4, 8 or 16, using pre-computed values, to approximate an integral over [a, b].  <br /></td></tr>
<tr class="separator:aa8406b9711bb256a289bb656c4c52e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a53869de63d5c2daf7790511ce8aac" id="r_aa4a53869de63d5c2daf7790511ce8aac"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:aa4a53869de63d5c2daf7790511ce8aac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa4a53869de63d5c2daf7790511ce8aac">integral_laguerre</a> (RealFunction f, const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:aa4a53869de63d5c2daf7790511ce8aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gauss-Laguerre quadrature of arbitrary degree to approximate an integral over [0, +inf) providing the roots of the n degree Legendre polynomial.  <br /></td></tr>
<tr class="separator:aa4a53869de63d5c2daf7790511ce8aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c209d0975ad962d9b5e68a3661150ab" id="r_a0c209d0975ad962d9b5e68a3661150ab"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a0c209d0975ad962d9b5e68a3661150ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a0c209d0975ad962d9b5e68a3661150ab">integral_laguerre</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a0c209d0975ad962d9b5e68a3661150ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gauss-Laguerre quadrature of arbitrary degree to approximate an integral over [a, b] providing the roots of the n degree Legendre polynomial.  <br /></td></tr>
<tr class="separator:a0c209d0975ad962d9b5e68a3661150ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15d3b8d15def86bb228a46811100bca" id="r_ab15d3b8d15def86bb228a46811100bca"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:ab15d3b8d15def86bb228a46811100bca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab15d3b8d15def86bb228a46811100bca">integral_laguerre</a> (RealFunction f, unsigned int n=16)</td></tr>
<tr class="memdesc:ab15d3b8d15def86bb228a46811100bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gauss-Laguerre quadrature of degree 2, 4, 8 or 16, using pre-computed values, to approximate an integral over [0, +inf).  <br /></td></tr>
<tr class="separator:ab15d3b8d15def86bb228a46811100bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe2540b2ff381a14b61588280cb9016" id="r_abbe2540b2ff381a14b61588280cb9016"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:abbe2540b2ff381a14b61588280cb9016"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abbe2540b2ff381a14b61588280cb9016">integral_hermite</a> (RealFunction f, const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:abbe2540b2ff381a14b61588280cb9016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gauss-Hermite quadrature of arbitrary degree to approximate an integral over (-inf, +inf) providing the roots of the n degree Hermite polynomial.  <br /></td></tr>
<tr class="separator:abbe2540b2ff381a14b61588280cb9016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd783739794f700157cc7f7d6f9d9632" id="r_abd783739794f700157cc7f7d6f9d9632"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:abd783739794f700157cc7f7d6f9d9632"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abd783739794f700157cc7f7d6f9d9632">integral_hermite</a> (RealFunction f, unsigned int n=16)</td></tr>
<tr class="memdesc:abd783739794f700157cc7f7d6f9d9632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gauss-Hermite quadrature of degree 2, 4, 8 or 16, using pre-computed values, to approximate an integral over (-inf, +inf).  <br /></td></tr>
<tr class="separator:abd783739794f700157cc7f7d6f9d9632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd61484f6f7bc8b474037d866a4b110" id="r_a5fd61484f6f7bc8b474037d866a4b110"><td class="memItemLeft" align="right" valign="top"><a id="a5fd61484f6f7bc8b474037d866a4b110" name="a5fd61484f6f7bc8b474037d866a4b110"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>integral_inf_riemann</b> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> step_sz=1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tol=CALCULUS_INTEGRAL_TOL, unsigned int max_iter=100)</td></tr>
<tr class="memdesc:a5fd61484f6f7bc8b474037d866a4b110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate a function from a point up to infinity by integrating it by steps, stopping execution when the variation of the integral is small enough or the number of steps reaches a maximum value. <br /></td></tr>
<tr class="separator:a5fd61484f6f7bc8b474037d866a4b110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae095e7eee4b03eddc3b035b2bde14a7e" id="r_ae095e7eee4b03eddc3b035b2bde14a7e"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:ae095e7eee4b03eddc3b035b2bde14a7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ae095e7eee4b03eddc3b035b2bde14a7e">integral</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:ae095e7eee4b03eddc3b035b2bde14a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the best available algorithm to approximate the definite integral of a real function.  <br /></td></tr>
<tr class="separator:ae095e7eee4b03eddc3b035b2bde14a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29abada0134095a6d9a120c241ce461" id="r_aa29abada0134095a6d9a120c241ce461"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:aa29abada0134095a6d9a120c241ce461"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa29abada0134095a6d9a120c241ce461">integral</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tol)</td></tr>
<tr class="memdesc:aa29abada0134095a6d9a120c241ce461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the best available algorithm to approximate the definite integral of a real function to a given tolerance.  <br /></td></tr>
<tr class="separator:aa29abada0134095a6d9a120c241ce461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3901b8b9a442e4b71368650c2ce1ee31" id="r_a3901b8b9a442e4b71368650c2ce1ee31"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3901b8b9a442e4b71368650c2ce1ee31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a3901b8b9a442e4b71368650c2ce1ee31">identity</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a3901b8b9a442e4b71368650c2ce1ee31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex identity.  <br /></td></tr>
<tr class="separator:a3901b8b9a442e4b71368650c2ce1ee31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4160ef942a7f710c85250f69e65def" id="r_a7d4160ef942a7f710c85250f69e65def"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d4160ef942a7f710c85250f69e65def"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a7d4160ef942a7f710c85250f69e65def">conjugate</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a7d4160ef942a7f710c85250f69e65def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the conjugate of a complex number.  <br /></td></tr>
<tr class="separator:a7d4160ef942a7f710c85250f69e65def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9b9fcd589d1358fb90effc83e1fc04" id="r_a3e9b9fcd589d1358fb90effc83e1fc04"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3e9b9fcd589d1358fb90effc83e1fc04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a3e9b9fcd589d1358fb90effc83e1fc04">inverse</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a3e9b9fcd589d1358fb90effc83e1fc04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the conjugate of a complex number.  <br /></td></tr>
<tr class="separator:a3e9b9fcd589d1358fb90effc83e1fc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13ddee06543aa9aa3deb827efd44f63" id="r_af13ddee06543aa9aa3deb827efd44f63"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af13ddee06543aa9aa3deb827efd44f63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af13ddee06543aa9aa3deb827efd44f63">square</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:af13ddee06543aa9aa3deb827efd44f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square of a complex number.  <br /></td></tr>
<tr class="separator:af13ddee06543aa9aa3deb827efd44f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc94802c6760bba16d0eaf5795dced7" id="r_a9cc94802c6760bba16d0eaf5795dced7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9cc94802c6760bba16d0eaf5795dced7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a9cc94802c6760bba16d0eaf5795dced7">cube</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a9cc94802c6760bba16d0eaf5795dced7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cube of a complex number.  <br /></td></tr>
<tr class="separator:a9cc94802c6760bba16d0eaf5795dced7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6500750eaa5ea09bf1a2fa8ca1c1d430" id="r_a6500750eaa5ea09bf1a2fa8ca1c1d430"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6500750eaa5ea09bf1a2fa8ca1c1d430"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6500750eaa5ea09bf1a2fa8ca1c1d430">exp</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a6500750eaa5ea09bf1a2fa8ca1c1d430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex exponential.  <br /></td></tr>
<tr class="separator:a6500750eaa5ea09bf1a2fa8ca1c1d430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefc7e5553fca6b62313bb2a3037e49b" id="r_adefc7e5553fca6b62313bb2a3037e49b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adefc7e5553fca6b62313bb2a3037e49b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#adefc7e5553fca6b62313bb2a3037e49b">abs</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:adefc7e5553fca6b62313bb2a3037e49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the modulus of a complex number.  <br /></td></tr>
<tr class="separator:adefc7e5553fca6b62313bb2a3037e49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbb7d4dc0c7a5138e34212ddd8dcda2" id="r_a2dbb7d4dc0c7a5138e34212ddd8dcda2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2dbb7d4dc0c7a5138e34212ddd8dcda2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a2dbb7d4dc0c7a5138e34212ddd8dcda2">sin</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a2dbb7d4dc0c7a5138e34212ddd8dcda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computer the complex sine.  <br /></td></tr>
<tr class="separator:a2dbb7d4dc0c7a5138e34212ddd8dcda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133da02105ffbd23a2f6f07c03b219f6" id="r_a133da02105ffbd23a2f6f07c03b219f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a133da02105ffbd23a2f6f07c03b219f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a133da02105ffbd23a2f6f07c03b219f6">cos</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a133da02105ffbd23a2f6f07c03b219f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex cosine.  <br /></td></tr>
<tr class="separator:a133da02105ffbd23a2f6f07c03b219f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92971816c6dda74903738b66ff69fb9c" id="r_a92971816c6dda74903738b66ff69fb9c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a92971816c6dda74903738b66ff69fb9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a92971816c6dda74903738b66ff69fb9c">tan</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a92971816c6dda74903738b66ff69fb9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex tangent.  <br /></td></tr>
<tr class="separator:a92971816c6dda74903738b66ff69fb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42af84f096a0f9e11fdb72d13990bd52" id="r_a42af84f096a0f9e11fdb72d13990bd52"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a42af84f096a0f9e11fdb72d13990bd52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a42af84f096a0f9e11fdb72d13990bd52">sqrt</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a42af84f096a0f9e11fdb72d13990bd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex square root.  <br /></td></tr>
<tr class="separator:a42af84f096a0f9e11fdb72d13990bd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa4a4d5af15f371b28d87d35b504aae" id="r_aeaa4a4d5af15f371b28d87d35b504aae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeaa4a4d5af15f371b28d87d35b504aae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aeaa4a4d5af15f371b28d87d35b504aae">ln</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:aeaa4a4d5af15f371b28d87d35b504aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex logarithm.  <br /></td></tr>
<tr class="separator:aeaa4a4d5af15f371b28d87d35b504aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af336feea10e3a8928f2d2723578d3704" id="r_af336feea10e3a8928f2d2723578d3704"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af336feea10e3a8928f2d2723578d3704"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af336feea10e3a8928f2d2723578d3704">asin</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:af336feea10e3a8928f2d2723578d3704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex arcsine.  <br /></td></tr>
<tr class="separator:af336feea10e3a8928f2d2723578d3704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0086a4838097cdade9da3abb896ac14" id="r_ab0086a4838097cdade9da3abb896ac14"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0086a4838097cdade9da3abb896ac14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab0086a4838097cdade9da3abb896ac14">acos</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:ab0086a4838097cdade9da3abb896ac14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex arccosine.  <br /></td></tr>
<tr class="separator:ab0086a4838097cdade9da3abb896ac14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7f72fc6086b22ac864727ac0ee064b" id="r_abb7f72fc6086b22ac864727ac0ee064b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abb7f72fc6086b22ac864727ac0ee064b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abb7f72fc6086b22ac864727ac0ee064b">atan</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:abb7f72fc6086b22ac864727ac0ee064b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex arctangent.  <br /></td></tr>
<tr class="separator:abb7f72fc6086b22ac864727ac0ee064b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2b51694a7dd4ded3a140f92366aaed" id="r_aca2b51694a7dd4ded3a140f92366aaed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aca2b51694a7dd4ded3a140f92366aaed">mul_uint128</a> (uint64_t a, uint64_t b, uint64_t &amp;c_low, uint64_t &amp;c_high)</td></tr>
<tr class="memdesc:aca2b51694a7dd4ded3a140f92366aaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two 64-bit unsigned integers and store the result in two 64-bit variables, keeping 128 bits of the result.  <br /></td></tr>
<tr class="separator:aca2b51694a7dd4ded3a140f92366aaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672dbbc0ea824c71d7ca0dc26b346200" id="r_a672dbbc0ea824c71d7ca0dc26b346200"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a672dbbc0ea824c71d7ca0dc26b346200">mix_mum</a> (uint64_t a, uint64_t b)</td></tr>
<tr class="memdesc:a672dbbc0ea824c71d7ca0dc26b346200"><td class="mdescLeft">&#160;</td><td class="mdescRight">MUM bit mixing function, computes the 128-bit product of a and b and the XOR of their high and low 64-bit parts.  <br /></td></tr>
<tr class="separator:a672dbbc0ea824c71d7ca0dc26b346200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4024f1ecd6e937492928965a417c2bc9" id="r_a4024f1ecd6e937492928965a417c2bc9"><td class="memTemplParams" colspan="2">template&lt;typename UnsignedIntType &gt; </td></tr>
<tr class="memitem:a4024f1ecd6e937492928965a417c2bc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> UnsignedIntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a4024f1ecd6e937492928965a417c2bc9">bit_rotate</a> (UnsignedIntType x, unsigned int i)</td></tr>
<tr class="memdesc:a4024f1ecd6e937492928965a417c2bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit rotation of unsigned integer types using shifts.  <br /></td></tr>
<tr class="separator:a4024f1ecd6e937492928965a417c2bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3702e8779681c1323f7a98f7f6a3cb" id="r_afc3702e8779681c1323f7a98f7f6a3cb"><td class="memTemplParams" colspan="2">template&lt;typename Vector , enable_vector&lt; Vector &gt;  = true&gt; </td></tr>
<tr class="memitem:afc3702e8779681c1323f7a98f7f6a3cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#afc3702e8779681c1323f7a98f7f6a3cb">swap_bit_reverse</a> (Vector &amp;x, unsigned int m)</td></tr>
<tr class="memdesc:afc3702e8779681c1323f7a98f7f6a3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the elements of a vector pair-wise, by exchanging elements with indices related by bit reversion (e.g.  <br /></td></tr>
<tr class="separator:afc3702e8779681c1323f7a98f7f6a3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf08c69e546c822b60b2185156b04360" id="r_adf08c69e546c822b60b2185156b04360"><td class="memTemplParams" colspan="2"><a id="adf08c69e546c822b60b2185156b04360" name="adf08c69e546c822b60b2185156b04360"></a>
template&lt;typename Vector , enable_vector&lt; Vector &gt;  = true&gt; </td></tr>
<tr class="memitem:adf08c69e546c822b60b2185156b04360"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>product</b> (const Vector &amp;X)</td></tr>
<tr class="memdesc:adf08c69e546c822b60b2185156b04360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of a set of values. <br /></td></tr>
<tr class="separator:adf08c69e546c822b60b2185156b04360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8298cbf34bf300bc2c84d14264484ffd" id="r_a8298cbf34bf300bc2c84d14264484ffd"><td class="memTemplParams" colspan="2"><a id="a8298cbf34bf300bc2c84d14264484ffd" name="a8298cbf34bf300bc2c84d14264484ffd"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a8298cbf34bf300bc2c84d14264484ffd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>product_sum</b> (const Vector &amp;X, const Vector &amp;Y)</td></tr>
<tr class="memdesc:a8298cbf34bf300bc2c84d14264484ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the products of two sets of values. <br /></td></tr>
<tr class="separator:a8298cbf34bf300bc2c84d14264484ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8799cd7d7645f496d0d2c9683688050b" id="r_a8799cd7d7645f496d0d2c9683688050b"><td class="memTemplParams" colspan="2"><a id="a8799cd7d7645f496d0d2c9683688050b" name="a8799cd7d7645f496d0d2c9683688050b"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a8799cd7d7645f496d0d2c9683688050b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>product_sum_squares</b> (const Vector &amp;X, const Vector &amp;Y)</td></tr>
<tr class="memdesc:a8799cd7d7645f496d0d2c9683688050b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the products of the squares of two sets of data. <br /></td></tr>
<tr class="separator:a8799cd7d7645f496d0d2c9683688050b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf60e1fdc60411ae615b952b7248b093" id="r_abf60e1fdc60411ae615b952b7248b093"><td class="memTemplParams" colspan="2"><a id="abf60e1fdc60411ae615b952b7248b093" name="abf60e1fdc60411ae615b952b7248b093"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:abf60e1fdc60411ae615b952b7248b093"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>product_sum</b> (const Vector &amp;X, const Vector &amp;Y, const Vector &amp;Z)</td></tr>
<tr class="memdesc:abf60e1fdc60411ae615b952b7248b093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the products of three sets of values. <br /></td></tr>
<tr class="separator:abf60e1fdc60411ae615b952b7248b093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14178d5680aaca3da91f2f0dc8a86d4" id="r_aa14178d5680aaca3da91f2f0dc8a86d4"><td class="memTemplParams" colspan="2"><a id="aa14178d5680aaca3da91f2f0dc8a86d4" name="aa14178d5680aaca3da91f2f0dc8a86d4"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:aa14178d5680aaca3da91f2f0dc8a86d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quotient_sum</b> (const Vector &amp;X, const Vector &amp;Y)</td></tr>
<tr class="memdesc:aa14178d5680aaca3da91f2f0dc8a86d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the quotients of two sets of values. <br /></td></tr>
<tr class="separator:aa14178d5680aaca3da91f2f0dc8a86d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4e70500501fc48d6ad18f8abfc1896" id="r_aec4e70500501fc48d6ad18f8abfc1896"><td class="memTemplParams" colspan="2"><a id="aec4e70500501fc48d6ad18f8abfc1896" name="aec4e70500501fc48d6ad18f8abfc1896"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:aec4e70500501fc48d6ad18f8abfc1896"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sum_squares</b> (const Vector &amp;X)</td></tr>
<tr class="memdesc:aec4e70500501fc48d6ad18f8abfc1896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the squares of a set of values. <br /></td></tr>
<tr class="separator:aec4e70500501fc48d6ad18f8abfc1896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173a64c4f73cb7abd476b739005d94e7" id="r_a173a64c4f73cb7abd476b739005d94e7"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a173a64c4f73cb7abd476b739005d94e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a173a64c4f73cb7abd476b739005d94e7">sum_compensated</a> (const Vector &amp;X)</td></tr>
<tr class="memdesc:a173a64c4f73cb7abd476b739005d94e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of a set of values using the compensated Neumaier-Kahan-Babushka summation algorithm to reduce round-off error.  <br /></td></tr>
<tr class="separator:a173a64c4f73cb7abd476b739005d94e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a97cfad96b9bb73d76b8f5cc20f2896" id="r_a2a97cfad96b9bb73d76b8f5cc20f2896"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a2a97cfad96b9bb73d76b8f5cc20f2896"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a2a97cfad96b9bb73d76b8f5cc20f2896">sum_pairwise</a> (const Vector &amp;X, size_t begin=0, size_t end=0, size_t base_size=128)</td></tr>
<tr class="memdesc:a2a97cfad96b9bb73d76b8f5cc20f2896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of a set of values using pairwise summation to reduce round-off error.  <br /></td></tr>
<tr class="separator:a2a97cfad96b9bb73d76b8f5cc20f2896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551e6c640e2580e8756526e015f2ad04" id="r_a551e6c640e2580e8756526e015f2ad04"><td class="memTemplParams" colspan="2">template&lt;typename Vector , std::enable_if_t&lt; has_real_elements&lt; Vector &gt;::value &gt;  = true&gt; </td></tr>
<tr class="memitem:a551e6c640e2580e8756526e015f2ad04"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a551e6c640e2580e8756526e015f2ad04">sum</a> (const Vector &amp;X)</td></tr>
<tr class="memdesc:a551e6c640e2580e8756526e015f2ad04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of a vector of real values using pairwise summation to reduce round-off error.  <br /></td></tr>
<tr class="separator:a551e6c640e2580e8756526e015f2ad04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3305c4f7617c88a3e8ee4deb5b7ef0" id="r_aec3305c4f7617c88a3e8ee4deb5b7ef0"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:aec3305c4f7617c88a3e8ee4deb5b7ef0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aec3305c4f7617c88a3e8ee4deb5b7ef0">sum</a> (const Vector &amp;X)</td></tr>
<tr class="memdesc:aec3305c4f7617c88a3e8ee4deb5b7ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of a set of values.  <br /></td></tr>
<tr class="separator:aec3305c4f7617c88a3e8ee4deb5b7ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a76a59d0419eb65ee9d89e7bd6c1db" id="r_ac0a76a59d0419eb65ee9d89e7bd6c1db"><td class="memTemplParams" colspan="2">template&lt;typename Vector , typename Function &gt; </td></tr>
<tr class="memitem:ac0a76a59d0419eb65ee9d89e7bd6c1db"><td class="memTemplItemLeft" align="right" valign="top">Vector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac0a76a59d0419eb65ee9d89e7bd6c1db">apply</a> (Function f, Vector &amp;X)</td></tr>
<tr class="memdesc:ac0a76a59d0419eb65ee9d89e7bd6c1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to a set of values element-wise.  <br /></td></tr>
<tr class="separator:ac0a76a59d0419eb65ee9d89e7bd6c1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b898a8449d723a807854f805f8be23e" id="r_a1b898a8449d723a807854f805f8be23e"><td class="memTemplParams" colspan="2">template&lt;typename Vector1 , typename Vector2  = Vector1, typename Function &gt; </td></tr>
<tr class="memitem:a1b898a8449d723a807854f805f8be23e"><td class="memTemplItemLeft" align="right" valign="top">Vector2 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a1b898a8449d723a807854f805f8be23e">map</a> (Function f, const Vector1 &amp;src, Vector2 &amp;dest)</td></tr>
<tr class="memdesc:a1b898a8449d723a807854f805f8be23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a new vector obtained by applying the function element-wise.  <br /></td></tr>
<tr class="separator:a1b898a8449d723a807854f805f8be23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43890de03a7e2c959fdabe4f7452042" id="r_ac43890de03a7e2c959fdabe4f7452042"><td class="memTemplParams" colspan="2">template&lt;typename Vector2 , typename Vector1 , typename Function &gt; </td></tr>
<tr class="memitem:ac43890de03a7e2c959fdabe4f7452042"><td class="memTemplItemLeft" align="right" valign="top">Vector2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac43890de03a7e2c959fdabe4f7452042">map</a> (Function f, const Vector1 &amp;X)</td></tr>
<tr class="memdesc:ac43890de03a7e2c959fdabe4f7452042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a new vector obtained by applying the function element-wise.  <br /></td></tr>
<tr class="separator:ac43890de03a7e2c959fdabe4f7452042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd4dbfccbb88413ccb29c93ae7254da" id="r_a1bd4dbfccbb88413ccb29c93ae7254da"><td class="memTemplParams" colspan="2">template&lt;typename Vector , typename Function &gt; </td></tr>
<tr class="memitem:a1bd4dbfccbb88413ccb29c93ae7254da"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a1bd4dbfccbb88413ccb29c93ae7254da">map</a> (Function f, const Vector &amp;X)</td></tr>
<tr class="memdesc:a1bd4dbfccbb88413ccb29c93ae7254da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a new vector obtained by applying the function element-wise.  <br /></td></tr>
<tr class="separator:a1bd4dbfccbb88413ccb29c93ae7254da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a85d4034e2edc73c0175f1d3b6d1382" id="r_a1a85d4034e2edc73c0175f1d3b6d1382"><td class="memTemplParams" colspan="2"><a id="a1a85d4034e2edc73c0175f1d3b6d1382" name="a1a85d4034e2edc73c0175f1d3b6d1382"></a>
template&lt;typename Vector1 , typename Vector2 , typename Vector3  = Vector1&gt; </td></tr>
<tr class="memitem:a1a85d4034e2edc73c0175f1d3b6d1382"><td class="memTemplItemLeft" align="right" valign="top">Vector3&#160;</td><td class="memTemplItemRight" valign="bottom"><b>concatenate</b> (const Vector1 &amp;v1, const Vector2 &amp;v2)</td></tr>
<tr class="memdesc:a1a85d4034e2edc73c0175f1d3b6d1382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two datasets to form a single one. <br /></td></tr>
<tr class="separator:a1a85d4034e2edc73c0175f1d3b6d1382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c3cffe1db6b2cb178d41bfc98b1c41" id="r_a79c3cffe1db6b2cb178d41bfc98b1c41"><td class="memTemplParams" colspan="2"><a id="a79c3cffe1db6b2cb178d41bfc98b1c41" name="a79c3cffe1db6b2cb178d41bfc98b1c41"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a79c3cffe1db6b2cb178d41bfc98b1c41"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const Vector &amp;X)</td></tr>
<tr class="memdesc:a79c3cffe1db6b2cb178d41bfc98b1c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the maximum value inside a dataset. <br /></td></tr>
<tr class="separator:a79c3cffe1db6b2cb178d41bfc98b1c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133ae02c952df7352cfb3830a1616bc1" id="r_a133ae02c952df7352cfb3830a1616bc1"><td class="memTemplParams" colspan="2"><a id="a133ae02c952df7352cfb3830a1616bc1" name="a133ae02c952df7352cfb3830a1616bc1"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a133ae02c952df7352cfb3830a1616bc1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const Vector &amp;X)</td></tr>
<tr class="memdesc:a133ae02c952df7352cfb3830a1616bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the minimum value inside a dataset. <br /></td></tr>
<tr class="separator:a133ae02c952df7352cfb3830a1616bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1191a32286f176c367f648431b1444ac" id="r_a1191a32286f176c367f648431b1444ac"><td class="memTemplParams" colspan="2"><a id="a1191a32286f176c367f648431b1444ac" name="a1191a32286f176c367f648431b1444ac"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a1191a32286f176c367f648431b1444ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>arithmetic_mean</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:a1191a32286f176c367f648431b1444ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arithmetic mean of a set of values. <br /></td></tr>
<tr class="separator:a1191a32286f176c367f648431b1444ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1638fb86d8cb03965ff398d41f7b00fb" id="r_a1638fb86d8cb03965ff398d41f7b00fb"><td class="memTemplParams" colspan="2"><a id="a1638fb86d8cb03965ff398d41f7b00fb" name="a1638fb86d8cb03965ff398d41f7b00fb"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a1638fb86d8cb03965ff398d41f7b00fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>harmonic_mean</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:a1638fb86d8cb03965ff398d41f7b00fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the harmonic mean of a set of values. <br /></td></tr>
<tr class="separator:a1638fb86d8cb03965ff398d41f7b00fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c73eaa2f2276a66b309426cc308d1b" id="r_a73c73eaa2f2276a66b309426cc308d1b"><td class="memTemplParams" colspan="2"><a id="a73c73eaa2f2276a66b309426cc308d1b" name="a73c73eaa2f2276a66b309426cc308d1b"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a73c73eaa2f2276a66b309426cc308d1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>geometric_mean</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:a73c73eaa2f2276a66b309426cc308d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the geometric mean of a set of values as \(\sqrt[n]{\Pi_i x_i}\). <br /></td></tr>
<tr class="separator:a73c73eaa2f2276a66b309426cc308d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8a4b7178a8558fc4ba3ab3b9b3f926" id="r_a0e8a4b7178a8558fc4ba3ab3b9b3f926"><td class="memTemplParams" colspan="2"><a id="a0e8a4b7178a8558fc4ba3ab3b9b3f926" name="a0e8a4b7178a8558fc4ba3ab3b9b3f926"></a>
template&lt;typename Dataset1 , typename Dataset2 &gt; </td></tr>
<tr class="memitem:a0e8a4b7178a8558fc4ba3ab3b9b3f926"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>weighted_mean</b> (const Dataset1 &amp;data, const Dataset2 &amp;weights)</td></tr>
<tr class="memdesc:a0e8a4b7178a8558fc4ba3ab3b9b3f926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the weighted mean of a set of values &lt;data&gt; and &lt;weights&gt; must have the same size. <br /></td></tr>
<tr class="separator:a0e8a4b7178a8558fc4ba3ab3b9b3f926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9473c3dfdbe71e408fb3241d458254c0" id="r_a9473c3dfdbe71e408fb3241d458254c0"><td class="memTemplParams" colspan="2"><a id="a9473c3dfdbe71e408fb3241d458254c0" name="a9473c3dfdbe71e408fb3241d458254c0"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a9473c3dfdbe71e408fb3241d458254c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quadratic_mean</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:a9473c3dfdbe71e408fb3241d458254c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the quadratic mean (Root Mean Square) of a set of values \(m_q = \sqrt{x1^2 + x2^2 + ...}\). <br /></td></tr>
<tr class="separator:a9473c3dfdbe71e408fb3241d458254c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710c25d508e9e9ae9ed4e734fe4cd6f9" id="r_a710c25d508e9e9ae9ed4e734fe4cd6f9"><td class="memItemLeft" align="right" valign="top"><a id="a710c25d508e9e9ae9ed4e734fe4cd6f9" name="a710c25d508e9e9ae9ed4e734fe4cd6f9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>th_errcode_to_errno</b> (<a class="el" href="namespacetheoretica.html#a47d8f770edb576685f4b8752f2eb9760">MATH_ERRCODE</a> err)</td></tr>
<tr class="memdesc:a710c25d508e9e9ae9ed4e734fe4cd6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a MATH_ERRCODE to errno error codes. <br /></td></tr>
<tr class="separator:a710c25d508e9e9ae9ed4e734fe4cd6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ee927450a4d29cb6318b2aede74fa6" id="r_a88ee927450a4d29cb6318b2aede74fa6"><td class="memItemLeft" align="right" valign="top"><a id="a88ee927450a4d29cb6318b2aede74fa6" name="a88ee927450a4d29cb6318b2aede74fa6"></a>
<a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nan</b> ()</td></tr>
<tr class="memdesc:a88ee927450a4d29cb6318b2aede74fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a quiet NaN number in floating point representation. <br /></td></tr>
<tr class="separator:a88ee927450a4d29cb6318b2aede74fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e311a811c0c7e23c30e4496cfbe63d" id="r_a22e311a811c0c7e23c30e4496cfbe63d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22e311a811c0c7e23c30e4496cfbe63d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a22e311a811c0c7e23c30e4496cfbe63d">is_nan</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a22e311a811c0c7e23c30e4496cfbe63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a generic variable is (equivalent to) a NaN number.  <br /></td></tr>
<tr class="separator:a22e311a811c0c7e23c30e4496cfbe63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab15c6d834d781bbe9fdc152cf5be1e" id="r_adab15c6d834d781bbe9fdc152cf5be1e"><td class="memItemLeft" align="right" valign="top"><a id="adab15c6d834d781bbe9fdc152cf5be1e" name="adab15c6d834d781bbe9fdc152cf5be1e"></a>
<a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>inf</b> ()</td></tr>
<tr class="memdesc:adab15c6d834d781bbe9fdc152cf5be1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get positive infinity in floating point representation. <br /></td></tr>
<tr class="separator:adab15c6d834d781bbe9fdc152cf5be1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e2748628e6c133de6a7e843c02c7d7" id="r_aa0e2748628e6c133de6a7e843c02c7d7"><td class="memItemLeft" align="right" valign="top"><a id="aa0e2748628e6c133de6a7e843c02c7d7" name="aa0e2748628e6c133de6a7e843c02c7d7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_inf</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:aa0e2748628e6c133de6a7e843c02c7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a real number is infinite. <br /></td></tr>
<tr class="separator:aa0e2748628e6c133de6a7e843c02c7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e3b9080dde2e7542682cf79f0bbf50" id="r_ac8e3b9080dde2e7542682cf79f0bbf50"><td class="memItemLeft" align="right" valign="top"><a id="ac8e3b9080dde2e7542682cf79f0bbf50" name="ac8e3b9080dde2e7542682cf79f0bbf50"></a>
<a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>identity</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:ac8e3b9080dde2e7542682cf79f0bbf50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity. <br /></td></tr>
<tr class="separator:ac8e3b9080dde2e7542682cf79f0bbf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a5d3a6d550b1c227342e5f6ed8d194" id="r_a63a5d3a6d550b1c227342e5f6ed8d194"><td class="memTemplParams" colspan="2"><a id="a63a5d3a6d550b1c227342e5f6ed8d194" name="a63a5d3a6d550b1c227342e5f6ed8d194"></a>
template&lt;typename Type , typename  = std::enable_if&lt;is_real_type&lt;Type&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a63a5d3a6d550b1c227342e5f6ed8d194"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conjugate</b> (Type x)</td></tr>
<tr class="memdesc:a63a5d3a6d550b1c227342e5f6ed8d194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate of a real number (identity) <br /></td></tr>
<tr class="separator:a63a5d3a6d550b1c227342e5f6ed8d194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726a5e18c863dc41040f5df134553fa9" id="r_a726a5e18c863dc41040f5df134553fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a726a5e18c863dc41040f5df134553fa9">square</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a726a5e18c863dc41040f5df134553fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square of a real number.  <br /></td></tr>
<tr class="separator:a726a5e18c863dc41040f5df134553fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfa8d12242c241b6f56cebc9cdc60ed" id="r_a6bfa8d12242c241b6f56cebc9cdc60ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6bfa8d12242c241b6f56cebc9cdc60ed">cube</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a6bfa8d12242c241b6f56cebc9cdc60ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cube of a real number.  <br /></td></tr>
<tr class="separator:a6bfa8d12242c241b6f56cebc9cdc60ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68914a563241494dfe7ac42f0462920c" id="r_a68914a563241494dfe7ac42f0462920c"><td class="memTemplParams" colspan="2">template&lt;typename UnsignedIntType  = uint64_t&gt; </td></tr>
<tr class="memitem:a68914a563241494dfe7ac42f0462920c"><td class="memTemplItemLeft" align="right" valign="top">UnsignedIntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a68914a563241494dfe7ac42f0462920c">isqrt</a> (UnsignedIntType n)</td></tr>
<tr class="memdesc:a68914a563241494dfe7ac42f0462920c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the integer square root of a positive integer.  <br /></td></tr>
<tr class="separator:a68914a563241494dfe7ac42f0462920c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad830de3729f8f2bea38d60ef706cf968" id="r_ad830de3729f8f2bea38d60ef706cf968"><td class="memTemplParams" colspan="2">template&lt;typename UnsignedIntType  = uint64_t&gt; </td></tr>
<tr class="memitem:ad830de3729f8f2bea38d60ef706cf968"><td class="memTemplItemLeft" align="right" valign="top">UnsignedIntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad830de3729f8f2bea38d60ef706cf968">icbrt</a> (UnsignedIntType n)</td></tr>
<tr class="memdesc:ad830de3729f8f2bea38d60ef706cf968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the integer cubic root of a positive integer.  <br /></td></tr>
<tr class="separator:ad830de3729f8f2bea38d60ef706cf968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e4cf02f9bcb4caf5371ee05d67df8d" id="r_aa2e4cf02f9bcb4caf5371ee05d67df8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa2e4cf02f9bcb4caf5371ee05d67df8d">sqrt</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:aa2e4cf02f9bcb4caf5371ee05d67df8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of a real number.  <br /></td></tr>
<tr class="separator:aa2e4cf02f9bcb4caf5371ee05d67df8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c3b797f94ec5bc22b4c22f85417c93" id="r_a61c3b797f94ec5bc22b4c22f85417c93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a61c3b797f94ec5bc22b4c22f85417c93">cbrt</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a61c3b797f94ec5bc22b4c22f85417c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cubic root of x.  <br /></td></tr>
<tr class="separator:a61c3b797f94ec5bc22b4c22f85417c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5177ff64d981840e149d1e282f1b27e" id="r_aa5177ff64d981840e149d1e282f1b27e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa5177ff64d981840e149d1e282f1b27e">abs</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:aa5177ff64d981840e149d1e282f1b27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of a real number.  <br /></td></tr>
<tr class="separator:aa5177ff64d981840e149d1e282f1b27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61e39abd4fd4cd8cd83add5d0752e2f" id="r_ad61e39abd4fd4cd8cd83add5d0752e2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad61e39abd4fd4cd8cd83add5d0752e2f">sgn</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:ad61e39abd4fd4cd8cd83add5d0752e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sign of x (1 if positive, -1 if negative, 0 if null)  <br /></td></tr>
<tr class="separator:ad61e39abd4fd4cd8cd83add5d0752e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad5c92586d6a0f841bfcd3759eff317" id="r_afad5c92586d6a0f841bfcd3759eff317"><td class="memItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#afad5c92586d6a0f841bfcd3759eff317">floor</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:afad5c92586d6a0f841bfcd3759eff317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the floor of x Computes the maximum integer number that is smaller than x.  <br /></td></tr>
<tr class="separator:afad5c92586d6a0f841bfcd3759eff317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d079c3d95f2bc80c4619d13ff7263a" id="r_a85d079c3d95f2bc80c4619d13ff7263a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a85d079c3d95f2bc80c4619d13ff7263a">fract</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a85d079c3d95f2bc80c4619d13ff7263a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the fractional part of a real number.  <br /></td></tr>
<tr class="separator:a85d079c3d95f2bc80c4619d13ff7263a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07569756dda099ecabf425371da6a31d" id="r_a07569756dda099ecabf425371da6a31d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a07569756dda099ecabf425371da6a31d">max</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y)</td></tr>
<tr class="memdesc:a07569756dda099ecabf425371da6a31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greatest number between two real numbers.  <br /></td></tr>
<tr class="separator:a07569756dda099ecabf425371da6a31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e295404d1712fb17851fe105715766e" id="r_a5e295404d1712fb17851fe105715766e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e295404d1712fb17851fe105715766e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a5e295404d1712fb17851fe105715766e">max</a> (T x, T y)</td></tr>
<tr class="memdesc:a5e295404d1712fb17851fe105715766e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two objects and return the greatest.  <br /></td></tr>
<tr class="separator:a5e295404d1712fb17851fe105715766e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac673920f8956ebea402eac4271f551ba" id="r_ac673920f8956ebea402eac4271f551ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac673920f8956ebea402eac4271f551ba">min</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y)</td></tr>
<tr class="memdesc:ac673920f8956ebea402eac4271f551ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the smallest number between two real numbers.  <br /></td></tr>
<tr class="separator:ac673920f8956ebea402eac4271f551ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f4122359c1f32ba0741d098a5fbe69" id="r_a70f4122359c1f32ba0741d098a5fbe69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70f4122359c1f32ba0741d098a5fbe69"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a70f4122359c1f32ba0741d098a5fbe69">min</a> (T x, T y)</td></tr>
<tr class="memdesc:a70f4122359c1f32ba0741d098a5fbe69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two objects and return the greatest.  <br /></td></tr>
<tr class="separator:a70f4122359c1f32ba0741d098a5fbe69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a4ad4c5446986fe2d255a03be337a1" id="r_af1a4ad4c5446986fe2d255a03be337a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af1a4ad4c5446986fe2d255a03be337a1">clamp</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:af1a4ad4c5446986fe2d255a03be337a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamp x between a and b.  <br /></td></tr>
<tr class="separator:af1a4ad4c5446986fe2d255a03be337a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf4d125306e3fffc7287aa42f9005a1" id="r_acdf4d125306e3fffc7287aa42f9005a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acdf4d125306e3fffc7287aa42f9005a1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#acdf4d125306e3fffc7287aa42f9005a1">clamp</a> (T x, T a, T b)</td></tr>
<tr class="memdesc:acdf4d125306e3fffc7287aa42f9005a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamp a value between two other values.  <br /></td></tr>
<tr class="separator:acdf4d125306e3fffc7287aa42f9005a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd0ef7aa0b136fbd1b4579cec14f369" id="r_abbd0ef7aa0b136fbd1b4579cec14f369"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abbd0ef7aa0b136fbd1b4579cec14f369">log2</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:abbd0ef7aa0b136fbd1b4579cec14f369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the binary logarithm of a real number.  <br /></td></tr>
<tr class="separator:abbd0ef7aa0b136fbd1b4579cec14f369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb04217fd0bd9dd23daaa186d3756d1e" id="r_adb04217fd0bd9dd23daaa186d3756d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#adb04217fd0bd9dd23daaa186d3756d1e">log10</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:adb04217fd0bd9dd23daaa186d3756d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the base-10 logarithm of x.  <br /></td></tr>
<tr class="separator:adb04217fd0bd9dd23daaa186d3756d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748eca731a8c05226332e5723b7a9d91" id="r_a748eca731a8c05226332e5723b7a9d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a748eca731a8c05226332e5723b7a9d91">ln</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a748eca731a8c05226332e5723b7a9d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of x.  <br /></td></tr>
<tr class="separator:a748eca731a8c05226332e5723b7a9d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cd5107369678c27b30dbae079283c5" id="r_a50cd5107369678c27b30dbae079283c5"><td class="memTemplParams" colspan="2">template&lt;typename UnsignedIntType  = uint64_t&gt; </td></tr>
<tr class="memitem:a50cd5107369678c27b30dbae079283c5"><td class="memTemplItemLeft" align="right" valign="top">UnsignedIntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a50cd5107369678c27b30dbae079283c5">ilog2</a> (UnsignedIntType x)</td></tr>
<tr class="memdesc:a50cd5107369678c27b30dbae079283c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the integer logarithm of x.  <br /></td></tr>
<tr class="separator:a50cd5107369678c27b30dbae079283c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9628d333f307cc0dfe8578f29146615" id="r_aa9628d333f307cc0dfe8578f29146615"><td class="memTemplParams" colspan="2">template&lt;typename UnsignedIntType  = uint64_t&gt; </td></tr>
<tr class="memitem:aa9628d333f307cc0dfe8578f29146615"><td class="memTemplItemLeft" align="right" valign="top">UnsignedIntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa9628d333f307cc0dfe8578f29146615">pad2</a> (UnsignedIntType x)</td></tr>
<tr class="memdesc:aa9628d333f307cc0dfe8578f29146615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the smallest power of 2 bigger than or equal to x.  <br /></td></tr>
<tr class="separator:aa9628d333f307cc0dfe8578f29146615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13248f2e439afdb6f72e0f2c1e79cc55" id="r_a13248f2e439afdb6f72e0f2c1e79cc55"><td class="memTemplParams" colspan="2">template&lt;typename T  = real&gt; </td></tr>
<tr class="memitem:a13248f2e439afdb6f72e0f2c1e79cc55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a13248f2e439afdb6f72e0f2c1e79cc55">pow</a> (T x, int n)</td></tr>
<tr class="memdesc:a13248f2e439afdb6f72e0f2c1e79cc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th power of x (where n is natural)  <br /></td></tr>
<tr class="separator:a13248f2e439afdb6f72e0f2c1e79cc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e31c328bc34c0d2fca2aad3bf78ca7" id="r_a52e31c328bc34c0d2fca2aad3bf78ca7"><td class="memTemplParams" colspan="2">template&lt;typename T  = real&gt; </td></tr>
<tr class="memitem:a52e31c328bc34c0d2fca2aad3bf78ca7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a52e31c328bc34c0d2fca2aad3bf78ca7">ipow</a> (T x, unsigned int n, T neutral_element=T(1))</td></tr>
<tr class="memdesc:a52e31c328bc34c0d2fca2aad3bf78ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th positive power of x (where n is natural)  <br /></td></tr>
<tr class="separator:a52e31c328bc34c0d2fca2aad3bf78ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5b285f294e32d7e2a601152d67b4b2" id="r_a8b5b285f294e32d7e2a601152d67b4b2"><td class="memTemplParams" colspan="2"><a id="a8b5b285f294e32d7e2a601152d67b4b2" name="a8b5b285f294e32d7e2a601152d67b4b2"></a>
template&lt;typename IntType  = uint64_t&gt; </td></tr>
<tr class="memitem:a8b5b285f294e32d7e2a601152d67b4b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fact</b> (unsigned int n)</td></tr>
<tr class="memdesc:a8b5b285f294e32d7e2a601152d67b4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the factorial of n. <br /></td></tr>
<tr class="separator:a8b5b285f294e32d7e2a601152d67b4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb032626b2f25bf5c31026c1ee6e639d" id="r_adb032626b2f25bf5c31026c1ee6e639d"><td class="memTemplParams" colspan="2"><a id="adb032626b2f25bf5c31026c1ee6e639d" name="adb032626b2f25bf5c31026c1ee6e639d"></a>
template&lt;typename T  = uint64_t&gt; </td></tr>
<tr class="memitem:adb032626b2f25bf5c31026c1ee6e639d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>falling_fact</b> (T x, unsigned int n)</td></tr>
<tr class="memdesc:adb032626b2f25bf5c31026c1ee6e639d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the falling factorial of n. <br /></td></tr>
<tr class="separator:adb032626b2f25bf5c31026c1ee6e639d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd4867609a302e1846b9cbdb83f629f" id="r_a1dd4867609a302e1846b9cbdb83f629f"><td class="memTemplParams" colspan="2"><a id="a1dd4867609a302e1846b9cbdb83f629f" name="a1dd4867609a302e1846b9cbdb83f629f"></a>
template&lt;typename T  = uint64_t&gt; </td></tr>
<tr class="memitem:a1dd4867609a302e1846b9cbdb83f629f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rising_fact</b> (T x, unsigned int n)</td></tr>
<tr class="memdesc:a1dd4867609a302e1846b9cbdb83f629f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the rising factorial of n. <br /></td></tr>
<tr class="separator:a1dd4867609a302e1846b9cbdb83f629f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a0989004608c56e6dd4bcc2bd148c7" id="r_a56a0989004608c56e6dd4bcc2bd148c7"><td class="memTemplParams" colspan="2"><a id="a56a0989004608c56e6dd4bcc2bd148c7" name="a56a0989004608c56e6dd4bcc2bd148c7"></a>
template&lt;typename IntType  = unsigned long long int&gt; </td></tr>
<tr class="memitem:a56a0989004608c56e6dd4bcc2bd148c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>double_fact</b> (unsigned int n)</td></tr>
<tr class="memdesc:a56a0989004608c56e6dd4bcc2bd148c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the double factorial of n. <br /></td></tr>
<tr class="separator:a56a0989004608c56e6dd4bcc2bd148c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61f8810fcedeaa35f54c834e934828e" id="r_ac61f8810fcedeaa35f54c834e934828e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac61f8810fcedeaa35f54c834e934828e">exp</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:ac61f8810fcedeaa35f54c834e934828e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the real exponential.  <br /></td></tr>
<tr class="separator:ac61f8810fcedeaa35f54c834e934828e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57235e0b29cc687c5084e5f0aa2515c" id="r_ae57235e0b29cc687c5084e5f0aa2515c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ae57235e0b29cc687c5084e5f0aa2515c">expm1</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:ae57235e0b29cc687c5084e5f0aa2515c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of x minus 1 more accurately for really small x.  <br /></td></tr>
<tr class="separator:ae57235e0b29cc687c5084e5f0aa2515c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f12dd8e0fc650fa75c9961e51d1406c" id="r_a6f12dd8e0fc650fa75c9961e51d1406c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6f12dd8e0fc650fa75c9961e51d1406c">powf</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a)</td></tr>
<tr class="memdesc:a6f12dd8e0fc650fa75c9961e51d1406c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate x elevated to a real exponent.  <br /></td></tr>
<tr class="separator:a6f12dd8e0fc650fa75c9961e51d1406c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf52f04c3a1cefbb9dabab21cac0abbb" id="r_acf52f04c3a1cefbb9dabab21cac0abbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#acf52f04c3a1cefbb9dabab21cac0abbb">root</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, int n)</td></tr>
<tr class="memdesc:acf52f04c3a1cefbb9dabab21cac0abbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th root of x.  <br /></td></tr>
<tr class="separator:acf52f04c3a1cefbb9dabab21cac0abbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2ea0b1258dfe34df321901707d1808" id="r_a2c2ea0b1258dfe34df321901707d1808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a2c2ea0b1258dfe34df321901707d1808">sin</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a2c2ea0b1258dfe34df321901707d1808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of a real number.  <br /></td></tr>
<tr class="separator:a2c2ea0b1258dfe34df321901707d1808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af684d7159e22012dc5229c31eb66fceb" id="r_af684d7159e22012dc5229c31eb66fceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af684d7159e22012dc5229c31eb66fceb">cos</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:af684d7159e22012dc5229c31eb66fceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of a real number.  <br /></td></tr>
<tr class="separator:af684d7159e22012dc5229c31eb66fceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9d9a32dc2c9f00de35c1b1a49b218e" id="r_abe9d9a32dc2c9f00de35c1b1a49b218e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abe9d9a32dc2c9f00de35c1b1a49b218e">tan</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:abe9d9a32dc2c9f00de35c1b1a49b218e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of x.  <br /></td></tr>
<tr class="separator:abe9d9a32dc2c9f00de35c1b1a49b218e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6f43e74456bea35fb757f17db47da8" id="r_aec6f43e74456bea35fb757f17db47da8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aec6f43e74456bea35fb757f17db47da8">cot</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:aec6f43e74456bea35fb757f17db47da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cotangent of x.  <br /></td></tr>
<tr class="separator:aec6f43e74456bea35fb757f17db47da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426b70abe4783e75806e1ae8c9e9e2bd" id="r_a426b70abe4783e75806e1ae8c9e9e2bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a426b70abe4783e75806e1ae8c9e9e2bd">atan</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a426b70abe4783e75806e1ae8c9e9e2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arctangent.  <br /></td></tr>
<tr class="separator:a426b70abe4783e75806e1ae8c9e9e2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b06e5bf997c4447c10f2fa96649347" id="r_a79b06e5bf997c4447c10f2fa96649347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a79b06e5bf997c4447c10f2fa96649347">asin</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a79b06e5bf997c4447c10f2fa96649347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcsine.  <br /></td></tr>
<tr class="separator:a79b06e5bf997c4447c10f2fa96649347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2d69e3a3387958a27d4a03ed478a99" id="r_a7f2d69e3a3387958a27d4a03ed478a99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a7f2d69e3a3387958a27d4a03ed478a99">acos</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a7f2d69e3a3387958a27d4a03ed478a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arccosine.  <br /></td></tr>
<tr class="separator:a7f2d69e3a3387958a27d4a03ed478a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae6ab14a39d6132b6858934dadaaf3e" id="r_a6ae6ab14a39d6132b6858934dadaaf3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6ae6ab14a39d6132b6858934dadaaf3e">atan2</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a6ae6ab14a39d6132b6858934dadaaf3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 2 argument arctangent.  <br /></td></tr>
<tr class="separator:a6ae6ab14a39d6132b6858934dadaaf3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0650ea8e1435cc518e960bfcecf5b66e" id="r_a0650ea8e1435cc518e960bfcecf5b66e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a0650ea8e1435cc518e960bfcecf5b66e">sinh</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a0650ea8e1435cc518e960bfcecf5b66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic sine.  <br /></td></tr>
<tr class="separator:a0650ea8e1435cc518e960bfcecf5b66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fc03cbb1de8180e51183bb82c0bb28" id="r_a12fc03cbb1de8180e51183bb82c0bb28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a12fc03cbb1de8180e51183bb82c0bb28">cosh</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a12fc03cbb1de8180e51183bb82c0bb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic cosine.  <br /></td></tr>
<tr class="separator:a12fc03cbb1de8180e51183bb82c0bb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6b8fc4bb2609507cd1fae0f7d6c8a7" id="r_aaf6b8fc4bb2609507cd1fae0f7d6c8a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aaf6b8fc4bb2609507cd1fae0f7d6c8a7">tanh</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:aaf6b8fc4bb2609507cd1fae0f7d6c8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic tangent.  <br /></td></tr>
<tr class="separator:aaf6b8fc4bb2609507cd1fae0f7d6c8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f957ad9b2354268f56ab1ca3843080" id="r_a96f957ad9b2354268f56ab1ca3843080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a96f957ad9b2354268f56ab1ca3843080">coth</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a96f957ad9b2354268f56ab1ca3843080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic cotangent.  <br /></td></tr>
<tr class="separator:a96f957ad9b2354268f56ab1ca3843080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c497fcd02e23df8fa0f197922c4e2c" id="r_a54c497fcd02e23df8fa0f197922c4e2c"><td class="memItemLeft" align="right" valign="top"><a id="a54c497fcd02e23df8fa0f197922c4e2c" name="a54c497fcd02e23df8fa0f197922c4e2c"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>asinh</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a54c497fcd02e23df8fa0f197922c4e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse hyperbolic sine. <br /></td></tr>
<tr class="separator:a54c497fcd02e23df8fa0f197922c4e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124297369ecba10c8516dc5a920aad1a" id="r_a124297369ecba10c8516dc5a920aad1a"><td class="memItemLeft" align="right" valign="top"><a id="a124297369ecba10c8516dc5a920aad1a" name="a124297369ecba10c8516dc5a920aad1a"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>acosh</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a124297369ecba10c8516dc5a920aad1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse hyperbolic cosine. <br /></td></tr>
<tr class="separator:a124297369ecba10c8516dc5a920aad1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85064afd88800f3129e97d2e2955be4" id="r_ab85064afd88800f3129e97d2e2955be4"><td class="memItemLeft" align="right" valign="top"><a id="ab85064afd88800f3129e97d2e2955be4" name="ab85064afd88800f3129e97d2e2955be4"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>atanh</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:ab85064afd88800f3129e97d2e2955be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse hyperbolic tangent. <br /></td></tr>
<tr class="separator:ab85064afd88800f3129e97d2e2955be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a76685197faa15403e24b836830cf5d" id="r_a7a76685197faa15403e24b836830cf5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a7a76685197faa15403e24b836830cf5d">sigmoid</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a7a76685197faa15403e24b836830cf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sigmoid function.  <br /></td></tr>
<tr class="separator:a7a76685197faa15403e24b836830cf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efe3bd7ff87719aab92b67cec535096" id="r_a1efe3bd7ff87719aab92b67cec535096"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a1efe3bd7ff87719aab92b67cec535096">sinc</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a1efe3bd7ff87719aab92b67cec535096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized sinc function.  <br /></td></tr>
<tr class="separator:a1efe3bd7ff87719aab92b67cec535096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024554cae44fb42700e8f68d235f0f15" id="r_a024554cae44fb42700e8f68d235f0f15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a024554cae44fb42700e8f68d235f0f15">heaviside</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a024554cae44fb42700e8f68d235f0f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the heaviside function.  <br /></td></tr>
<tr class="separator:a024554cae44fb42700e8f68d235f0f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129bf1f1085a76b92999e0faeb30e831" id="r_a129bf1f1085a76b92999e0faeb30e831"><td class="memTemplParams" colspan="2">template&lt;typename IntType  = unsigned long long int&gt; </td></tr>
<tr class="memitem:a129bf1f1085a76b92999e0faeb30e831"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a129bf1f1085a76b92999e0faeb30e831">binomial_coeff</a> (unsigned int n, unsigned int m)</td></tr>
<tr class="memdesc:a129bf1f1085a76b92999e0faeb30e831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the binomial coefficient.  <br /></td></tr>
<tr class="separator:a129bf1f1085a76b92999e0faeb30e831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286f4d2ae42de1965c86c999927f128b" id="r_a286f4d2ae42de1965c86c999927f128b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a286f4d2ae42de1965c86c999927f128b">radians</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#a840b8c27d0a8398f33858b1f8d55732d">degrees</a>)</td></tr>
<tr class="memdesc:a286f4d2ae42de1965c86c999927f128b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert degrees to radians.  <br /></td></tr>
<tr class="separator:a286f4d2ae42de1965c86c999927f128b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840b8c27d0a8398f33858b1f8d55732d" id="r_a840b8c27d0a8398f33858b1f8d55732d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a840b8c27d0a8398f33858b1f8d55732d">degrees</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#a286f4d2ae42de1965c86c999927f128b">radians</a>)</td></tr>
<tr class="memdesc:a840b8c27d0a8398f33858b1f8d55732d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert radians to degrees.  <br /></td></tr>
<tr class="separator:a840b8c27d0a8398f33858b1f8d55732d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321928d10b6606c1cba0232a613e6dfe" id="r_a321928d10b6606c1cba0232a613e6dfe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a321928d10b6606c1cba0232a613e6dfe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a321928d10b6606c1cba0232a613e6dfe">kronecker_delta</a> (T i, T j)</td></tr>
<tr class="memdesc:a321928d10b6606c1cba0232a613e6dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker delta, equals 1 if i is equal to j, 0 otherwise.  <br /></td></tr>
<tr class="separator:a321928d10b6606c1cba0232a613e6dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30aae7ee5989d1ae26c670c757483176" id="r_a30aae7ee5989d1ae26c670c757483176"><td class="memTemplParams" colspan="2"><a id="a30aae7ee5989d1ae26c670c757483176" name="a30aae7ee5989d1ae26c670c757483176"></a>
template&lt;typename IntType  = unsigned long long int&gt; </td></tr>
<tr class="memitem:a30aae7ee5989d1ae26c670c757483176"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>catalan</b> (unsigned int n)</td></tr>
<tr class="memdesc:a30aae7ee5989d1ae26c670c757483176"><td class="mdescLeft">&#160;</td><td class="mdescRight">The n-th Catalan number. <br /></td></tr>
<tr class="separator:a30aae7ee5989d1ae26c670c757483176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b367e4460b8aec5f8c29282f671006" id="r_ab8b367e4460b8aec5f8c29282f671006"><td class="memTemplParams" colspan="2">template&lt;typename T  = real&gt; </td></tr>
<tr class="memitem:ab8b367e4460b8aec5f8c29282f671006"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab8b367e4460b8aec5f8c29282f671006">lagrange_polynomial</a> (const std::vector&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; T, 2 &gt; &gt; &amp;points)</td></tr>
<tr class="memdesc:ab8b367e4460b8aec5f8c29282f671006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Lagrange polynomial interpolating a set of points.  <br /></td></tr>
<tr class="separator:ab8b367e4460b8aec5f8c29282f671006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e8ede5b63e3e928ba06999468f33ef" id="r_a25e8ede5b63e3e928ba06999468f33ef"><td class="memTemplParams" colspan="2">template&lt;typename VectorType  = std::vector&lt;real&gt;&gt; </td></tr>
<tr class="memitem:a25e8ede5b63e3e928ba06999468f33ef"><td class="memTemplItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a25e8ede5b63e3e928ba06999468f33ef">chebyshev_nodes</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int n)</td></tr>
<tr class="memdesc:a25e8ede5b63e3e928ba06999468f33ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n Chebyshev nodes on a given interval.  <br /></td></tr>
<tr class="separator:a25e8ede5b63e3e928ba06999468f33ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc2216d71f0d7147b5c0dacdeea80db" id="r_a9dc2216d71f0d7147b5c0dacdeea80db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a9dc2216d71f0d7147b5c0dacdeea80db">interpolate_grid</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int order)</td></tr>
<tr class="memdesc:a9dc2216d71f0d7147b5c0dacdeea80db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the interpolating polynomial of a real function on an equidistant point sample.  <br /></td></tr>
<tr class="separator:a9dc2216d71f0d7147b5c0dacdeea80db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f9a26f1ee40dea3fced3ee7e0c9aa9" id="r_a88f9a26f1ee40dea3fced3ee7e0c9aa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a88f9a26f1ee40dea3fced3ee7e0c9aa9">interpolate_chebyshev</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int order)</td></tr>
<tr class="memdesc:a88f9a26f1ee40dea3fced3ee7e0c9aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the interpolating polynomial of a real function using Chebyshev nodes as sampling points.  <br /></td></tr>
<tr class="separator:a88f9a26f1ee40dea3fced3ee7e0c9aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0edd44311fc206d96919ab11d1977a9" id="r_aa0edd44311fc206d96919ab11d1977a9"><td class="memItemLeft" align="right" valign="top"><a id="aa0edd44311fc206d96919ab11d1977a9" name="aa0edd44311fc206d96919ab11d1977a9"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lerp</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:aa0edd44311fc206d96919ab11d1977a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolation. <br /></td></tr>
<tr class="separator:aa0edd44311fc206d96919ab11d1977a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab906f1a292b9290eaeb5b947b34561" id="r_a9ab906f1a292b9290eaeb5b947b34561"><td class="memTemplParams" colspan="2"><a id="a9ab906f1a292b9290eaeb5b947b34561" name="a9ab906f1a292b9290eaeb5b947b34561"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a9ab906f1a292b9290eaeb5b947b34561"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lerp</b> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P1, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:a9ab906f1a292b9290eaeb5b947b34561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolation. <br /></td></tr>
<tr class="separator:a9ab906f1a292b9290eaeb5b947b34561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a854543c4d5334c61247aed920937c7" id="r_a7a854543c4d5334c61247aed920937c7"><td class="memItemLeft" align="right" valign="top"><a id="a7a854543c4d5334c61247aed920937c7" name="a7a854543c4d5334c61247aed920937c7"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>invlerp</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> value)</td></tr>
<tr class="memdesc:a7a854543c4d5334c61247aed920937c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse linear interpolation. <br /></td></tr>
<tr class="separator:a7a854543c4d5334c61247aed920937c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7169371ce472198840dea64d46b21ca4" id="r_a7169371ce472198840dea64d46b21ca4"><td class="memTemplParams" colspan="2"><a id="a7169371ce472198840dea64d46b21ca4" name="a7169371ce472198840dea64d46b21ca4"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a7169371ce472198840dea64d46b21ca4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invlerp</b> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P1, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> value)</td></tr>
<tr class="memdesc:a7169371ce472198840dea64d46b21ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse linear interpolation. <br /></td></tr>
<tr class="separator:a7169371ce472198840dea64d46b21ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d55941e7aa059d066873e4116c531b0" id="r_a6d55941e7aa059d066873e4116c531b0"><td class="memItemLeft" align="right" valign="top"><a id="a6d55941e7aa059d066873e4116c531b0" name="a6d55941e7aa059d066873e4116c531b0"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>remap</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> iFrom, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> iTo, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> oFrom, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> oTo, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> value)</td></tr>
<tr class="memdesc:a6d55941e7aa059d066873e4116c531b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap a value from one range to another. <br /></td></tr>
<tr class="separator:a6d55941e7aa059d066873e4116c531b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71a4b01f78a3d0c9189041f667409b1" id="r_aa71a4b01f78a3d0c9189041f667409b1"><td class="memTemplParams" colspan="2"><a id="aa71a4b01f78a3d0c9189041f667409b1" name="aa71a4b01f78a3d0c9189041f667409b1"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aa71a4b01f78a3d0c9189041f667409b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>remap</b> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;iFrom, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;iTo, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;oFrom, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;oTo, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> value)</td></tr>
<tr class="memdesc:aa71a4b01f78a3d0c9189041f667409b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap a vector value from one range to another. <br /></td></tr>
<tr class="separator:aa71a4b01f78a3d0c9189041f667409b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7403a0756ef5ec70b2a821373def40" id="r_a5d7403a0756ef5ec70b2a821373def40"><td class="memTemplParams" colspan="2"><a id="a5d7403a0756ef5ec70b2a821373def40" name="a5d7403a0756ef5ec70b2a821373def40"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a5d7403a0756ef5ec70b2a821373def40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nlerp</b> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P1, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:a5d7403a0756ef5ec70b2a821373def40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalized linear interpolation. <br /></td></tr>
<tr class="separator:a5d7403a0756ef5ec70b2a821373def40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe689c12108304dd74edc6b6e92ff84" id="r_acfe689c12108304dd74edc6b6e92ff84"><td class="memTemplParams" colspan="2"><a id="acfe689c12108304dd74edc6b6e92ff84" name="acfe689c12108304dd74edc6b6e92ff84"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:acfe689c12108304dd74edc6b6e92ff84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>slerp</b> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P1, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> t)</td></tr>
<tr class="memdesc:acfe689c12108304dd74edc6b6e92ff84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spherical interpolation. <br /></td></tr>
<tr class="separator:acfe689c12108304dd74edc6b6e92ff84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b8a327e65a2d21993a28009828faae" id="r_a75b8a327e65a2d21993a28009828faae"><td class="memItemLeft" align="right" valign="top"><a id="a75b8a327e65a2d21993a28009828faae" name="a75b8a327e65a2d21993a28009828faae"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>smoothstep</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:a75b8a327e65a2d21993a28009828faae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smoothstep interpolation. <br /></td></tr>
<tr class="separator:a75b8a327e65a2d21993a28009828faae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423c4bdba84ea280878dcef43b5df206" id="r_a423c4bdba84ea280878dcef43b5df206"><td class="memItemLeft" align="right" valign="top"><a id="a423c4bdba84ea280878dcef43b5df206" name="a423c4bdba84ea280878dcef43b5df206"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>smootherstep</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:a423c4bdba84ea280878dcef43b5df206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smootherstep interpolation. <br /></td></tr>
<tr class="separator:a423c4bdba84ea280878dcef43b5df206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb40a700a725235c37a4ceeb1e09c7f6" id="r_afb40a700a725235c37a4ceeb1e09c7f6"><td class="memTemplParams" colspan="2"><a id="afb40a700a725235c37a4ceeb1e09c7f6" name="afb40a700a725235c37a4ceeb1e09c7f6"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:afb40a700a725235c37a4ceeb1e09c7f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quadratic_bezier</b> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P0, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P1, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> t)</td></tr>
<tr class="memdesc:afb40a700a725235c37a4ceeb1e09c7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quadratic Bezier curve. <br /></td></tr>
<tr class="separator:afb40a700a725235c37a4ceeb1e09c7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc018b01eb3df4f133863741a5ed343b" id="r_acc018b01eb3df4f133863741a5ed343b"><td class="memTemplParams" colspan="2"><a id="acc018b01eb3df4f133863741a5ed343b" name="acc018b01eb3df4f133863741a5ed343b"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:acc018b01eb3df4f133863741a5ed343b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cubic_bezier</b> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P0, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P1, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P2, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; P3, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> t)</td></tr>
<tr class="memdesc:acc018b01eb3df4f133863741a5ed343b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cubic Bezier curve. <br /></td></tr>
<tr class="separator:acc018b01eb3df4f133863741a5ed343b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bfc7cddd25fd7dd7eb774e9ea1bef4" id="r_ac9bfc7cddd25fd7dd7eb774e9ea1bef4"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ac9bfc7cddd25fd7dd7eb774e9ea1bef4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac9bfc7cddd25fd7dd7eb774e9ea1bef4">bezier</a> (const std::vector&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &gt; &amp;points, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> t)</td></tr>
<tr class="memdesc:ac9bfc7cddd25fd7dd7eb774e9ea1bef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic Bezier curve in N dimensions.  <br /></td></tr>
<tr class="separator:ac9bfc7cddd25fd7dd7eb774e9ea1bef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99316012fec5500c779ddf8d4114b643" id="r_a99316012fec5500c779ddf8d4114b643"><td class="memTemplParams" colspan="2">template&lt;typename DataPoints  = std::vector&lt;vec2&gt;&gt; </td></tr>
<tr class="memitem:a99316012fec5500c779ddf8d4114b643"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structtheoretica_1_1spline__node.html">spline_node</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a99316012fec5500c779ddf8d4114b643">cubic_splines</a> (DataPoints p)</td></tr>
<tr class="memdesc:a99316012fec5500c779ddf8d4114b643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cubic splines interpolation of a set of data points.  <br /></td></tr>
<tr class="separator:a99316012fec5500c779ddf8d4114b643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bf96b1e850f0901d249adbfea8f382" id="r_ae7bf96b1e850f0901d249adbfea8f382"><td class="memTemplParams" colspan="2">template&lt;typename Dataset1 , typename Dataset2 &gt; </td></tr>
<tr class="memitem:ae7bf96b1e850f0901d249adbfea8f382"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structtheoretica_1_1spline__node.html">spline_node</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ae7bf96b1e850f0901d249adbfea8f382">cubic_splines</a> (const Dataset1 &amp;x, const Dataset2 &amp;y)</td></tr>
<tr class="memdesc:ae7bf96b1e850f0901d249adbfea8f382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cubic splines interpolation of the sets of X and Y data points.  <br /></td></tr>
<tr class="separator:ae7bf96b1e850f0901d249adbfea8f382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8f4ab246c4b2b8ed36c3893880b6c4" id="r_aab8f4ab246c4b2b8ed36c3893880b6c4"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:aab8f4ab246c4b2b8ed36c3893880b6c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aab8f4ab246c4b2b8ed36c3893880b6c4">maximize_goldensection</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:aab8f4ab246c4b2b8ed36c3893880b6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function maximum using the Golden Section search algorithm.  <br /></td></tr>
<tr class="separator:aab8f4ab246c4b2b8ed36c3893880b6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a7880ad0abc4b7b03198d90001631c" id="r_ac3a7880ad0abc4b7b03198d90001631c"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:ac3a7880ad0abc4b7b03198d90001631c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac3a7880ad0abc4b7b03198d90001631c">minimize_goldensection</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:ac3a7880ad0abc4b7b03198d90001631c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function minimum using the Golden Section search algorithm.  <br /></td></tr>
<tr class="separator:ac3a7880ad0abc4b7b03198d90001631c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfdc59bb7d6b7bce2173add38cb7a89" id="r_accfdc59bb7d6b7bce2173add38cb7a89"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:accfdc59bb7d6b7bce2173add38cb7a89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#accfdc59bb7d6b7bce2173add38cb7a89">maximize_newton</a> (RealFunction f, RealFunction Df, RealFunction D2f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:accfdc59bb7d6b7bce2173add38cb7a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function maximum given the function and the first two derivatives using Newton-Raphson's method to find a root of the derivative.  <br /></td></tr>
<tr class="separator:accfdc59bb7d6b7bce2173add38cb7a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9dc22f3165357c127c26aa2a4b6c5e5" id="r_ae9dc22f3165357c127c26aa2a4b6c5e5"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:ae9dc22f3165357c127c26aa2a4b6c5e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ae9dc22f3165357c127c26aa2a4b6c5e5">minimize_newton</a> (RealFunction f, RealFunction Df, RealFunction D2f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:ae9dc22f3165357c127c26aa2a4b6c5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function minimum given the function and the first two derivatives using Newton-Raphson's method to find a root of the derivative.  <br /></td></tr>
<tr class="separator:ae9dc22f3165357c127c26aa2a4b6c5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e122e9c54b7f36043851a702fb7e79a" id="r_a4e122e9c54b7f36043851a702fb7e79a"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a4e122e9c54b7f36043851a702fb7e79a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a4e122e9c54b7f36043851a702fb7e79a">maximize_bisection</a> (RealFunction f, RealFunction Df, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:a4e122e9c54b7f36043851a702fb7e79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function maximum inside an interval given the function and its first derivative using bisection on the derivative.  <br /></td></tr>
<tr class="separator:a4e122e9c54b7f36043851a702fb7e79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9db1a3ca3da10bd76a8af20bb513ae" id="r_a0f9db1a3ca3da10bd76a8af20bb513ae"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a0f9db1a3ca3da10bd76a8af20bb513ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a0f9db1a3ca3da10bd76a8af20bb513ae">minimize_bisection</a> (RealFunction f, RealFunction Df, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:a0f9db1a3ca3da10bd76a8af20bb513ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function minimum inside an interval given the function and its first derivative using bisection on the derivative.  <br /></td></tr>
<tr class="separator:a0f9db1a3ca3da10bd76a8af20bb513ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf55462e13265d39fef3afe0cc375c92" id="r_aaf55462e13265d39fef3afe0cc375c92"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aaf55462e13265d39fef3afe0cc375c92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aaf55462e13265d39fef3afe0cc375c92">multi_minimize_grad</a> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; guess=<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> gamma=<a class="el" href="namespacetheoretica.html#aec69cb2482367d47a3d966c573b04fd6">OPTIMIZATION_MINGRAD_GAMMA</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a5a801e1df1e3281002e402a3f310bfb0">OPTIMIZATION_MINGRAD_TOLERANCE</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#a86e5dd300ac007074bcf54bfc9e59c6d">OPTIMIZATION_MINGRAD_ITER</a>)</td></tr>
<tr class="memdesc:aaf55462e13265d39fef3afe0cc375c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a local minimum of the given multivariate function using fixed-step gradient descent.  <br /></td></tr>
<tr class="separator:aaf55462e13265d39fef3afe0cc375c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1e891bf9ed955c5d05a1a41c01d832" id="r_a9f1e891bf9ed955c5d05a1a41c01d832"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a9f1e891bf9ed955c5d05a1a41c01d832"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a9f1e891bf9ed955c5d05a1a41c01d832">multi_maximize_grad</a> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; guess=<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> gamma=<a class="el" href="namespacetheoretica.html#aec69cb2482367d47a3d966c573b04fd6">OPTIMIZATION_MINGRAD_GAMMA</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a5a801e1df1e3281002e402a3f310bfb0">OPTIMIZATION_MINGRAD_TOLERANCE</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#a86e5dd300ac007074bcf54bfc9e59c6d">OPTIMIZATION_MINGRAD_ITER</a>)</td></tr>
<tr class="memdesc:a9f1e891bf9ed955c5d05a1a41c01d832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a local maximum of the given multivariate function using fixed-step gradient descent.  <br /></td></tr>
<tr class="separator:a9f1e891bf9ed955c5d05a1a41c01d832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006aae49f3c2e2d8a91c13d3485c902a" id="r_a006aae49f3c2e2d8a91c13d3485c902a"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a006aae49f3c2e2d8a91c13d3485c902a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a006aae49f3c2e2d8a91c13d3485c902a">multi_minimize_lingrad</a> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; guess=<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a5a801e1df1e3281002e402a3f310bfb0">OPTIMIZATION_MINGRAD_TOLERANCE</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#a86e5dd300ac007074bcf54bfc9e59c6d">OPTIMIZATION_MINGRAD_ITER</a>)</td></tr>
<tr class="memdesc:a006aae49f3c2e2d8a91c13d3485c902a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a local minimum of the given multivariate function using gradient descent with linear search.  <br /></td></tr>
<tr class="separator:a006aae49f3c2e2d8a91c13d3485c902a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7006f83864895393d90045a16a31bd04" id="r_a7006f83864895393d90045a16a31bd04"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a7006f83864895393d90045a16a31bd04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a7006f83864895393d90045a16a31bd04">multi_maximize_lingrad</a> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; guess=<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a5a801e1df1e3281002e402a3f310bfb0">OPTIMIZATION_MINGRAD_TOLERANCE</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#a86e5dd300ac007074bcf54bfc9e59c6d">OPTIMIZATION_MINGRAD_ITER</a>)</td></tr>
<tr class="memdesc:a7006f83864895393d90045a16a31bd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a local maximum of the given multivariate function using gradient descent with linear search.  <br /></td></tr>
<tr class="separator:a7006f83864895393d90045a16a31bd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1448b081afb964641757cc81cee35d7d" id="r_a1448b081afb964641757cc81cee35d7d"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a1448b081afb964641757cc81cee35d7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a1448b081afb964641757cc81cee35d7d">multi_minimize</a> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; guess=<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a5a801e1df1e3281002e402a3f310bfb0">OPTIMIZATION_MINGRAD_TOLERANCE</a>)</td></tr>
<tr class="memdesc:a1448b081afb964641757cc81cee35d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the best available algorithm to find a local minimum of the given multivariate function.  <br /></td></tr>
<tr class="separator:a1448b081afb964641757cc81cee35d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5703b4f09d1f4a018d2cca9e8aeaa3c2" id="r_a5703b4f09d1f4a018d2cca9e8aeaa3c2"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a5703b4f09d1f4a018d2cca9e8aeaa3c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a5703b4f09d1f4a018d2cca9e8aeaa3c2">multi_maximize</a> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; guess=<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a5a801e1df1e3281002e402a3f310bfb0">OPTIMIZATION_MINGRAD_TOLERANCE</a>)</td></tr>
<tr class="memdesc:a5703b4f09d1f4a018d2cca9e8aeaa3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the best available algorithm to find a local maximum of the given multivariate function.  <br /></td></tr>
<tr class="separator:a5703b4f09d1f4a018d2cca9e8aeaa3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266e22e5ea430f0524e91f2cc377387f" id="r_a266e22e5ea430f0524e91f2cc377387f"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a266e22e5ea430f0524e91f2cc377387f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a266e22e5ea430f0524e91f2cc377387f">multiroot_newton</a> (<a class="el" href="namespacetheoretica_1_1autodiff.html#abdc7bdd230700601e24de68a05d7ec08">autodiff::dvec_t</a>&lt; N &gt;(*f)(<a class="el" href="namespacetheoretica_1_1autodiff.html#abdc7bdd230700601e24de68a05d7ec08">autodiff::dvec_t</a>&lt; N &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; guess=<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a5a801e1df1e3281002e402a3f310bfb0">OPTIMIZATION_MINGRAD_TOLERANCE</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#a86e5dd300ac007074bcf54bfc9e59c6d">OPTIMIZATION_MINGRAD_ITER</a>)</td></tr>
<tr class="memdesc:a266e22e5ea430f0524e91f2cc377387f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the root of a multivariate function using Newton's method with pure Jacobian.  <br /></td></tr>
<tr class="separator:a266e22e5ea430f0524e91f2cc377387f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587130155867c6e054e3668a0aed581e" id="r_a587130155867c6e054e3668a0aed581e"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction , typename Vector  = vec2&gt; </td></tr>
<tr class="memitem:a587130155867c6e054e3668a0aed581e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Vector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a587130155867c6e054e3668a0aed581e">find_root_intervals</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int steps=10)</td></tr>
<tr class="memdesc:a587130155867c6e054e3668a0aed581e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find candidate intervals for root finding by evaluating a function at equidistant points inside an interval [a, b] and checking its sign.  <br /></td></tr>
<tr class="separator:a587130155867c6e054e3668a0aed581e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0649a3f31e025510b86dc7031c35f08" id="r_aa0649a3f31e025510b86dc7031c35f08"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:aa0649a3f31e025510b86dc7031c35f08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa0649a3f31e025510b86dc7031c35f08">root_bisect</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tol=<a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#ab2a935663988c6d893699a70ddfd7bdd">OPTIMIZATION_BISECTION_ITER</a>)</td></tr>
<tr class="memdesc:aa0649a3f31e025510b86dc7031c35f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the root of a univariate real function using bisection inside a compact interval [a, b] where \(f(a) * f(b) &lt; 0\).  <br /></td></tr>
<tr class="separator:aa0649a3f31e025510b86dc7031c35f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3de94cffc4e11a1a0fbaaa11db16d65" id="r_aa3de94cffc4e11a1a0fbaaa11db16d65"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:aa3de94cffc4e11a1a0fbaaa11db16d65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa3de94cffc4e11a1a0fbaaa11db16d65">root_itp</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tol=<a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a>, unsigned int n0=1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> k1=0.0)</td></tr>
<tr class="memdesc:aa3de94cffc4e11a1a0fbaaa11db16d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a root of a univariate real function using the ITP (Interpolate-Truncate-Project) method, by bracketing the zero inside a compact interval [a, b] where \(f(a) * f(b) &lt; 0\).  <br /></td></tr>
<tr class="separator:aa3de94cffc4e11a1a0fbaaa11db16d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12682ec4d92c0ad2c459f7a1ae2bfda4" id="r_a12682ec4d92c0ad2c459f7a1ae2bfda4"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a12682ec4d92c0ad2c459f7a1ae2bfda4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a12682ec4d92c0ad2c459f7a1ae2bfda4">root_newton</a> (RealFunction f, RealFunction Df, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0.0, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tol=<a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#ac83f2fa2a615e5fe6bf4acafa0549c3f">OPTIMIZATION_NEWTON_ITER</a>)</td></tr>
<tr class="memdesc:a12682ec4d92c0ad2c459f7a1ae2bfda4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a root of a univariate real function using Newton's method.  <br /></td></tr>
<tr class="separator:a12682ec4d92c0ad2c459f7a1ae2bfda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f0ff1bc27c68e40b1da5c870e1b15e" id="r_a13f0ff1bc27c68e40b1da5c870e1b15e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a13f0ff1bc27c68e40b1da5c870e1b15e">root_newton</a> (<a class="el" href="classtheoretica_1_1dual.html">dual</a>(*f)(<a class="el" href="classtheoretica_1_1dual.html">dual</a>), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tol=<a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#ac83f2fa2a615e5fe6bf4acafa0549c3f">OPTIMIZATION_NEWTON_ITER</a>)</td></tr>
<tr class="memdesc:a13f0ff1bc27c68e40b1da5c870e1b15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a root of a univariate real function using Newton's method, computing the derivative using automatic differentiation.  <br /></td></tr>
<tr class="separator:a13f0ff1bc27c68e40b1da5c870e1b15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ab9446feae0a1abf496061fae55d99" id="r_a33ab9446feae0a1abf496061fae55d99"><td class="memTemplParams" colspan="2">template&lt;typename Type  = real, typename ComplexFunction  = std::function&lt;complex&lt;Type&gt;(complex&lt;Type&gt;)&gt;&gt; </td></tr>
<tr class="memitem:a33ab9446feae0a1abf496061fae55d99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a33ab9446feae0a1abf496061fae55d99">root_newton</a> (ComplexFunction f, ComplexFunction Df, <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; Type &gt; guess, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tol=<a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#ac83f2fa2a615e5fe6bf4acafa0549c3f">OPTIMIZATION_NEWTON_ITER</a>)</td></tr>
<tr class="memdesc:a33ab9446feae0a1abf496061fae55d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a root of a complex function using Newton's method.  <br /></td></tr>
<tr class="separator:a33ab9446feae0a1abf496061fae55d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1feafa93b8400245b1004281f75ed39f" id="r_a1feafa93b8400245b1004281f75ed39f"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a1feafa93b8400245b1004281f75ed39f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a1feafa93b8400245b1004281f75ed39f">root_halley</a> (RealFunction f, RealFunction Df, RealFunction D2f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tol=<a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#ae648762992e4710d0d7d2c9d01c0e66d">OPTIMIZATION_HALLEY_ITER</a>)</td></tr>
<tr class="memdesc:a1feafa93b8400245b1004281f75ed39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a root of a univariate real function using Halley's method.  <br /></td></tr>
<tr class="separator:a1feafa93b8400245b1004281f75ed39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdea1fd73b49016d4d7bec2e829eb7e" id="r_a1bdea1fd73b49016d4d7bec2e829eb7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a1bdea1fd73b49016d4d7bec2e829eb7e">root_halley</a> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>(*f)(<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tol=<a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#ae648762992e4710d0d7d2c9d01c0e66d">OPTIMIZATION_HALLEY_ITER</a>)</td></tr>
<tr class="memdesc:a1bdea1fd73b49016d4d7bec2e829eb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a root of a univariate real function using Halley's method, leveraging automatic differentiation to compute the first and second derivatives of the function.  <br /></td></tr>
<tr class="separator:a1bdea1fd73b49016d4d7bec2e829eb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa127bcc16e700cfee3ae2105df3307" id="r_aafa127bcc16e700cfee3ae2105df3307"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:aafa127bcc16e700cfee3ae2105df3307"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aafa127bcc16e700cfee3ae2105df3307">root_steffensen</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tol=<a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#ab4d71500ca8667ee14c30bc90605db9d">OPTIMIZATION_STEFFENSEN_ITER</a>)</td></tr>
<tr class="memdesc:aafa127bcc16e700cfee3ae2105df3307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a root of a univariate real function using Steffensen's method.  <br /></td></tr>
<tr class="separator:aafa127bcc16e700cfee3ae2105df3307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f9fbd5182e447c5f16a48617e16aa4" id="r_ac8f9fbd5182e447c5f16a48617e16aa4"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:ac8f9fbd5182e447c5f16a48617e16aa4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac8f9fbd5182e447c5f16a48617e16aa4">root_chebyshev</a> (RealFunction f, RealFunction Df, RealFunction D2f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tol=<a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#ab147579539a73fa79bc4e13852eb53e9">OPTIMIZATION_CHEBYSHEV_ITER</a>)</td></tr>
<tr class="memdesc:ac8f9fbd5182e447c5f16a48617e16aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a root of a univariate real function using Chebyshev's method.  <br /></td></tr>
<tr class="separator:ac8f9fbd5182e447c5f16a48617e16aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9e164e51e8ed01e633dfa36633e439" id="r_a3e9e164e51e8ed01e633dfa36633e439"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a3e9e164e51e8ed01e633dfa36633e439">root_chebyshev</a> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>(*f)(<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tol=<a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#ab147579539a73fa79bc4e13852eb53e9">OPTIMIZATION_CHEBYSHEV_ITER</a>)</td></tr>
<tr class="memdesc:a3e9e164e51e8ed01e633dfa36633e439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a root of a univariate real function using Chebyshev's method, by computing the first and second derivatives using automatic differentiation.  <br /></td></tr>
<tr class="separator:a3e9e164e51e8ed01e633dfa36633e439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9662690d148c3037300c4f34c6c9d07" id="r_ab9662690d148c3037300c4f34c6c9d07"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:ab9662690d148c3037300c4f34c6c9d07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab9662690d148c3037300c4f34c6c9d07">root_ostrowski</a> (RealFunction f, RealFunction Df, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0.0, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tol=<a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#a6a8f4ef82e19e3dc1b382c03df5d15f9">OPTIMIZATION_OSTROWSKI_ITER</a>)</td></tr>
<tr class="memdesc:ab9662690d148c3037300c4f34c6c9d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a root of a univariate real function using Ostrowski's method.  <br /></td></tr>
<tr class="separator:ab9662690d148c3037300c4f34c6c9d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd038a12f3d962ecf4ee8c63ae0a22e" id="r_aefd038a12f3d962ecf4ee8c63ae0a22e"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:aefd038a12f3d962ecf4ee8c63ae0a22e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aefd038a12f3d962ecf4ee8c63ae0a22e">root_jarrat</a> (RealFunction f, RealFunction Df, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0.0, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tol=<a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#a10e44603eb761970ec19fd740bda6c21">OPTIMIZATION_JARRAT_ITER</a>)</td></tr>
<tr class="memdesc:aefd038a12f3d962ecf4ee8c63ae0a22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a root of a univariate real function using Jarrat's method.  <br /></td></tr>
<tr class="separator:aefd038a12f3d962ecf4ee8c63ae0a22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602a45107ab7d777486a587e8f032ed0" id="r_a602a45107ab7d777486a587e8f032ed0"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a602a45107ab7d777486a587e8f032ed0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a602a45107ab7d777486a587e8f032ed0">roots</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tol=<a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> steps=10)</td></tr>
<tr class="memdesc:a602a45107ab7d777486a587e8f032ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the roots of a univariate real function inside a given interval, by first searching for candidate intervals and then applying bracketing methods.  <br /></td></tr>
<tr class="separator:a602a45107ab7d777486a587e8f032ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabba19eeae5346a421f26e13e6a7e89" id="r_adabba19eeae5346a421f26e13e6a7e89"><td class="memTemplParams" colspan="2">template&lt;typename Field &gt; </td></tr>
<tr class="memitem:adabba19eeae5346a421f26e13e6a7e89"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Field &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#adabba19eeae5346a421f26e13e6a7e89">roots</a> (const <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; Field &gt; &amp;p, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a>, unsigned int steps=0)</td></tr>
<tr class="memdesc:adabba19eeae5346a421f26e13e6a7e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the roots of a polynomial.  <br /></td></tr>
<tr class="separator:adabba19eeae5346a421f26e13e6a7e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adf7d2f3094d32dd9d4059ec86247db" id="r_a5adf7d2f3094d32dd9d4059ec86247db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a5adf7d2f3094d32dd9d4059ec86247db">gen_polyn_recurr</a> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; P0, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; P1, <a class="el" href="namespacetheoretica.html#adcb53498374f76292a3da8bb8c785341">polyn_recurr_formula</a> f, unsigned int n)</td></tr>
<tr class="memdesc:a5adf7d2f3094d32dd9d4059ec86247db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a polynomial basis using a recursion formula.  <br /></td></tr>
<tr class="separator:a5adf7d2f3094d32dd9d4059ec86247db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed24464894a5a23896554578641576ac" id="r_aed24464894a5a23896554578641576ac"><td class="memItemLeft" align="right" valign="top"><a id="aed24464894a5a23896554578641576ac" name="aed24464894a5a23896554578641576ac"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>legendre_polyn_recurr</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; P0, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; P1, unsigned int l)</td></tr>
<tr class="memdesc:aed24464894a5a23896554578641576ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursion formula for Legendre polynomials. <br /></td></tr>
<tr class="separator:aed24464894a5a23896554578641576ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa95392d9bfc3ddf34f3e82f4b6ae78" id="r_acaa95392d9bfc3ddf34f3e82f4b6ae78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#acaa95392d9bfc3ddf34f3e82f4b6ae78">legendre_polynomial</a> (unsigned int n)</td></tr>
<tr class="memdesc:acaa95392d9bfc3ddf34f3e82f4b6ae78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nth Legendre polynomial.  <br /></td></tr>
<tr class="separator:acaa95392d9bfc3ddf34f3e82f4b6ae78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca937d779d223cab3a43b4236876491a" id="r_aca937d779d223cab3a43b4236876491a"><td class="memItemLeft" align="right" valign="top"><a id="aca937d779d223cab3a43b4236876491a" name="aca937d779d223cab3a43b4236876491a"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>legendre_polyn_normalization</b> (unsigned int n)</td></tr>
<tr class="memdesc:aca937d779d223cab3a43b4236876491a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalization constant for the nth Legendre polynomial. <br /></td></tr>
<tr class="separator:aca937d779d223cab3a43b4236876491a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5a48283ac42a9362f25d977d066cf3" id="r_a0b5a48283ac42a9362f25d977d066cf3"><td class="memItemLeft" align="right" valign="top"><a id="a0b5a48283ac42a9362f25d977d066cf3" name="a0b5a48283ac42a9362f25d977d066cf3"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>laguerre_polyn_recurr</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; L0, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; L1, unsigned int i)</td></tr>
<tr class="memdesc:a0b5a48283ac42a9362f25d977d066cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursion formula for Laguerre polynomials. <br /></td></tr>
<tr class="separator:a0b5a48283ac42a9362f25d977d066cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62665bb64745df12234614b05c2dfb3" id="r_af62665bb64745df12234614b05c2dfb3"><td class="memItemLeft" align="right" valign="top"><a id="af62665bb64745df12234614b05c2dfb3" name="af62665bb64745df12234614b05c2dfb3"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>laguerre_polynomial</b> (unsigned int n)</td></tr>
<tr class="memdesc:af62665bb64745df12234614b05c2dfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nth Laguerre polynomial. <br /></td></tr>
<tr class="separator:af62665bb64745df12234614b05c2dfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeafda1fc6155cc96c62d9d777d8f709" id="r_aaeafda1fc6155cc96c62d9d777d8f709"><td class="memItemLeft" align="right" valign="top"><a id="aaeafda1fc6155cc96c62d9d777d8f709" name="aaeafda1fc6155cc96c62d9d777d8f709"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>general_laguerre_polyn_recurr</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; L0, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; L1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha, unsigned int i)</td></tr>
<tr class="memdesc:aaeafda1fc6155cc96c62d9d777d8f709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursion formula for Generalized Laguerre polynomials. <br /></td></tr>
<tr class="separator:aaeafda1fc6155cc96c62d9d777d8f709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e5e8380097d9ad25a51413bcb244d3" id="r_ab3e5e8380097d9ad25a51413bcb244d3"><td class="memItemLeft" align="right" valign="top"><a id="ab3e5e8380097d9ad25a51413bcb244d3" name="ab3e5e8380097d9ad25a51413bcb244d3"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>general_laguerre_polynomial</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha, unsigned int n)</td></tr>
<tr class="memdesc:ab3e5e8380097d9ad25a51413bcb244d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nth Laguerre polynomial. <br /></td></tr>
<tr class="separator:ab3e5e8380097d9ad25a51413bcb244d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da3a4e4195c5c77e99db62ae442fa19" id="r_a2da3a4e4195c5c77e99db62ae442fa19"><td class="memItemLeft" align="right" valign="top"><a id="a2da3a4e4195c5c77e99db62ae442fa19" name="a2da3a4e4195c5c77e99db62ae442fa19"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>hermite_polyn_recurr</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; H0, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; H1, unsigned int i)</td></tr>
<tr class="memdesc:a2da3a4e4195c5c77e99db62ae442fa19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursion formula for Hermite polynomials. <br /></td></tr>
<tr class="separator:a2da3a4e4195c5c77e99db62ae442fa19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd97a0d6d99915f065567958760164f4" id="r_afd97a0d6d99915f065567958760164f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#afd97a0d6d99915f065567958760164f4">hermite_polynomial</a> (unsigned int n)</td></tr>
<tr class="memdesc:afd97a0d6d99915f065567958760164f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nth Hermite polynomial.  <br /></td></tr>
<tr class="separator:afd97a0d6d99915f065567958760164f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7659e1b121c8c96e884b95bb4ae45ebc" id="r_a7659e1b121c8c96e884b95bb4ae45ebc"><td class="memItemLeft" align="right" valign="top"><a id="a7659e1b121c8c96e884b95bb4ae45ebc" name="a7659e1b121c8c96e884b95bb4ae45ebc"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hermite_polyn_normalization</b> (unsigned int n)</td></tr>
<tr class="memdesc:a7659e1b121c8c96e884b95bb4ae45ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalization constant for the nth Hermite polynomial. <br /></td></tr>
<tr class="separator:a7659e1b121c8c96e884b95bb4ae45ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e77e33cee4661bf1a52bec32fa434c" id="r_ac8e77e33cee4661bf1a52bec32fa434c"><td class="memItemLeft" align="right" valign="top"><a id="ac8e77e33cee4661bf1a52bec32fa434c" name="ac8e77e33cee4661bf1a52bec32fa434c"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>chebyshev_polyn_recurr</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; T0, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; T1, unsigned int i)</td></tr>
<tr class="memdesc:ac8e77e33cee4661bf1a52bec32fa434c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursion formula for Chebyshev polynomials The formula is the same for first and second kind polynomials. <br /></td></tr>
<tr class="separator:ac8e77e33cee4661bf1a52bec32fa434c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085e34f437a529b59778090e0cb122e5" id="r_a085e34f437a529b59778090e0cb122e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a085e34f437a529b59778090e0cb122e5">chebyshev1_polynomial</a> (unsigned int n)</td></tr>
<tr class="memdesc:a085e34f437a529b59778090e0cb122e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nth Chebyshev polynomial of the first kind.  <br /></td></tr>
<tr class="separator:a085e34f437a529b59778090e0cb122e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3450aa75a960635e9f33a6dabb22752b" id="r_a3450aa75a960635e9f33a6dabb22752b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a3450aa75a960635e9f33a6dabb22752b">chebyshev2_polynomial</a> (unsigned int n)</td></tr>
<tr class="memdesc:a3450aa75a960635e9f33a6dabb22752b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nth Chebyshev polynomial of the second kind.  <br /></td></tr>
<tr class="separator:a3450aa75a960635e9f33a6dabb22752b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbaeffb922b25d5f1758296b473939f" id="r_aebbaeffb922b25d5f1758296b473939f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aebbaeffb922b25d5f1758296b473939f">legendre_roots</a> (unsigned int n)</td></tr>
<tr class="memdesc:aebbaeffb922b25d5f1758296b473939f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Roots of the n-th Legendre polynomial.  <br /></td></tr>
<tr class="separator:aebbaeffb922b25d5f1758296b473939f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40aca2488b0466c4934fd050d3718760" id="r_a40aca2488b0466c4934fd050d3718760"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a40aca2488b0466c4934fd050d3718760">legendre_weights</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;<a class="el" href="namespacetheoretica.html#a602a45107ab7d777486a587e8f032ed0">roots</a>)</td></tr>
<tr class="memdesc:a40aca2488b0466c4934fd050d3718760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legendre weights for Gauss-Legendre quadrature of n-th order.  <br /></td></tr>
<tr class="separator:a40aca2488b0466c4934fd050d3718760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b528fc8814c1dd197a21d49f1ad6c93" id="r_a4b528fc8814c1dd197a21d49f1ad6c93"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a4b528fc8814c1dd197a21d49f1ad6c93">laguerre_weights</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;<a class="el" href="namespacetheoretica.html#a602a45107ab7d777486a587e8f032ed0">roots</a>)</td></tr>
<tr class="memdesc:a4b528fc8814c1dd197a21d49f1ad6c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Laguerre weights for Gauss-Laguerre quadrature of n-th order.  <br /></td></tr>
<tr class="separator:a4b528fc8814c1dd197a21d49f1ad6c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04806d2927b08fe51b37c5a1c517de35" id="r_a04806d2927b08fe51b37c5a1c517de35"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a04806d2927b08fe51b37c5a1c517de35">hermite_weights</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;<a class="el" href="namespacetheoretica.html#a602a45107ab7d777486a587e8f032ed0">roots</a>)</td></tr>
<tr class="memdesc:a04806d2927b08fe51b37c5a1c517de35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermite weights for Gauss-Hermite quadrature of n-th order.  <br /></td></tr>
<tr class="separator:a04806d2927b08fe51b37c5a1c517de35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07652c066aaca0e41b16a21554bc5a28" id="r_a07652c066aaca0e41b16a21554bc5a28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a07652c066aaca0e41b16a21554bc5a28">integral_crude</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int N=1000)</td></tr>
<tr class="memdesc:a07652c066aaca0e41b16a21554bc5a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Crude Monte Carlo integration.  <br /></td></tr>
<tr class="separator:a07652c066aaca0e41b16a21554bc5a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301de055cdb4b0a9888d68dc8382b5cf" id="r_a301de055cdb4b0a9888d68dc8382b5cf"><td class="memTemplParams" colspan="2">template&lt;unsigned int S&gt; </td></tr>
<tr class="memitem:a301de055cdb4b0a9888d68dc8382b5cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a301de055cdb4b0a9888d68dc8382b5cf">integral_crude</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, S &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a1f21bd68ba64b172c29d9fce15c8712d">vec2</a>, S &gt; extremes, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int N=1000)</td></tr>
<tr class="memdesc:a301de055cdb4b0a9888d68dc8382b5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Crude Monte Carlo integration.  <br /></td></tr>
<tr class="separator:a301de055cdb4b0a9888d68dc8382b5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c69bea27399e4d430e877b538ce777" id="r_a11c69bea27399e4d430e877b538ce777"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a11c69bea27399e4d430e877b538ce777">integral_quasi_crude</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int N=1000)</td></tr>
<tr class="memdesc:a11c69bea27399e4d430e877b538ce777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Crude Quasi-Monte Carlo integration by sampling from the Weyl sequence.  <br /></td></tr>
<tr class="separator:a11c69bea27399e4d430e877b538ce777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad6a42bf9fd0176e622e01e0f7446a9" id="r_abad6a42bf9fd0176e622e01e0f7446a9"><td class="memTemplParams" colspan="2">template&lt;unsigned int S&gt; </td></tr>
<tr class="memitem:abad6a42bf9fd0176e622e01e0f7446a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abad6a42bf9fd0176e622e01e0f7446a9">integral_quasi_crude</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, S &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a1f21bd68ba64b172c29d9fce15c8712d">vec2</a>, S &gt; extremes, unsigned int N, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, S &gt; alpha)</td></tr>
<tr class="memdesc:abad6a42bf9fd0176e622e01e0f7446a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Crude Quasi-Monte Carlo integration by sampling from the Weyl sequence.  <br /></td></tr>
<tr class="separator:abad6a42bf9fd0176e622e01e0f7446a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed022df42e2b7152fc916433acbfbcc" id="r_a4ed022df42e2b7152fc916433acbfbcc"><td class="memTemplParams" colspan="2">template&lt;unsigned int S&gt; </td></tr>
<tr class="memitem:a4ed022df42e2b7152fc916433acbfbcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a4ed022df42e2b7152fc916433acbfbcc">integral_quasi_crude</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, S &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a1f21bd68ba64b172c29d9fce15c8712d">vec2</a>, S &gt; extremes, unsigned int N=1000, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha=0)</td></tr>
<tr class="memdesc:a4ed022df42e2b7152fc916433acbfbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Crude Quasi-Monte Carlo integration by sampling from the Weyl sequence.  <br /></td></tr>
<tr class="separator:a4ed022df42e2b7152fc916433acbfbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369a64e60df5e45af0bb4581a9f213da" id="r_a369a64e60df5e45af0bb4581a9f213da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a369a64e60df5e45af0bb4581a9f213da">integral_hom</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> c, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> d, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int N=1000)</td></tr>
<tr class="memdesc:a369a64e60df5e45af0bb4581a9f213da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Hit-or-miss Monte Carlo integration.  <br /></td></tr>
<tr class="separator:a369a64e60df5e45af0bb4581a9f213da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8b0a1c223e7bc79b04046d4e8502da" id="r_afd8b0a1c223e7bc79b04046d4e8502da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#afd8b0a1c223e7bc79b04046d4e8502da">integral_hom</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> f_max, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int N=1000)</td></tr>
<tr class="memdesc:afd8b0a1c223e7bc79b04046d4e8502da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Hit-or-miss Monte Carlo integration.  <br /></td></tr>
<tr class="separator:afd8b0a1c223e7bc79b04046d4e8502da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2655b89d203adc197979dafd29fe518b" id="r_a2655b89d203adc197979dafd29fe518b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a2655b89d203adc197979dafd29fe518b">integral_quasi_hom</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> c, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> d, unsigned int N=1000)</td></tr>
<tr class="memdesc:a2655b89d203adc197979dafd29fe518b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Hit-or-miss Quasi-Monte Carlo integration, sampling points from the Weyl bi-dimensional sequence.  <br /></td></tr>
<tr class="separator:a2655b89d203adc197979dafd29fe518b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f21b203e4325f357c2c84558239269" id="r_a22f21b203e4325f357c2c84558239269"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a22f21b203e4325f357c2c84558239269">integral_quasi_hom</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> f_max, unsigned int N=1000)</td></tr>
<tr class="memdesc:a22f21b203e4325f357c2c84558239269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Hit-or-miss Quasi-Monte Carlo integration, sampling points from the Weyl bi-dimensional sequence.  <br /></td></tr>
<tr class="separator:a22f21b203e4325f357c2c84558239269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1373c528867e33024d2975dfa7c41ca4" id="r_a1373c528867e33024d2975dfa7c41ca4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a1373c528867e33024d2975dfa7c41ca4">integral_hom_2d</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> c, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> d, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> f_max, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int N=1000)</td></tr>
<tr class="memdesc:a1373c528867e33024d2975dfa7c41ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Hit-or-Miss Monte Carlo method to approximate a double integral.  <br /></td></tr>
<tr class="separator:a1373c528867e33024d2975dfa7c41ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1d65e5dba67ccf5199e5d5544e2484" id="r_a3d1d65e5dba67ccf5199e5d5544e2484"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a3d1d65e5dba67ccf5199e5d5544e2484">integral_impsamp</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> g, <a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> Ginv, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;gen, unsigned int N=1000)</td></tr>
<tr class="memdesc:a3d1d65e5dba67ccf5199e5d5544e2484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Crude Monte Carlo integration with importance sampling.  <br /></td></tr>
<tr class="separator:a3d1d65e5dba67ccf5199e5d5544e2484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edff8be282482211b0cbc6cd022222e" id="r_a0edff8be282482211b0cbc6cd022222e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a0edff8be282482211b0cbc6cd022222e">integral_quasi_impsamp</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> g, <a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> Ginv, unsigned int N=1000)</td></tr>
<tr class="memdesc:a0edff8be282482211b0cbc6cd022222e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Crude Quasi-Monte Carlo integration with importance sampling, using the Weyl sequence.  <br /></td></tr>
<tr class="separator:a0edff8be282482211b0cbc6cd022222e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891845bdf03e80b72925c16db545606f" id="r_a891845bdf03e80b72925c16db545606f"><td class="memTemplParams" colspan="2">template&lt;typename Vector  = std::vector&lt;real&gt;, typename Function  = std::function&lt;real(vec&lt;real&gt;)&gt;&gt; </td></tr>
<tr class="memitem:a891845bdf03e80b72925c16db545606f"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a891845bdf03e80b72925c16db545606f">sample_mc</a> (Function f, std::vector&lt; <a class="el" href="structtheoretica_1_1pdf__sampler.html">pdf_sampler</a> &gt; &amp;rv, unsigned int N)</td></tr>
<tr class="memdesc:a891845bdf03e80b72925c16db545606f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Monte Carlo sample of values of a given function of arbitrary variables following the given distributions.  <br /></td></tr>
<tr class="separator:a891845bdf03e80b72925c16db545606f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8679d2642c8820e78e33f7aa3294f7eb" id="r_a8679d2642c8820e78e33f7aa3294f7eb"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a8679d2642c8820e78e33f7aa3294f7eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a8679d2642c8820e78e33f7aa3294f7eb">shuffle</a> (Vector &amp;v, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int rounds=0)</td></tr>
<tr class="memdesc:a8679d2642c8820e78e33f7aa3294f7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffle a set by exchanging random couples of elements.  <br /></td></tr>
<tr class="separator:a8679d2642c8820e78e33f7aa3294f7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafab10ea5cdd0da85e7eca301936c0d0" id="r_aafab10ea5cdd0da85e7eca301936c0d0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aafab10ea5cdd0da85e7eca301936c0d0">randgen_congruential</a> (uint64_t x, uint64_t a=48271, uint64_t c=0, uint64_t m=((uint64_t) 1&lt;&lt; 31) - 1)</td></tr>
<tr class="memdesc:aafab10ea5cdd0da85e7eca301936c0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudorandom natural number using the congruential pseudorandom number generation algorithm.  <br /></td></tr>
<tr class="separator:aafab10ea5cdd0da85e7eca301936c0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01565fc76eac80418a68b0076f0e5c1d" id="r_a01565fc76eac80418a68b0076f0e5c1d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a01565fc76eac80418a68b0076f0e5c1d">randgen_congruential</a> (uint64_t x, std::vector&lt; uint64_t &gt; &amp;state)</td></tr>
<tr class="memdesc:a01565fc76eac80418a68b0076f0e5c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudorandom natural number using the congruential pseudorandom number generation algorithm (wrapper)  <br /></td></tr>
<tr class="separator:a01565fc76eac80418a68b0076f0e5c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b453326547b2d165f095733e67a10d" id="r_a32b453326547b2d165f095733e67a10d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a32b453326547b2d165f095733e67a10d">randgen_xoshiro</a> (uint64_t &amp;a, uint64_t &amp;b, uint64_t &amp;c, uint64_t &amp;d)</td></tr>
<tr class="memdesc:a32b453326547b2d165f095733e67a10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudorandom natural number using the xoshiro256++ pseudorandom number generation algorithm.  <br /></td></tr>
<tr class="separator:a32b453326547b2d165f095733e67a10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae939f7e9a1eaee809da226cbfbd883e" id="r_aae939f7e9a1eaee809da226cbfbd883e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aae939f7e9a1eaee809da226cbfbd883e">randgen_xoshiro</a> (uint64_t x, std::vector&lt; uint64_t &gt; &amp;state)</td></tr>
<tr class="memdesc:aae939f7e9a1eaee809da226cbfbd883e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudorandom natural number using the xoshiro256++ pseudorandom number generation algorithm (wrapper)  <br /></td></tr>
<tr class="separator:aae939f7e9a1eaee809da226cbfbd883e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c543b2a35f826b5cbac8d2c55423cb3" id="r_a8c543b2a35f826b5cbac8d2c55423cb3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a8c543b2a35f826b5cbac8d2c55423cb3">randgen_splitmix64</a> (uint64_t x)</td></tr>
<tr class="memdesc:a8c543b2a35f826b5cbac8d2c55423cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudorandom natural number using the SplitMix64 pseudorandom number generation algorithm.  <br /></td></tr>
<tr class="separator:a8c543b2a35f826b5cbac8d2c55423cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1748188bd7af18f43b175f39b52aa9" id="r_a6e1748188bd7af18f43b175f39b52aa9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6e1748188bd7af18f43b175f39b52aa9">randgen_splitmix64</a> (uint64_t x, std::vector&lt; uint64_t &gt; &amp;p)</td></tr>
<tr class="memdesc:a6e1748188bd7af18f43b175f39b52aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudorandom natural number using the SplitMix64 pseudorandom number generation algorithm.  <br /></td></tr>
<tr class="separator:a6e1748188bd7af18f43b175f39b52aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa4e075d9a95b8a060832e053eede81" id="r_acaa4e075d9a95b8a060832e053eede81"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#acaa4e075d9a95b8a060832e053eede81">randgen_wyrand</a> (uint64_t &amp;seed, uint64_t p1, uint64_t p2)</td></tr>
<tr class="memdesc:acaa4e075d9a95b8a060832e053eede81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudorandom natural number using the Wyrand pseudorandom number generation, as invented by Yi Wang.  <br /></td></tr>
<tr class="separator:acaa4e075d9a95b8a060832e053eede81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6556353391af45a096cc875c7c535f5" id="r_ac6556353391af45a096cc875c7c535f5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac6556353391af45a096cc875c7c535f5">randgen_wyrand</a> (uint64_t x, std::vector&lt; uint64_t &gt; &amp;p)</td></tr>
<tr class="memdesc:ac6556353391af45a096cc875c7c535f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudorandom natural number using the Wyrand pseudorandom number generation, as invented by Yi Wang (wrapper)  <br /></td></tr>
<tr class="separator:ac6556353391af45a096cc875c7c535f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a82c81ffa9c26b29666bee9c4255a7" id="r_aa8a82c81ffa9c26b29666bee9c4255a7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa8a82c81ffa9c26b29666bee9c4255a7">randgen_middlesquare</a> (uint64_t seed, uint64_t offset=765872292751861)</td></tr>
<tr class="memdesc:aa8a82c81ffa9c26b29666bee9c4255a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudorandom natural number using the middle-square pseudorandom number generation algorithm.  <br /></td></tr>
<tr class="separator:aa8a82c81ffa9c26b29666bee9c4255a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0eae50ce4c989d7120cab32259f965" id="r_a0e0eae50ce4c989d7120cab32259f965"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a0e0eae50ce4c989d7120cab32259f965">randgen_middlesquare</a> (uint64_t x, std::vector&lt; uint64_t &gt; &amp;p)</td></tr>
<tr class="memdesc:a0e0eae50ce4c989d7120cab32259f965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudorandom natural number using the middle-square pseudorandom number generation algorithm (wrapper)  <br /></td></tr>
<tr class="separator:a0e0eae50ce4c989d7120cab32259f965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e523c1cc3621e7cbc1ac0df01913c3" id="r_aa7e523c1cc3621e7cbc1ac0df01913c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa7e523c1cc3621e7cbc1ac0df01913c3">qrand_weyl</a> (unsigned int n, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha=<a class="el" href="namespacetheoretica.html#a6a6de16e5ee81d340ff91dbadb99edde">INVPHI</a>)</td></tr>
<tr class="memdesc:aa7e523c1cc3621e7cbc1ac0df01913c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weyl quasi-random sequence.  <br /></td></tr>
<tr class="separator:aa7e523c1cc3621e7cbc1ac0df01913c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5001951408c716ce4e6414cc45f420" id="r_a6c5001951408c716ce4e6414cc45f420"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6c5001951408c716ce4e6414cc45f420">qrand_weyl_recurr</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> prev=0, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha=<a class="el" href="namespacetheoretica.html#a6a6de16e5ee81d340ff91dbadb99edde">INVPHI</a>)</td></tr>
<tr class="memdesc:a6c5001951408c716ce4e6414cc45f420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weyl quasi-random sequence (computed with recurrence relation)  <br /></td></tr>
<tr class="separator:a6c5001951408c716ce4e6414cc45f420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216195a1bbd4fed54c50cce034e48bfa" id="r_a216195a1bbd4fed54c50cce034e48bfa"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a216195a1bbd4fed54c50cce034e48bfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a216195a1bbd4fed54c50cce034e48bfa">qrand_weyl_multi</a> (unsigned int n, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha)</td></tr>
<tr class="memdesc:a216195a1bbd4fed54c50cce034e48bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weyl quasi-random sequence in N dimensions.  <br /></td></tr>
<tr class="separator:a216195a1bbd4fed54c50cce034e48bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d4be50bf77c6b368c94bb627305224" id="r_ac1d4be50bf77c6b368c94bb627305224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a1f21bd68ba64b172c29d9fce15c8712d">vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac1d4be50bf77c6b368c94bb627305224">qrand_weyl2</a> (unsigned int n, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha=0.7548776662466927)</td></tr>
<tr class="memdesc:ac1d4be50bf77c6b368c94bb627305224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weyl quasi-random sequence in 2 dimensions.  <br /></td></tr>
<tr class="separator:ac1d4be50bf77c6b368c94bb627305224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579b4ccc4078b67b7ec795b744e436d5" id="r_a579b4ccc4078b67b7ec795b744e436d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a579b4ccc4078b67b7ec795b744e436d5">rand_uniform</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, uint64_t prec=<a class="el" href="namespacetheoretica.html#a2ab0dc413ccb1d809e2269de05dbf48d">STATISTICS_RAND_PREC</a>)</td></tr>
<tr class="memdesc:a579b4ccc4078b67b7ec795b744e436d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudorandom real number in [a, b] using a preexisting generator.  <br /></td></tr>
<tr class="separator:a579b4ccc4078b67b7ec795b744e436d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e77a1836e1b966cdbb0934d5ebbbf2" id="r_ad7e77a1836e1b966cdbb0934d5ebbbf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad7e77a1836e1b966cdbb0934d5ebbbf2">rand_uniform</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:ad7e77a1836e1b966cdbb0934d5ebbbf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_uniform(real, real, PRNG)  <br /></td></tr>
<tr class="separator:ad7e77a1836e1b966cdbb0934d5ebbbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ddd9fc13f4c8b28ea4025640cbadf4" id="r_a99ddd9fc13f4c8b28ea4025640cbadf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a99ddd9fc13f4c8b28ea4025640cbadf4">rand_cointoss</a> (<a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a99ddd9fc13f4c8b28ea4025640cbadf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coin toss random generator.  <br /></td></tr>
<tr class="separator:a99ddd9fc13f4c8b28ea4025640cbadf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada12d3bc9842b85e97e14f0eb975e132" id="r_ada12d3bc9842b85e97e14f0eb975e132"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ada12d3bc9842b85e97e14f0eb975e132">rand_cointoss</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:ada12d3bc9842b85e97e14f0eb975e132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_cointoss(PRNG)  <br /></td></tr>
<tr class="separator:ada12d3bc9842b85e97e14f0eb975e132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968bc8465bcb421983d457b96469e9ef" id="r_a968bc8465bcb421983d457b96469e9ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a968bc8465bcb421983d457b96469e9ef">rand_diceroll</a> (unsigned int faces, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a968bc8465bcb421983d457b96469e9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dice roll random generator.  <br /></td></tr>
<tr class="separator:a968bc8465bcb421983d457b96469e9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709a55686cbd545429284beb16eef7b7" id="r_a709a55686cbd545429284beb16eef7b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a709a55686cbd545429284beb16eef7b7">rand_diceroll</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a709a55686cbd545429284beb16eef7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_diceroll(PRNG)  <br /></td></tr>
<tr class="separator:a709a55686cbd545429284beb16eef7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbe6df09ae3883660614f02f70a2ade" id="r_accbe6df09ae3883660614f02f70a2ade"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#accbe6df09ae3883660614f02f70a2ade">rand_trycatch</a> (<a class="el" href="namespacetheoretica.html#ac7a0bafb035970e4921b84f75661e2b1">stat_function</a> f, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y2, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#a69a848b21acb5341a013db4baa629bde">STATISTICS_TRYANDCATCH_ITER</a>)</td></tr>
<tr class="memdesc:accbe6df09ae3883660614f02f70a2ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudorandom value following any probability distribution function using the Try-and-Catch (rejection) algorithm.  <br /></td></tr>
<tr class="separator:accbe6df09ae3883660614f02f70a2ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e708ed0859828011f0d262c93274ec3" id="r_a7e708ed0859828011f0d262c93274ec3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a7e708ed0859828011f0d262c93274ec3">rand_rejectsamp</a> (<a class="el" href="namespacetheoretica.html#ac7a0bafb035970e4921b84f75661e2b1">stat_function</a> f, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> p, <a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> Pinv, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int max_tries=100)</td></tr>
<tr class="memdesc:a7e708ed0859828011f0d262c93274ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following any given distribution using rejection sampling.  <br /></td></tr>
<tr class="separator:a7e708ed0859828011f0d262c93274ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bdf0dc89459fedaf6950c0f9b96df5" id="r_ac8bdf0dc89459fedaf6950c0f9b96df5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac8bdf0dc89459fedaf6950c0f9b96df5">rand_gaussian_polar</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> mean, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:ac8bdf0dc89459fedaf6950c0f9b96df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Gaussian distribution using Marsaglia's polar method.  <br /></td></tr>
<tr class="separator:ac8bdf0dc89459fedaf6950c0f9b96df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d0c9531b268c00e759cb571422e01f" id="r_a91d0c9531b268c00e759cb571422e01f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a91d0c9531b268c00e759cb571422e01f">rand_gaussian_boxmuller</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> mean, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a91d0c9531b268c00e759cb571422e01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Gaussian distribution using the Box-Muller method.  <br /></td></tr>
<tr class="separator:a91d0c9531b268c00e759cb571422e01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c36b22d9b1f9f2beeab1c7be35fe8b3" id="r_a8c36b22d9b1f9f2beeab1c7be35fe8b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a8c36b22d9b1f9f2beeab1c7be35fe8b3">rand_gaussian_clt</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> mean, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a8c36b22d9b1f9f2beeab1c7be35fe8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number in a range following a Gaussian distribution by exploiting the Central Limit Theorem.  <br /></td></tr>
<tr class="separator:a8c36b22d9b1f9f2beeab1c7be35fe8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b8d1fc98c8429d4b342e860cab6ed1" id="r_af2b8d1fc98c8429d4b342e860cab6ed1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af2b8d1fc98c8429d4b342e860cab6ed1">rand_gaussian_clt</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> mean, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int N)</td></tr>
<tr class="memdesc:af2b8d1fc98c8429d4b342e860cab6ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number in a range following a Gaussian distribution by exploiting the Central Limit Theorem.  <br /></td></tr>
<tr class="separator:af2b8d1fc98c8429d4b342e860cab6ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856e584fd661d664a36cb185c8abd6ba" id="r_a856e584fd661d664a36cb185c8abd6ba"><td class="memItemLeft" align="right" valign="top"><a id="a856e584fd661d664a36cb185c8abd6ba" name="a856e584fd661d664a36cb185c8abd6ba"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_gaussian</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> mean, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a856e584fd661d664a36cb185c8abd6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Gaussian distribution using the best available algorithm. <br /></td></tr>
<tr class="separator:a856e584fd661d664a36cb185c8abd6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2c1865b7a5639ed82643a069554e3d" id="r_aad2c1865b7a5639ed82643a069554e3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aad2c1865b7a5639ed82643a069554e3d">rand_gaussian</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:aad2c1865b7a5639ed82643a069554e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_gaussian(real, real, PRNG)  <br /></td></tr>
<tr class="separator:aad2c1865b7a5639ed82643a069554e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fc6d88e78808dfe4a4bbb03798a754" id="r_a40fc6d88e78808dfe4a4bbb03798a754"><td class="memItemLeft" align="right" valign="top"><a id="a40fc6d88e78808dfe4a4bbb03798a754" name="a40fc6d88e78808dfe4a4bbb03798a754"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_exponential</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> lambda, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a40fc6d88e78808dfe4a4bbb03798a754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following an exponential distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:a40fc6d88e78808dfe4a4bbb03798a754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e6165f6c783179d1b3c2e321b3e7d4" id="r_aa2e6165f6c783179d1b3c2e321b3e7d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa2e6165f6c783179d1b3c2e321b3e7d4">rand_exponential</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:aa2e6165f6c783179d1b3c2e321b3e7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_exponential(real, PRNG)  <br /></td></tr>
<tr class="separator:aa2e6165f6c783179d1b3c2e321b3e7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c93a1f60698d75caa21a305e2ba107" id="r_a55c93a1f60698d75caa21a305e2ba107"><td class="memItemLeft" align="right" valign="top"><a id="a55c93a1f60698d75caa21a305e2ba107" name="a55c93a1f60698d75caa21a305e2ba107"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_rayleigh</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a55c93a1f60698d75caa21a305e2ba107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Rayleigh distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:a55c93a1f60698d75caa21a305e2ba107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012d14c9ef85d6f3028bf8ceb1008787" id="r_a012d14c9ef85d6f3028bf8ceb1008787"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a012d14c9ef85d6f3028bf8ceb1008787">rand_rayleigh</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a012d14c9ef85d6f3028bf8ceb1008787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_rayleigh(real, PRNG)  <br /></td></tr>
<tr class="separator:a012d14c9ef85d6f3028bf8ceb1008787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34a4b6660c0287dc6dfa979a2f83002" id="r_ac34a4b6660c0287dc6dfa979a2f83002"><td class="memItemLeft" align="right" valign="top"><a id="ac34a4b6660c0287dc6dfa979a2f83002" name="ac34a4b6660c0287dc6dfa979a2f83002"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_cauchy</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> mu, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:ac34a4b6660c0287dc6dfa979a2f83002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Cauchy distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:ac34a4b6660c0287dc6dfa979a2f83002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473df88a9edd9ccc8dcf03665591575b" id="r_a473df88a9edd9ccc8dcf03665591575b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a473df88a9edd9ccc8dcf03665591575b">rand_cauchy</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a473df88a9edd9ccc8dcf03665591575b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_cauchy(real, real, PRNG)  <br /></td></tr>
<tr class="separator:a473df88a9edd9ccc8dcf03665591575b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01522152b1ccfd9a7db77654b6d8c12a" id="r_a01522152b1ccfd9a7db77654b6d8c12a"><td class="memItemLeft" align="right" valign="top"><a id="a01522152b1ccfd9a7db77654b6d8c12a" name="a01522152b1ccfd9a7db77654b6d8c12a"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_laplace</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> mu, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a01522152b1ccfd9a7db77654b6d8c12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Laplace distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:a01522152b1ccfd9a7db77654b6d8c12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441cea1ebea409b2deb0ba387febc626" id="r_a441cea1ebea409b2deb0ba387febc626"><td class="memItemLeft" align="right" valign="top"><a id="a441cea1ebea409b2deb0ba387febc626" name="a441cea1ebea409b2deb0ba387febc626"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_laplace</b> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a441cea1ebea409b2deb0ba387febc626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Laplace distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:a441cea1ebea409b2deb0ba387febc626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b34801047d52afccf3b4120c3d2d74e" id="r_a2b34801047d52afccf3b4120c3d2d74e"><td class="memItemLeft" align="right" valign="top"><a id="a2b34801047d52afccf3b4120c3d2d74e" name="a2b34801047d52afccf3b4120c3d2d74e"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_pareto</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x_m, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a2b34801047d52afccf3b4120c3d2d74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Pareto distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:a2b34801047d52afccf3b4120c3d2d74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66a655f57ef0f6e436dfc03e800585b" id="r_ae66a655f57ef0f6e436dfc03e800585b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ae66a655f57ef0f6e436dfc03e800585b">rand_pareto</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:ae66a655f57ef0f6e436dfc03e800585b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_pareto(real, real, PRNG)  <br /></td></tr>
<tr class="separator:ae66a655f57ef0f6e436dfc03e800585b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a8fc915915b6eff35dbf94c74b13bd" id="r_a66a8fc915915b6eff35dbf94c74b13bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a66a8fc915915b6eff35dbf94c74b13bd">metropolis</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> pdf, <a class="el" href="structtheoretica_1_1pdf__sampler.html">pdf_sampler</a> &amp;g, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x0, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;rnd, unsigned int depth=<a class="el" href="namespacetheoretica.html#a1a92480c95125647eabea5f15aa26f83">STATISTICS_METROPOLIS_DEPTH</a>)</td></tr>
<tr class="memdesc:a66a8fc915915b6eff35dbf94c74b13bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metropolis algorithm for distribution sampling using a symmetric proposal distribution.  <br /></td></tr>
<tr class="separator:a66a8fc915915b6eff35dbf94c74b13bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91dfc5efe4fa412bd7ef46f142f7045" id="r_ac91dfc5efe4fa412bd7ef46f142f7045"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac91dfc5efe4fa412bd7ef46f142f7045">metropolis</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> pdf, <a class="el" href="structtheoretica_1_1pdf__sampler.html">pdf_sampler</a> &amp;g, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x0, unsigned int depth=<a class="el" href="namespacetheoretica.html#a1a92480c95125647eabea5f15aa26f83">STATISTICS_METROPOLIS_DEPTH</a>)</td></tr>
<tr class="memdesc:ac91dfc5efe4fa412bd7ef46f142f7045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metropolis algorithm for distribution sampling using a symmetric proposal distribution.  <br /></td></tr>
<tr class="separator:ac91dfc5efe4fa412bd7ef46f142f7045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f27a1f05cae98a0a9a55cce43c1e1b" id="r_a33f27a1f05cae98a0a9a55cce43c1e1b"><td class="memItemLeft" align="right" valign="top"><a id="a33f27a1f05cae98a0a9a55cce43c1e1b" name="a33f27a1f05cae98a0a9a55cce43c1e1b"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>max</b> (const <a class="el" href="classtheoretica_1_1histogram.html">histogram</a> &amp;h)</td></tr>
<tr class="memdesc:a33f27a1f05cae98a0a9a55cce43c1e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum value of the elements of a histogram. <br /></td></tr>
<tr class="separator:a33f27a1f05cae98a0a9a55cce43c1e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98aafc63fe4127e81acdfd9c69ace2ae" id="r_a98aafc63fe4127e81acdfd9c69ace2ae"><td class="memItemLeft" align="right" valign="top"><a id="a98aafc63fe4127e81acdfd9c69ace2ae" name="a98aafc63fe4127e81acdfd9c69ace2ae"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>min</b> (const <a class="el" href="classtheoretica_1_1histogram.html">histogram</a> &amp;h)</td></tr>
<tr class="memdesc:a98aafc63fe4127e81acdfd9c69ace2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the minimum value of the elements of a histogram. <br /></td></tr>
<tr class="separator:a98aafc63fe4127e81acdfd9c69ace2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59052e9762d5098c271e35288f6c136" id="r_ac59052e9762d5098c271e35288f6c136"><td class="memTemplParams" colspan="2"><a id="ac59052e9762d5098c271e35288f6c136" name="ac59052e9762d5098c271e35288f6c136"></a>
template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ac59052e9762d5098c271e35288f6c136"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>print</b> (const Type &amp;curr)</td></tr>
<tr class="memdesc:ac59052e9762d5098c271e35288f6c136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the given argument to standard output. <br /></td></tr>
<tr class="separator:ac59052e9762d5098c271e35288f6c136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f584b57ec832fc639211fc036e9c03" id="r_a42f584b57ec832fc639211fc036e9c03"><td class="memTemplParams" colspan="2"><a id="a42f584b57ec832fc639211fc036e9c03" name="a42f584b57ec832fc639211fc036e9c03"></a>
template&lt;typename Type , typename ... Args&gt; </td></tr>
<tr class="memitem:a42f584b57ec832fc639211fc036e9c03"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>print</b> (const Type &amp;curr, Args... args)</td></tr>
<tr class="memdesc:a42f584b57ec832fc639211fc036e9c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the given arguments to standard output separated by a space. <br /></td></tr>
<tr class="separator:a42f584b57ec832fc639211fc036e9c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119b1d711663d89f37de4078e6338598" id="r_a119b1d711663d89f37de4078e6338598"><td class="memTemplParams" colspan="2"><a id="a119b1d711663d89f37de4078e6338598" name="a119b1d711663d89f37de4078e6338598"></a>
template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a119b1d711663d89f37de4078e6338598"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fprint</b> (std::ostream &amp;out, const Type &amp;last)</td></tr>
<tr class="memdesc:a119b1d711663d89f37de4078e6338598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the given argument to a stream. <br /></td></tr>
<tr class="separator:a119b1d711663d89f37de4078e6338598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba669cb3e9488f1941813deb1d570f0" id="r_afba669cb3e9488f1941813deb1d570f0"><td class="memTemplParams" colspan="2"><a id="afba669cb3e9488f1941813deb1d570f0" name="afba669cb3e9488f1941813deb1d570f0"></a>
template&lt;typename Type , typename ... Args&gt; </td></tr>
<tr class="memitem:afba669cb3e9488f1941813deb1d570f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fprint</b> (std::ostream &amp;out, const Type &amp;curr, Args... args)</td></tr>
<tr class="memdesc:afba669cb3e9488f1941813deb1d570f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the given arguments to standard output separated by a space. <br /></td></tr>
<tr class="separator:afba669cb3e9488f1941813deb1d570f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cf6fb440a16f2884c2d1a69866eef8" id="r_a52cf6fb440a16f2884c2d1a69866eef8"><td class="memItemLeft" align="right" valign="top"><a id="a52cf6fb440a16f2884c2d1a69866eef8" name="a52cf6fb440a16f2884c2d1a69866eef8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>println</b> ()</td></tr>
<tr class="memdesc:a52cf6fb440a16f2884c2d1a69866eef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a newline to standard output. <br /></td></tr>
<tr class="separator:a52cf6fb440a16f2884c2d1a69866eef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c29f8db75bba82e599acb57a24d8997" id="r_a8c29f8db75bba82e599acb57a24d8997"><td class="memTemplParams" colspan="2"><a id="a8c29f8db75bba82e599acb57a24d8997" name="a8c29f8db75bba82e599acb57a24d8997"></a>
template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a8c29f8db75bba82e599acb57a24d8997"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>println</b> (const Type &amp;curr)</td></tr>
<tr class="memdesc:a8c29f8db75bba82e599acb57a24d8997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the given argument to standard output followed by a newline. <br /></td></tr>
<tr class="separator:a8c29f8db75bba82e599acb57a24d8997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4644c562747582e9802c5d9bf5cf99" id="r_a2f4644c562747582e9802c5d9bf5cf99"><td class="memTemplParams" colspan="2"><a id="a2f4644c562747582e9802c5d9bf5cf99" name="a2f4644c562747582e9802c5d9bf5cf99"></a>
template&lt;typename Type , typename ... Args&gt; </td></tr>
<tr class="memitem:a2f4644c562747582e9802c5d9bf5cf99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>println</b> (const Type &amp;curr, Args... args)</td></tr>
<tr class="memdesc:a2f4644c562747582e9802c5d9bf5cf99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the given arguments to standard output separated by a space and followed by a newline. <br /></td></tr>
<tr class="separator:a2f4644c562747582e9802c5d9bf5cf99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16a96e279d5cc7105ca1a5b17421100" id="r_aa16a96e279d5cc7105ca1a5b17421100"><td class="memTemplParams" colspan="2"><a id="aa16a96e279d5cc7105ca1a5b17421100" name="aa16a96e279d5cc7105ca1a5b17421100"></a>
template&lt;typename Type &gt; </td></tr>
<tr class="memitem:aa16a96e279d5cc7105ca1a5b17421100"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fprintln</b> (std::ostream &amp;out, const Type &amp;curr)</td></tr>
<tr class="memdesc:aa16a96e279d5cc7105ca1a5b17421100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the given argument to an output stream followed by a newline. <br /></td></tr>
<tr class="separator:aa16a96e279d5cc7105ca1a5b17421100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa685b521e53c3df54b3a3169ebc89c72" id="r_aa685b521e53c3df54b3a3169ebc89c72"><td class="memTemplParams" colspan="2"><a id="aa685b521e53c3df54b3a3169ebc89c72" name="aa685b521e53c3df54b3a3169ebc89c72"></a>
template&lt;typename Type , typename ... Args&gt; </td></tr>
<tr class="memitem:aa685b521e53c3df54b3a3169ebc89c72"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fprintln</b> (std::ostream &amp;out, const Type &amp;curr, Args... args)</td></tr>
<tr class="memdesc:aa685b521e53c3df54b3a3169ebc89c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the given arguments to an output stream separated by a space and followed by a newline. <br /></td></tr>
<tr class="separator:aa685b521e53c3df54b3a3169ebc89c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d24797ec2dd04cdc3f3288660bb5c9" id="r_ae3d24797ec2dd04cdc3f3288660bb5c9"><td class="memTemplParams" colspan="2"><a id="ae3d24797ec2dd04cdc3f3288660bb5c9" name="ae3d24797ec2dd04cdc3f3288660bb5c9"></a>
template&lt;typename Type  = real&gt; </td></tr>
<tr class="memitem:ae3d24797ec2dd04cdc3f3288660bb5c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>readln</b> (std::istream &amp;in, const std::string &amp;terminator, std::function&lt; Type(std::string)&gt; parse)</td></tr>
<tr class="memdesc:ae3d24797ec2dd04cdc3f3288660bb5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a data set of the given type from a stream, reading line by line until a line is equal to the terminator and parsing each line using the given function, returning the list of values. <br /></td></tr>
<tr class="separator:ae3d24797ec2dd04cdc3f3288660bb5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b96df3a9ba9e56299d44c363c1ca03" id="r_aa9b96df3a9ba9e56299d44c363c1ca03"><td class="memItemLeft" align="right" valign="top"><a id="aa9b96df3a9ba9e56299d44c363c1ca03" name="aa9b96df3a9ba9e56299d44c363c1ca03"></a>
<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>readln</b> (std::istream &amp;in, const std::string &amp;terminator=&quot;&quot;)</td></tr>
<tr class="memdesc:aa9b96df3a9ba9e56299d44c363c1ca03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a data set of the given type from a stream, reading line by line until a line is equal to the terminator and parsing each line as a real value, returning the list of values. <br /></td></tr>
<tr class="separator:aa9b96df3a9ba9e56299d44c363c1ca03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3eb50fb28bd74d4f9692c652beac4c" id="r_a0f3eb50fb28bd74d4f9692c652beac4c"><td class="memItemLeft" align="right" valign="top"><a id="a0f3eb50fb28bd74d4f9692c652beac4c" name="a0f3eb50fb28bd74d4f9692c652beac4c"></a>
<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>readln</b> (const std::string &amp;terminator=&quot;&quot;)</td></tr>
<tr class="memdesc:a0f3eb50fb28bd74d4f9692c652beac4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a data set of the given type from standard input, reading line by line until a line is equal to the terminator and parsing each line as a real value, returning the list of values. <br /></td></tr>
<tr class="separator:a0f3eb50fb28bd74d4f9692c652beac4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa34d8798921a9b3b78e885a455ff4211" id="r_aa34d8798921a9b3b78e885a455ff4211"><td class="memItemLeft" align="right" valign="top"><a id="aa34d8798921a9b3b78e885a455ff4211" name="aa34d8798921a9b3b78e885a455ff4211"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MACH_EPSILON</b> = std::numeric_limits&lt;<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&gt;::epsilon()</td></tr>
<tr class="memdesc:aa34d8798921a9b3b78e885a455ff4211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Machine epsilon for the real type. <br /></td></tr>
<tr class="separator:aa34d8798921a9b3b78e885a455ff4211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8245ba56baa7620ff9d0d9ccfbc53f" id="r_ace8245ba56baa7620ff9d0d9ccfbc53f"><td class="memItemLeft" align="right" valign="top"><a id="ace8245ba56baa7620ff9d0d9ccfbc53f" name="ace8245ba56baa7620ff9d0d9ccfbc53f"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PHI</b> = 1.6180339887498948482045868</td></tr>
<tr class="memdesc:ace8245ba56baa7620ff9d0d9ccfbc53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Phi (Golden Section) mathematical constant. <br /></td></tr>
<tr class="separator:ace8245ba56baa7620ff9d0d9ccfbc53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6de16e5ee81d340ff91dbadb99edde" id="r_a6a6de16e5ee81d340ff91dbadb99edde"><td class="memItemLeft" align="right" valign="top"><a id="a6a6de16e5ee81d340ff91dbadb99edde" name="a6a6de16e5ee81d340ff91dbadb99edde"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>INVPHI</b> = 0.6180339887498948482045868</td></tr>
<tr class="memdesc:a6a6de16e5ee81d340ff91dbadb99edde"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of the Golden Section mathematical constant. <br /></td></tr>
<tr class="separator:a6a6de16e5ee81d340ff91dbadb99edde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93349020a59cf77efcca5bb77c0e7f9" id="r_ae93349020a59cf77efcca5bb77c0e7f9"><td class="memItemLeft" align="right" valign="top"><a id="ae93349020a59cf77efcca5bb77c0e7f9" name="ae93349020a59cf77efcca5bb77c0e7f9"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PI</b> = 3.141592653589793238462643</td></tr>
<tr class="memdesc:ae93349020a59cf77efcca5bb77c0e7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Pi mathematical constant. <br /></td></tr>
<tr class="separator:ae93349020a59cf77efcca5bb77c0e7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b5dac597409564afdc448fbef23eae" id="r_a27b5dac597409564afdc448fbef23eae"><td class="memItemLeft" align="right" valign="top"><a id="a27b5dac597409564afdc448fbef23eae" name="a27b5dac597409564afdc448fbef23eae"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PI2</b> = 1.57079632679489655799898</td></tr>
<tr class="memdesc:a27b5dac597409564afdc448fbef23eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Half of Pi. <br /></td></tr>
<tr class="separator:a27b5dac597409564afdc448fbef23eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f9025deb90bc4fd64fb9260340e3f2" id="r_ac7f9025deb90bc4fd64fb9260340e3f2"><td class="memItemLeft" align="right" valign="top"><a id="ac7f9025deb90bc4fd64fb9260340e3f2" name="ac7f9025deb90bc4fd64fb9260340e3f2"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PI4</b> = <a class="el" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a> / 4.0</td></tr>
<tr class="memdesc:ac7f9025deb90bc4fd64fb9260340e3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A quarter of Pi. <br /></td></tr>
<tr class="separator:ac7f9025deb90bc4fd64fb9260340e3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974f2fd34520034645cb5c96487c6ed4" id="r_a974f2fd34520034645cb5c96487c6ed4"><td class="memItemLeft" align="right" valign="top"><a id="a974f2fd34520034645cb5c96487c6ed4" name="a974f2fd34520034645cb5c96487c6ed4"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PIDOUBLE</b> = <a class="el" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a> * 2</td></tr>
<tr class="memdesc:a974f2fd34520034645cb5c96487c6ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pi multiplied by 2. <br /></td></tr>
<tr class="separator:a974f2fd34520034645cb5c96487c6ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6a742ab030fe585063215a644f60df" id="r_aeb6a742ab030fe585063215a644f60df"><td class="memItemLeft" align="right" valign="top"><a id="aeb6a742ab030fe585063215a644f60df" name="aeb6a742ab030fe585063215a644f60df"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TAU</b> = <a class="el" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a> * 2</td></tr>
<tr class="memdesc:aeb6a742ab030fe585063215a644f60df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Tau mathematical constant (Pi times 2) <br /></td></tr>
<tr class="separator:aeb6a742ab030fe585063215a644f60df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6916417c8d2b817cfc48b8e2a1abb5" id="r_a4d6916417c8d2b817cfc48b8e2a1abb5"><td class="memItemLeft" align="right" valign="top"><a id="a4d6916417c8d2b817cfc48b8e2a1abb5" name="a4d6916417c8d2b817cfc48b8e2a1abb5"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>INVPI</b> = 1.0 / <a class="el" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a></td></tr>
<tr class="memdesc:a4d6916417c8d2b817cfc48b8e2a1abb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of Pi. <br /></td></tr>
<tr class="separator:a4d6916417c8d2b817cfc48b8e2a1abb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fb7f2271fa0e9cd55b47cf4641ca45" id="r_a37fb7f2271fa0e9cd55b47cf4641ca45"><td class="memItemLeft" align="right" valign="top"><a id="a37fb7f2271fa0e9cd55b47cf4641ca45" name="a37fb7f2271fa0e9cd55b47cf4641ca45"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SQRTPI</b> = 1.7724538509055159927</td></tr>
<tr class="memdesc:a37fb7f2271fa0e9cd55b47cf4641ca45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The square root of Pi. <br /></td></tr>
<tr class="separator:a37fb7f2271fa0e9cd55b47cf4641ca45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c0a5082e6b4428b15b7b02d16eafc7" id="r_aa3c0a5082e6b4428b15b7b02d16eafc7"><td class="memItemLeft" align="right" valign="top"><a id="aa3c0a5082e6b4428b15b7b02d16eafc7" name="aa3c0a5082e6b4428b15b7b02d16eafc7"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>E</b> = 2.718281828459045235360287</td></tr>
<tr class="memdesc:aa3c0a5082e6b4428b15b7b02d16eafc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Euler mathematical constant (e) <br /></td></tr>
<tr class="separator:aa3c0a5082e6b4428b15b7b02d16eafc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771e19568e0562e2fcccd740ec90dae4" id="r_a771e19568e0562e2fcccd740ec90dae4"><td class="memItemLeft" align="right" valign="top"><a id="a771e19568e0562e2fcccd740ec90dae4" name="a771e19568e0562e2fcccd740ec90dae4"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LOG2E</b> = 1.44269504088896338700465094</td></tr>
<tr class="memdesc:a771e19568e0562e2fcccd740ec90dae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary logarithm of e. <br /></td></tr>
<tr class="separator:a771e19568e0562e2fcccd740ec90dae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4145093692043269fa4c1ebef8b4890f" id="r_a4145093692043269fa4c1ebef8b4890f"><td class="memItemLeft" align="right" valign="top"><a id="a4145093692043269fa4c1ebef8b4890f" name="a4145093692043269fa4c1ebef8b4890f"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LOG210</b> = 3.32192809488736218170856773213</td></tr>
<tr class="memdesc:a4145093692043269fa4c1ebef8b4890f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary logarithm of 10. <br /></td></tr>
<tr class="separator:a4145093692043269fa4c1ebef8b4890f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612238583a4ec50cebd32b4694d5cb9a" id="r_a612238583a4ec50cebd32b4694d5cb9a"><td class="memItemLeft" align="right" valign="top"><a id="a612238583a4ec50cebd32b4694d5cb9a" name="a612238583a4ec50cebd32b4694d5cb9a"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LOG10E</b> = 0.434294481903</td></tr>
<tr class="memdesc:a612238583a4ec50cebd32b4694d5cb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base-10 logarithm of e. <br /></td></tr>
<tr class="separator:a612238583a4ec50cebd32b4694d5cb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7021b7b588c9ea63d46679aaa1f7c6c4" id="r_a7021b7b588c9ea63d46679aaa1f7c6c4"><td class="memItemLeft" align="right" valign="top"><a id="a7021b7b588c9ea63d46679aaa1f7c6c4" name="a7021b7b588c9ea63d46679aaa1f7c6c4"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LN2</b> = 0.69314718056</td></tr>
<tr class="memdesc:a7021b7b588c9ea63d46679aaa1f7c6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 2. <br /></td></tr>
<tr class="separator:a7021b7b588c9ea63d46679aaa1f7c6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc384f25a1d4c7c19169a5ce6c51710" id="r_a3bc384f25a1d4c7c19169a5ce6c51710"><td class="memItemLeft" align="right" valign="top"><a id="a3bc384f25a1d4c7c19169a5ce6c51710" name="a3bc384f25a1d4c7c19169a5ce6c51710"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LN10</b> = 2.30258509299</td></tr>
<tr class="memdesc:a3bc384f25a1d4c7c19169a5ce6c51710"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 10. <br /></td></tr>
<tr class="separator:a3bc384f25a1d4c7c19169a5ce6c51710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0afb9f871b425c7454c388eb41a3c19" id="r_ae0afb9f871b425c7454c388eb41a3c19"><td class="memItemLeft" align="right" valign="top"><a id="ae0afb9f871b425c7454c388eb41a3c19" name="ae0afb9f871b425c7454c388eb41a3c19"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DEG2RAD</b> = 0.017453292519943295474371680598</td></tr>
<tr class="memdesc:ae0afb9f871b425c7454c388eb41a3c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scalar conversion factor from degrees to radians. <br /></td></tr>
<tr class="separator:ae0afb9f871b425c7454c388eb41a3c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75cd5d78670f968bac3fbcfee6660b0" id="r_ae75cd5d78670f968bac3fbcfee6660b0"><td class="memItemLeft" align="right" valign="top"><a id="ae75cd5d78670f968bac3fbcfee6660b0" name="ae75cd5d78670f968bac3fbcfee6660b0"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RAD2DEG</b> = 57.2957795130823228646477218717</td></tr>
<tr class="memdesc:ae75cd5d78670f968bac3fbcfee6660b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scalar conversion factor from radians to degrees. <br /></td></tr>
<tr class="separator:ae75cd5d78670f968bac3fbcfee6660b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3be7f003670e91509c8f2fac523fab8" id="r_ae3be7f003670e91509c8f2fac523fab8"><td class="memItemLeft" align="right" valign="top"><a id="ae3be7f003670e91509c8f2fac523fab8" name="ae3be7f003670e91509c8f2fac523fab8"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SQRT2</b> = 1.4142135623730950488</td></tr>
<tr class="memdesc:ae3be7f003670e91509c8f2fac523fab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The square root of 2. <br /></td></tr>
<tr class="separator:ae3be7f003670e91509c8f2fac523fab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c1ffb22a0191558cafdaec71c3b81d" id="r_a42c1ffb22a0191558cafdaec71c3b81d"><td class="memItemLeft" align="right" valign="top"><a id="a42c1ffb22a0191558cafdaec71c3b81d" name="a42c1ffb22a0191558cafdaec71c3b81d"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>INVSQR2</b> = 0.7071067811865475</td></tr>
<tr class="memdesc:a42c1ffb22a0191558cafdaec71c3b81d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of the square root of 2. <br /></td></tr>
<tr class="separator:a42c1ffb22a0191558cafdaec71c3b81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3b1fe5337a2dcbdbbeb278cfd7c71d" id="r_adb3b1fe5337a2dcbdbbeb278cfd7c71d"><td class="memItemLeft" align="right" valign="top"><a id="adb3b1fe5337a2dcbdbbeb278cfd7c71d" name="adb3b1fe5337a2dcbdbbeb278cfd7c71d"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SQRT3</b> = 1.732050807568877</td></tr>
<tr class="memdesc:adb3b1fe5337a2dcbdbbeb278cfd7c71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The square root of 3. <br /></td></tr>
<tr class="separator:adb3b1fe5337a2dcbdbbeb278cfd7c71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431f69ddc5ada0242f703284a54726f9" id="r_a431f69ddc5ada0242f703284a54726f9"><td class="memItemLeft" align="right" valign="top"><a id="a431f69ddc5ada0242f703284a54726f9" name="a431f69ddc5ada0242f703284a54726f9"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ALGEBRA_ELEMENT_TOL</b> = <a class="el" href="constants_8h.html#ab9a6a14e083f6b0e58bcfb3d48de806d">THEORETICA_ALGEBRA_ELEMENT_TOL</a></td></tr>
<tr class="memdesc:a431f69ddc5ada0242f703284a54726f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tolerance for the elements of matrices. <br /></td></tr>
<tr class="separator:a431f69ddc5ada0242f703284a54726f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b9679476be607282a44a7f7f8b38c4" id="r_af8b9679476be607282a44a7f7f8b38c4"><td class="memItemLeft" align="right" valign="top"><a id="af8b9679476be607282a44a7f7f8b38c4" name="af8b9679476be607282a44a7f7f8b38c4"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ALGEBRA_EIGEN_TOL</b> = <a class="el" href="constants_8h.html#a3ee1447e26f6359f2f7508fba28581b9">THEORETICA_ALGEBRA_EIGEN_TOL</a></td></tr>
<tr class="memdesc:af8b9679476be607282a44a7f7f8b38c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tolerance for eigensolvers. <br /></td></tr>
<tr class="separator:af8b9679476be607282a44a7f7f8b38c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae203c518f0274c29d78167c457cac65b" id="r_ae203c518f0274c29d78167c457cac65b"><td class="memItemLeft" align="right" valign="top"><a id="ae203c518f0274c29d78167c457cac65b" name="ae203c518f0274c29d78167c457cac65b"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ALGEBRA_EIGEN_ITER</b> = <a class="el" href="constants_8h.html#a212f03078a80c3c28be85caad4b0487f">THEORETICA_ALGEBRA_EIGEN_ITER</a></td></tr>
<tr class="memdesc:ae203c518f0274c29d78167c457cac65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for eigensolvers. <br /></td></tr>
<tr class="separator:ae203c518f0274c29d78167c457cac65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ce237d68a1b674bc4d9d41211bdec5" id="r_ac2ce237d68a1b674bc4d9d41211bdec5"><td class="memItemLeft" align="right" valign="top"><a id="ac2ce237d68a1b674bc4d9d41211bdec5" name="ac2ce237d68a1b674bc4d9d41211bdec5"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>CORE_TAYLOR_ORDER</b> = <a class="el" href="constants_8h.html#a6a0a879f91cd0cf4a1a062f7b4ec809a">THEORETICA_CORE_TAYLOR_ORDER</a></td></tr>
<tr class="memdesc:ac2ce237d68a1b674bc4d9d41211bdec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order of Taylor series approximations. <br /></td></tr>
<tr class="separator:ac2ce237d68a1b674bc4d9d41211bdec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f59d0debe6a7cbdee72b28d4d53f16" id="r_a92f59d0debe6a7cbdee72b28d4d53f16"><td class="memItemLeft" align="right" valign="top"><a id="a92f59d0debe6a7cbdee72b28d4d53f16" name="a92f59d0debe6a7cbdee72b28d4d53f16"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>CALCULUS_INTEGRAL_STEPS</b> = <a class="el" href="constants_8h.html#ae641e7f5a02c5d5f1702f21d2620c736">THEORETICA_CALCULUS_INTEGRAL_STEPS</a></td></tr>
<tr class="memdesc:a92f59d0debe6a7cbdee72b28d4d53f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default number of steps for integral approximation. <br /></td></tr>
<tr class="separator:a92f59d0debe6a7cbdee72b28d4d53f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5effdda5848839bedf4a3aace62edc09" id="r_a5effdda5848839bedf4a3aace62edc09"><td class="memItemLeft" align="right" valign="top"><a id="a5effdda5848839bedf4a3aace62edc09" name="a5effdda5848839bedf4a3aace62edc09"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIMIZATION_TOL</b> = <a class="el" href="constants_8h.html#a031daaf86110b420def2d679b7ca4840">THEORETICA_OPTIMIZATION_TOL</a></td></tr>
<tr class="memdesc:a5effdda5848839bedf4a3aace62edc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximation tolerance for root finding. <br /></td></tr>
<tr class="separator:a5effdda5848839bedf4a3aace62edc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a935663988c6d893699a70ddfd7bdd" id="r_ab2a935663988c6d893699a70ddfd7bdd"><td class="memItemLeft" align="right" valign="top"><a id="ab2a935663988c6d893699a70ddfd7bdd" name="ab2a935663988c6d893699a70ddfd7bdd"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIMIZATION_BISECTION_ITER</b> = <a class="el" href="constants_8h.html#afb73c329d09fda7c329aa04dc7916a0c">THEORETICA_OPTIMIZATION_BISECTION_ITER</a></td></tr>
<tr class="memdesc:ab2a935663988c6d893699a70ddfd7bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the bisection algorithm. <br /></td></tr>
<tr class="separator:ab2a935663988c6d893699a70ddfd7bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4691051e74a09eb5e7285a6ee90e62" id="r_a7d4691051e74a09eb5e7285a6ee90e62"><td class="memItemLeft" align="right" valign="top"><a id="a7d4691051e74a09eb5e7285a6ee90e62" name="a7d4691051e74a09eb5e7285a6ee90e62"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIMIZATION_GOLDENSECTION_ITER</b> = <a class="el" href="constants_8h.html#a230ae213d64e3cb79e6ff601eec157dd">THEORETICA_OPTIMIZATION_GOLDENSECTION_ITER</a></td></tr>
<tr class="memdesc:a7d4691051e74a09eb5e7285a6ee90e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the golden section search algorithm. <br /></td></tr>
<tr class="separator:a7d4691051e74a09eb5e7285a6ee90e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae648762992e4710d0d7d2c9d01c0e66d" id="r_ae648762992e4710d0d7d2c9d01c0e66d"><td class="memItemLeft" align="right" valign="top"><a id="ae648762992e4710d0d7d2c9d01c0e66d" name="ae648762992e4710d0d7d2c9d01c0e66d"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIMIZATION_HALLEY_ITER</b> = <a class="el" href="constants_8h.html#a452bf502cfc93a36f365b6848756161b">THEORETICA_OPTIMIZATION_HALLEY_ITER</a></td></tr>
<tr class="memdesc:ae648762992e4710d0d7d2c9d01c0e66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for Halley's method. <br /></td></tr>
<tr class="separator:ae648762992e4710d0d7d2c9d01c0e66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83f2fa2a615e5fe6bf4acafa0549c3f" id="r_ac83f2fa2a615e5fe6bf4acafa0549c3f"><td class="memItemLeft" align="right" valign="top"><a id="ac83f2fa2a615e5fe6bf4acafa0549c3f" name="ac83f2fa2a615e5fe6bf4acafa0549c3f"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIMIZATION_NEWTON_ITER</b> = <a class="el" href="constants_8h.html#ade8c25dc126d6790d877dc5f9b5ae34f">THEORETICA_OPTIMIZATION_NEWTON_ITER</a></td></tr>
<tr class="memdesc:ac83f2fa2a615e5fe6bf4acafa0549c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the Newton-Raphson algorithm. <br /></td></tr>
<tr class="separator:ac83f2fa2a615e5fe6bf4acafa0549c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d71500ca8667ee14c30bc90605db9d" id="r_ab4d71500ca8667ee14c30bc90605db9d"><td class="memItemLeft" align="right" valign="top"><a id="ab4d71500ca8667ee14c30bc90605db9d" name="ab4d71500ca8667ee14c30bc90605db9d"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIMIZATION_STEFFENSEN_ITER</b> = <a class="el" href="constants_8h.html#a135a07c3f309f04137c003ded9b8cc16">THEORETICA_OPTIMIZATION_STEFFENSEN_ITER</a></td></tr>
<tr class="memdesc:ab4d71500ca8667ee14c30bc90605db9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the Steffensen algorithm. <br /></td></tr>
<tr class="separator:ab4d71500ca8667ee14c30bc90605db9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab147579539a73fa79bc4e13852eb53e9" id="r_ab147579539a73fa79bc4e13852eb53e9"><td class="memItemLeft" align="right" valign="top"><a id="ab147579539a73fa79bc4e13852eb53e9" name="ab147579539a73fa79bc4e13852eb53e9"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIMIZATION_CHEBYSHEV_ITER</b> = <a class="el" href="constants_8h.html#a372d072243b6c7c42db84d5debef1924">THEORETICA_OPTIMIZATION_CHEBYSHEV_ITER</a></td></tr>
<tr class="memdesc:ab147579539a73fa79bc4e13852eb53e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the Chebyshev algorithm. <br /></td></tr>
<tr class="separator:ab147579539a73fa79bc4e13852eb53e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8f4ef82e19e3dc1b382c03df5d15f9" id="r_a6a8f4ef82e19e3dc1b382c03df5d15f9"><td class="memItemLeft" align="right" valign="top"><a id="a6a8f4ef82e19e3dc1b382c03df5d15f9" name="a6a8f4ef82e19e3dc1b382c03df5d15f9"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIMIZATION_OSTROWSKI_ITER</b> = <a class="el" href="constants_8h.html#a93ff0c9b628b71df6c6adf5368e08cb0">THEORETICA_OPTIMIZATION_OSTROWSKI_ITER</a></td></tr>
<tr class="memdesc:a6a8f4ef82e19e3dc1b382c03df5d15f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the Ostrowski algorithm. <br /></td></tr>
<tr class="separator:a6a8f4ef82e19e3dc1b382c03df5d15f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e44603eb761970ec19fd740bda6c21" id="r_a10e44603eb761970ec19fd740bda6c21"><td class="memItemLeft" align="right" valign="top"><a id="a10e44603eb761970ec19fd740bda6c21" name="a10e44603eb761970ec19fd740bda6c21"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIMIZATION_JARRAT_ITER</b> = <a class="el" href="constants_8h.html#ab2c7b0e513db2fde54902664d75903df">THEORETICA_OPTIMIZATION_JARRAT_ITER</a></td></tr>
<tr class="memdesc:a10e44603eb761970ec19fd740bda6c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the Jarrat algorithm. <br /></td></tr>
<tr class="separator:a10e44603eb761970ec19fd740bda6c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a848b21acb5341a013db4baa629bde" id="r_a69a848b21acb5341a013db4baa629bde"><td class="memItemLeft" align="right" valign="top"><a id="a69a848b21acb5341a013db4baa629bde" name="a69a848b21acb5341a013db4baa629bde"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>STATISTICS_TRYANDCATCH_ITER</b> = <a class="el" href="constants_8h.html#a9df2dd49806e72c313d62bda3e61298e">THEORETICA_STATISTICS_TRYANDCATCH_ITER</a></td></tr>
<tr class="memdesc:a69a848b21acb5341a013db4baa629bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of failed iterations for the Try-and-Catch algorithm. <br /></td></tr>
<tr class="separator:a69a848b21acb5341a013db4baa629bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6041e735f753a4888a2eec14a79ebc09" id="r_a6041e735f753a4888a2eec14a79ebc09"><td class="memItemLeft" align="right" valign="top"><a id="a6041e735f753a4888a2eec14a79ebc09" name="a6041e735f753a4888a2eec14a79ebc09"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CALCULUS_DERIV_STEP</b> = <a class="el" href="constants_8h.html#adde8183503c7ffc5fe113ac52b1c4030">THEORETICA_CALCULUS_DERIV_STEP</a></td></tr>
<tr class="memdesc:a6041e735f753a4888a2eec14a79ebc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default variation for derivative approximation. <br /></td></tr>
<tr class="separator:a6041e735f753a4888a2eec14a79ebc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec69cb2482367d47a3d966c573b04fd6" id="r_aec69cb2482367d47a3d966c573b04fd6"><td class="memItemLeft" align="right" valign="top"><a id="aec69cb2482367d47a3d966c573b04fd6" name="aec69cb2482367d47a3d966c573b04fd6"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIMIZATION_MINGRAD_GAMMA</b> = <a class="el" href="constants_8h.html#ac97061c6c44e27f56c9bab55293ebe54">THEORETICA_OPTIMIZATION_MINGRAD_GAMMA</a></td></tr>
<tr class="memdesc:aec69cb2482367d47a3d966c573b04fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default step size for gradient descent minimization. <br /></td></tr>
<tr class="separator:aec69cb2482367d47a3d966c573b04fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a801e1df1e3281002e402a3f310bfb0" id="r_a5a801e1df1e3281002e402a3f310bfb0"><td class="memItemLeft" align="right" valign="top"><a id="a5a801e1df1e3281002e402a3f310bfb0" name="a5a801e1df1e3281002e402a3f310bfb0"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIMIZATION_MINGRAD_TOLERANCE</b> = <a class="el" href="constants_8h.html#a9a329c368d75aea3b80c881cfc8aa18f">THEORETICA_OPTIMIZATION_MINGRAD_TOLERANCE</a></td></tr>
<tr class="memdesc:a5a801e1df1e3281002e402a3f310bfb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default tolerance for gradient descent minimization. <br /></td></tr>
<tr class="separator:a5a801e1df1e3281002e402a3f310bfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e5dd300ac007074bcf54bfc9e59c6d" id="r_a86e5dd300ac007074bcf54bfc9e59c6d"><td class="memItemLeft" align="right" valign="top"><a id="a86e5dd300ac007074bcf54bfc9e59c6d" name="a86e5dd300ac007074bcf54bfc9e59c6d"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIMIZATION_MINGRAD_ITER</b> = <a class="el" href="constants_8h.html#a0e35dc3b59e56b8c7262a68a0aa5ab4e">THEORETICA_OPTIMIZATION_MINGRAD_ITER</a></td></tr>
<tr class="memdesc:a86e5dd300ac007074bcf54bfc9e59c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for gradient descent minimization. <br /></td></tr>
<tr class="separator:a86e5dd300ac007074bcf54bfc9e59c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab0dc413ccb1d809e2269de05dbf48d" id="r_a2ab0dc413ccb1d809e2269de05dbf48d"><td class="memItemLeft" align="right" valign="top"><a id="a2ab0dc413ccb1d809e2269de05dbf48d" name="a2ab0dc413ccb1d809e2269de05dbf48d"></a>
constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>STATISTICS_RAND_PREC</b> = <a class="el" href="constants_8h.html#a3c3d063c9fcfc61332eab8c32b49a0bb">THEORETICA_STATISTICS_RAND_PREC</a></td></tr>
<tr class="memdesc:a2ab0dc413ccb1d809e2269de05dbf48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default precision for random number generation using <a class="el" href="namespacetheoretica.html#a579b4ccc4078b67b7ec795b744e436d5" title="Generate a pseudorandom real number in [a, b] using a preexisting generator.">rand_uniform()</a> <br /></td></tr>
<tr class="separator:a2ab0dc413ccb1d809e2269de05dbf48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a92480c95125647eabea5f15aa26f83" id="r_a1a92480c95125647eabea5f15aa26f83"><td class="memItemLeft" align="right" valign="top"><a id="a1a92480c95125647eabea5f15aa26f83" name="a1a92480c95125647eabea5f15aa26f83"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>STATISTICS_METROPOLIS_DEPTH</b> = <a class="el" href="constants_8h.html#a125c2adae715691abe202c3cb3423c84">THEORETICA_STATISTICS_METROPOLIS_DEPTH</a></td></tr>
<tr class="memdesc:a1a92480c95125647eabea5f15aa26f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default depth of the Metropolis algorithm. <br /></td></tr>
<tr class="separator:a1a92480c95125647eabea5f15aa26f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main namespace of the library which contains all functions and objects. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a99f8bd44356f8184466e4cc0d6986fe5" name="a99f8bd44356f8184466e4cc0d6986fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f8bd44356f8184466e4cc0d6986fe5">&#9670;&#160;</a></span>pseudorandom_function</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetheoretica.html#a99f8bd44356f8184466e4cc0d6986fe5">theoretica::pseudorandom_function</a> = typedef uint64_t (*)(uint64_t, std::vector&lt;uint64_t&gt;&amp;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer which wraps a pseudorandom generator, taking as input the previous generated value (or seed) and the current state of the algorithm. </p>
<p>Such functions may be passed to the <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> class to simplify the usage of generators. </p>

</div>
</div>
<a id="a049966946220f1f7e5eae57293703066" name="a049966946220f1f7e5eae57293703066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049966946220f1f7e5eae57293703066">&#9670;&#160;</a></span>real</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">theoretica::real</a> = typedef double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A real number, defined as a floating point type. </p>
<p>The underlying type is determined by the defined macros: By default, <code>real</code> will be defined as the <code>double</code> type. If <code>THEORETICA_FLOAT_PREC</code> is defined, <code>real</code> will be defined as a <code>float</code>, if <code>THEORETICA_LONG_DOUBLE_PREC</code> is defined, <code>real</code> will be defined as a <code>long double</code> </p><dl class="section note"><dt>Note</dt><dd>The <code>THEORETICA_ARBITRARY_PREC</code> option is currently unsupported </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adefc7e5553fca6b62313bb2a3037e49b" name="adefc7e5553fca6b62313bb2a3037e49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adefc7e5553fca6b62313bb2a3037e49b">&#9670;&#160;</a></span>abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the modulus of a complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5177ff64d981840e149d1e282f1b27e" name="aa5177ff64d981840e149d1e282f1b27e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5177ff64d981840e149d1e282f1b27e">&#9670;&#160;</a></span>abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the absolute value of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute value of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fabs</code> instruction will be used. </p>

</div>
</div>
<a id="ab0086a4838097cdade9da3abb896ac14" name="ab0086a4838097cdade9da3abb896ac14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0086a4838097cdade9da3abb896ac14">&#9670;&#160;</a></span>acos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::acos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex arccosine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f2d69e3a3387958a27d4a03ed478a99" name="a7f2d69e3a3387958a27d4a03ed478a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2d69e3a3387958a27d4a03ed478a99">&#9670;&#160;</a></span>acos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::acos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arccosine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arccosine of x</dd></dl>
<p>Domain: [-1, 1]. The identities \(acos(x) = atan(\frac{sqrt{1 - x^2}}{x})\) and \(acos(x) = atan(\frac{\sqrt{1 - x^2}}{x}) + \pi\) are used. </p>

</div>
</div>
<a id="ac0a76a59d0419eb65ee9d89e7bd6c1db" name="ac0a76a59d0419eb65ee9d89e7bd6c1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a76a59d0419eb65ee9d89e7bd6c1db">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector , typename Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector &amp; theoretica::apply </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to a set of values element-wise. </p>
<dl class="section note"><dt>Note</dt><dd>Unlike functions in the parallel namespace, this routine is not parallelized.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to apply </td></tr>
    <tr><td class="paramname">X</td><td>The vector to modify the elements of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the modified vector </dd></dl>

</div>
</div>
<a id="af336feea10e3a8928f2d2723578d3704" name="af336feea10e3a8928f2d2723578d3704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af336feea10e3a8928f2d2723578d3704">&#9670;&#160;</a></span>asin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::asin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex arcsine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79b06e5bf997c4447c10f2fa96649347" name="a79b06e5bf997c4447c10f2fa96649347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b06e5bf997c4447c10f2fa96649347">&#9670;&#160;</a></span>asin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::asin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arcsine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arcsine of x</dd></dl>
<p>Domain: [-1, 1]. The identity \(asin(x) = atan(\frac{x}{\sqrt{1 - x^2}})\) is used. </p>

</div>
</div>
<a id="abb7f72fc6086b22ac864727ac0ee064b" name="abb7f72fc6086b22ac864727ac0ee064b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7f72fc6086b22ac864727ac0ee064b">&#9670;&#160;</a></span>atan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::atan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex arctangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a426b70abe4783e75806e1ae8c9e9e2bd" name="a426b70abe4783e75806e1ae8c9e9e2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426b70abe4783e75806e1ae8c9e9e2bd">&#9670;&#160;</a></span>atan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::atan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arctangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arctangent of x</dd></dl>
<p>A degree 9 interpolating polynomial through Chebyshev nodes is used to approximate \(atan(x)\). Domain reduction to [-1, 1] is performed. </p>

</div>
</div>
<a id="a6ae6ab14a39d6132b6858934dadaaf3e" name="a6ae6ab14a39d6132b6858934dadaaf3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae6ab14a39d6132b6858934dadaaf3e">&#9670;&#160;</a></span>atan2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::atan2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the 2 argument arctangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>The y coordinate in Cartesian space </td></tr>
    <tr><td class="paramname">x</td><td>The x coordinate in Cartesian space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The counterclockwise angle between the vector described by x and y and the x axis.</dd></dl>
<p>Computed using identities on atan(x). </p>

</div>
</div>
<a id="ac9bfc7cddd25fd7dd7eb774e9ea1bef4" name="ac9bfc7cddd25fd7dd7eb774e9ea1bef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9bfc7cddd25fd7dd7eb774e9ea1bef4">&#9670;&#160;</a></span>bezier()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::bezier </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic Bezier curve in N dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The control points </td></tr>
    <tr><td class="paramname">t</td><td>The curve parameter between 0 and 1</td></tr>
  </table>
  </dd>
</dl>
<p>The generic Bezier curve is computed by successive linear interpolations. For cubic and quadratic Bezier curves the related functions should be preferred. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#afb40a700a725235c37a4ceeb1e09c7f6" title="Quadratic Bezier curve.">quadratic_bezier</a> </dd>
<dd>
<a class="el" href="namespacetheoretica.html#acc018b01eb3df4f133863741a5ed343b" title="Cubic Bezier curve.">cubic_bezier</a> </dd></dl>

</div>
</div>
<a id="a129bf1f1085a76b92999e0faeb30e831" name="a129bf1f1085a76b92999e0faeb30e831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129bf1f1085a76b92999e0faeb30e831">&#9670;&#160;</a></span>binomial_coeff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType  = unsigned long long int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> IntType theoretica::binomial_coeff </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the binomial coefficient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A natural number </td></tr>
    <tr><td class="paramname">m</td><td>A natural number smaller than n </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binomial coefficient computed on (n, m) as \(\frac{n!}{m!(n - m)!}\) </dd></dl>

</div>
</div>
<a id="a4024f1ecd6e937492928965a417c2bc9" name="a4024f1ecd6e937492928965a417c2bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4024f1ecd6e937492928965a417c2bc9">&#9670;&#160;</a></span>bit_rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnsignedIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> UnsignedIntType theoretica::bit_rotate </td>
          <td>(</td>
          <td class="paramtype">UnsignedIntType&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit rotation of unsigned integer types using shifts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The unsigned integer to rotate the bits of </td></tr>
    <tr><td class="paramname">i</td><td>The index of the rotated bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unsigned integer with the given bits rotated </dd></dl>

</div>
</div>
<a id="a61c3b797f94ec5bc22b4c22f85417c93" name="a61c3b797f94ec5bc22b4c22f85417c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c3b797f94ec5bc22b4c22f85417c93">&#9670;&#160;</a></span>cbrt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cbrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cubic root of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cubic root of x</dd></dl>
<p>Domain: [-inf, +inf] <br  />
The Newton-Raphson algorithm, optimized for the cubic root and limited by the <code>THEORETICA_OPTIMIZATION_NEWTON_ITER</code> macro constant, is used. Domain reduction to [0, 1] is applied to ensure convergence of the algorithm. </p>

</div>
</div>
<a id="a085e34f437a529b59778090e0cb122e5" name="a085e34f437a529b59778090e0cb122e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085e34f437a529b59778090e0cb122e5">&#9670;&#160;</a></span>chebyshev1_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::chebyshev1_polynomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the nth Chebyshev polynomial of the first kind. </p>
<dl class="section note"><dt>Note</dt><dd>The result is not normalized </dd></dl>

</div>
</div>
<a id="a3450aa75a960635e9f33a6dabb22752b" name="a3450aa75a960635e9f33a6dabb22752b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3450aa75a960635e9f33a6dabb22752b">&#9670;&#160;</a></span>chebyshev2_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::chebyshev2_polynomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the nth Chebyshev polynomial of the second kind. </p>
<dl class="section note"><dt>Note</dt><dd>The result is not normalized </dd></dl>

</div>
</div>
<a id="a25e8ede5b63e3e928ba06999468f33ef" name="a25e8ede5b63e3e928ba06999468f33ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e8ede5b63e3e928ba06999468f33ef">&#9670;&#160;</a></span>chebyshev_nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = std::vector&lt;real&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorType theoretica::chebyshev_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the n Chebyshev nodes on a given interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The lower bound of the interval </td></tr>
    <tr><td class="paramname">b</td><td>The upper bound of the interval </td></tr>
    <tr><td class="paramname">n</td><td>The number of points to evaluate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1a4ad4c5446986fe2d255a03be337a1" name="af1a4ad4c5446986fe2d255a03be337a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a4ad4c5446986fe2d255a03be337a1">&#9670;&#160;</a></span>clamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::clamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clamp x between a and b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The real number to clamp </td></tr>
    <tr><td class="paramname">a</td><td>The lower bound </td></tr>
    <tr><td class="paramname">b</td><td>The upper bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns x if x is between a and b, a if x is less than a, b if x is bigger than b </dd></dl>

</div>
</div>
<a id="acdf4d125306e3fffc7287aa42f9005a1" name="acdf4d125306e3fffc7287aa42f9005a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf4d125306e3fffc7287aa42f9005a1">&#9670;&#160;</a></span>clamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T theoretica::clamp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clamp a value between two other values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to clamp </td></tr>
    <tr><td class="paramname">a</td><td>The lower bound </td></tr>
    <tr><td class="paramname">b</td><td>The upper bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns x if x is between a and b, a if x is less than a, b if x is bigger than b</dd></dl>
<p>The templated T type must have comparison operators. </p>

</div>
</div>
<a id="a7d4160ef942a7f710c85250f69e65def" name="a7d4160ef942a7f710c85250f69e65def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4160ef942a7f710c85250f69e65def">&#9670;&#160;</a></span>conjugate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::conjugate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the conjugate of a complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a133da02105ffbd23a2f6f07c03b219f6" name="a133da02105ffbd23a2f6f07c03b219f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133da02105ffbd23a2f6f07c03b219f6">&#9670;&#160;</a></span>cos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::cos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex cosine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af684d7159e22012dc5229c31eb66fceb" name="af684d7159e22012dc5229c31eb66fceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af684d7159e22012dc5229c31eb66fceb">&#9670;&#160;</a></span>cos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cosine of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cosine of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fcos</code> instruction will be used. </p>

</div>
</div>
<a id="a12fc03cbb1de8180e51183bb82c0bb28" name="a12fc03cbb1de8180e51183bb82c0bb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fc03cbb1de8180e51183bb82c0bb28">&#9670;&#160;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cosh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hyperbolic cosine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic cosine of x</dd></dl>
<p>\(cosh = \frac{e^x + e^{-x}}{2}\) </p>

</div>
</div>
<a id="aec6f43e74456bea35fb757f17db47da8" name="aec6f43e74456bea35fb757f17db47da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6f43e74456bea35fb757f17db47da8">&#9670;&#160;</a></span>cot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cotangent of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cotangent of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fsincos</code> instruction will be used if supported by the compiler. </p>

</div>
</div>
<a id="a96f957ad9b2354268f56ab1ca3843080" name="a96f957ad9b2354268f56ab1ca3843080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f957ad9b2354268f56ab1ca3843080">&#9670;&#160;</a></span>coth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::coth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hyperbolic cotangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic cotangent of x </dd></dl>

</div>
</div>
<a id="a9cc94802c6760bba16d0eaf5795dced7" name="a9cc94802c6760bba16d0eaf5795dced7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc94802c6760bba16d0eaf5795dced7">&#9670;&#160;</a></span>cube() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cube of a complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bfa8d12242c241b6f56cebc9cdc60ed" name="a6bfa8d12242c241b6f56cebc9cdc60ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfa8d12242c241b6f56cebc9cdc60ed">&#9670;&#160;</a></span>cube() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cube of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cube of x</dd></dl>
<p>Domain: [-inf, +inf] </p>

</div>
</div>
<a id="ae7bf96b1e850f0901d249adbfea8f382" name="ae7bf96b1e850f0901d249adbfea8f382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bf96b1e850f0901d249adbfea8f382">&#9670;&#160;</a></span>cubic_splines() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dataset1 , typename Dataset2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structtheoretica_1_1spline__node.html">spline_node</a> &gt; theoretica::cubic_splines </td>
          <td>(</td>
          <td class="paramtype">const Dataset1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Dataset2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cubic splines interpolation of the sets of X and Y data points. </p>
<p>The X values should be strictly increasing. </p>

</div>
</div>
<a id="a99316012fec5500c779ddf8d4114b643" name="a99316012fec5500c779ddf8d4114b643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99316012fec5500c779ddf8d4114b643">&#9670;&#160;</a></span>cubic_splines() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataPoints  = std::vector&lt;vec2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structtheoretica_1_1spline__node.html">spline_node</a> &gt; theoretica::cubic_splines </td>
          <td>(</td>
          <td class="paramtype">DataPoints&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cubic splines interpolation of a set of data points. </p>
<p>The X values should be strictly increasing. </p>

</div>
</div>
<a id="a840b8c27d0a8398f33858b1f8d55732d" name="a840b8c27d0a8398f33858b1f8d55732d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840b8c27d0a8398f33858b1f8d55732d">&#9670;&#160;</a></span>degrees()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::degrees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>radians</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert radians to degrees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radians</td><td>An angle in radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted angle in degrees</dd></dl>
<p>The <code>RAD2DEG</code> scalar factor is used. </p>

</div>
</div>
<a id="ae231f0ed7d65026e95d86dad20498113" name="ae231f0ed7d65026e95d86dad20498113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae231f0ed7d65026e95d86dad20498113">&#9670;&#160;</a></span>deriv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Field  = real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; Field &gt; theoretica::deriv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the exact derivative of a polynomial function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The polynomial to differentiate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derivative polynomial </dd></dl>

</div>
</div>
<a id="a6e6a820d42c7b057384b9eb88fc312f3" name="a6e6a820d42c7b057384b9eb88fc312f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6a820d42c7b057384b9eb88fc312f3">&#9670;&#160;</a></span>deriv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the exact derivative of a polynomial function at the given point. </p>
<p>In-place calculation with Horner's evaluation scheme is used, with linear complexity in the coefficients \(O(n)\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The polynomial to differentiate </td></tr>
    <tr><td class="paramname">x</td><td>The point to compute the derivative at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derivative of the polynomial at the given point </dd></dl>

</div>
</div>
<a id="a69edeaa0ec50e54eeaf1473f83582a68" name="a69edeaa0ec50e54eeaf1473f83582a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69edeaa0ec50e54eeaf1473f83582a68">&#9670;&#160;</a></span>deriv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction  = std::function&lt;real(real)&gt;, enable_real_func&lt; RealFunction &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="namespacetheoretica.html#a6041e735f753a4888a2eec14a79ebc09">CALCULUS_DERIV_STEP</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the first derivative of a real function using the best available algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">h</td><td>The step size to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the derivative </dd></dl>

</div>
</div>
<a id="ac470f622545e9f044b6099d96222532f" name="ac470f622545e9f044b6099d96222532f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac470f622545e9f044b6099d96222532f">&#9670;&#160;</a></span>deriv2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction  = std::function&lt;real(real)&gt;, enable_real_func&lt; RealFunction &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv2 </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="namespacetheoretica.html#a6041e735f753a4888a2eec14a79ebc09">CALCULUS_DERIV_STEP</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the second derivative of a real function using the best available algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the second derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">h</td><td>The step size to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the second derivative </dd></dl>

</div>
</div>
<a id="acef217e4310f467330d0a18986f70d84" name="acef217e4310f467330d0a18986f70d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef217e4310f467330d0a18986f70d84">&#9670;&#160;</a></span>deriv_backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction  = std::function&lt;real(real)&gt;, enable_real_func&lt; RealFunction &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv_backward </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="namespacetheoretica.html#a6041e735f753a4888a2eec14a79ebc09">CALCULUS_DERIV_STEP</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the first derivative of a real function using the backward method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">h</td><td>The step size to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the derivative </dd></dl>

</div>
</div>
<a id="aa6f7dff89fe2dd3e8124c10ff19bd0ed" name="aa6f7dff89fe2dd3e8124c10ff19bd0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f7dff89fe2dd3e8124c10ff19bd0ed">&#9670;&#160;</a></span>deriv_central()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction  = std::function&lt;real(real)&gt;, enable_real_func&lt; RealFunction &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv_central </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="namespacetheoretica.html#a6041e735f753a4888a2eec14a79ebc09">CALCULUS_DERIV_STEP</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the first derivative of a real function using the central method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">h</td><td>The step size to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the derivative </dd></dl>

</div>
</div>
<a id="a383ecbb074d735f5b5e8a2f45e5eb291" name="a383ecbb074d735f5b5e8a2f45e5eb291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383ecbb074d735f5b5e8a2f45e5eb291">&#9670;&#160;</a></span>deriv_forward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction  = std::function&lt;real(real)&gt;, enable_real_func&lt; RealFunction &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv_forward </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="namespacetheoretica.html#a6041e735f753a4888a2eec14a79ebc09">CALCULUS_DERIV_STEP</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the first derivative of a real function using the forward method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">h</td><td>The step size to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the derivative </dd></dl>

</div>
</div>
<a id="a989e6f0a6fd6fe05664b6d5de8aaaaf5" name="a989e6f0a6fd6fe05664b6d5de8aaaaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989e6f0a6fd6fe05664b6d5de8aaaaf5">&#9670;&#160;</a></span>deriv_ridders()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction  = std::function&lt;real(real)&gt;, enable_real_func&lt; RealFunction &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv_ridders </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code>0.01</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>degree</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the first derivative of a real function using Ridder's method of arbitrary degree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">degree</td><td>The degree of the algorithm </td></tr>
    <tr><td class="paramname">h</td><td>The step size to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the derivative </dd></dl>

</div>
</div>
<a id="a9c49b5e16e7366e0299972a87e3eb641" name="a9c49b5e16e7366e0299972a87e3eb641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c49b5e16e7366e0299972a87e3eb641">&#9670;&#160;</a></span>deriv_ridders2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction  = std::function&lt;real(real)&gt;, enable_real_func&lt; RealFunction &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv_ridders2 </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="namespacetheoretica.html#a6041e735f753a4888a2eec14a79ebc09">CALCULUS_DERIV_STEP</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the first derivative of a real function using Ridder's method of second degree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">h</td><td>The step size to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the derivative </dd></dl>

</div>
</div>
<a id="a6500750eaa5ea09bf1a2fa8ca1c1d430" name="a6500750eaa5ea09bf1a2fa8ca1c1d430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6500750eaa5ea09bf1a2fa8ca1c1d430">&#9670;&#160;</a></span>exp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex exponential. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac61f8810fcedeaa35f54c834e934828e" name="ac61f8810fcedeaa35f54c834e934828e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61f8810fcedeaa35f54c834e934828e">&#9670;&#160;</a></span>exp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the real exponential. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exponential of x</dd></dl>
<p>The exponential is computed as \(e^{floor(x)} \cdot e^{fract(x)}\), where \(e^{floor(x)} = pow(e, floor(x))\) and \(e^{fract(x)}\) is approximated using Taylor series on [0, 0.25] </p>

</div>
</div>
<a id="ae57235e0b29cc687c5084e5f0aa2515c" name="ae57235e0b29cc687c5084e5f0aa2515c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57235e0b29cc687c5084e5f0aa2515c">&#9670;&#160;</a></span>expm1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::expm1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the exponential of x minus 1 more accurately for really small x. </p>
<p>For |x| &gt; 0.001, <a class="el" href="namespacetheoretica.html#a3def790003197bb019f5933b4db45c44" title="Compute the exponential of a second order dual number.">th::exp</a> is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exponential of x minus 1. </dd></dl>

</div>
</div>
<a id="a587130155867c6e054e3668a0aed581e" name="a587130155867c6e054e3668a0aed581e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587130155867c6e054e3668a0aed581e">&#9670;&#160;</a></span>find_root_intervals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction , typename Vector  = vec2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Vector &gt; theoretica::find_root_intervals </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>steps</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find candidate intervals for root finding by evaluating a function at equidistant points inside an interval [a, b] and checking its sign. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function of real variable </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of the interval </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of the interval </td></tr>
    <tr><td class="paramname">steps</td><td>The number of sub-intervals to check (defaults to 10) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afad5c92586d6a0f841bfcd3759eff317" name="afad5c92586d6a0f841bfcd3759eff317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad5c92586d6a0f841bfcd3759eff317">&#9670;&#160;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> int theoretica::floor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the floor of x Computes the maximum integer number that is smaller than x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The floor of x</dd></dl>
<p>e.g. floor(1.6) = 1 e.g. floor(-0.3) = -1 </p>

</div>
</div>
<a id="a85d079c3d95f2bc80c4619d13ff7263a" name="a85d079c3d95f2bc80c4619d13ff7263a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d079c3d95f2bc80c4619d13ff7263a">&#9670;&#160;</a></span>fract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::fract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the fractional part of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fractional part of x</dd></dl>
<p>e.g. fract(2.5) = 0.5 e.g. fract(-0.2) = 0.2 </p>

</div>
</div>
<a id="a5adf7d2f3094d32dd9d4059ec86247db" name="a5adf7d2f3094d32dd9d4059ec86247db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adf7d2f3094d32dd9d4059ec86247db">&#9670;&#160;</a></span>gen_polyn_recurr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::gen_polyn_recurr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td>
          <td class="paramname"><em>P0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#adcb53498374f76292a3da8bb8c785341">polyn_recurr_formula</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a polynomial basis using a recursion formula. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P0</td><td>First polynomial of the sequence </td></tr>
    <tr><td class="paramname">P1</td><td>Second polynomial of the sequence </td></tr>
    <tr><td class="paramname">f</td><td>Recursion formula </td></tr>
    <tr><td class="paramname">n</td><td>Degree of the final polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting polynomial </dd></dl>

</div>
</div>
<a id="a024554cae44fb42700e8f68d235f0f15" name="a024554cae44fb42700e8f68d235f0f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024554cae44fb42700e8f68d235f0f15">&#9670;&#160;</a></span>heaviside()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::heaviside </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the heaviside function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The heaviside function for x, equal to 1 if x &gt; 0, 0 if x &lt; 0 and 1/2 if x = 0 </dd></dl>

</div>
</div>
<a id="afd97a0d6d99915f065567958760164f4" name="afd97a0d6d99915f065567958760164f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd97a0d6d99915f065567958760164f4">&#9670;&#160;</a></span>hermite_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::hermite_polynomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the nth Hermite polynomial. </p>
<dl class="section note"><dt>Note</dt><dd>The result is not normalized </dd></dl>

</div>
</div>
<a id="a04806d2927b08fe51b37c5a1c517de35" name="a04806d2927b08fe51b37c5a1c517de35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04806d2927b08fe51b37c5a1c517de35">&#9670;&#160;</a></span>hermite_weights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::hermite_weights </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>roots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hermite weights for Gauss-Hermite quadrature of n-th order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roots</td><td>The n roots of the n-th Hermite polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Hermite weights for Gauss-Hermite quadrature </dd></dl>

</div>
</div>
<a id="ad830de3729f8f2bea38d60ef706cf968" name="ad830de3729f8f2bea38d60ef706cf968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad830de3729f8f2bea38d60ef706cf968">&#9670;&#160;</a></span>icbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnsignedIntType  = uint64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnsignedIntType theoretica::icbrt </td>
          <td>(</td>
          <td class="paramtype">UnsignedIntType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the integer cubic root of a positive integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A positive integer number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rounded down cubic root of n A binary search algorithm is used. </dd></dl>

</div>
</div>
<a id="a3901b8b9a442e4b71368650c2ce1ee31" name="a3901b8b9a442e4b71368650c2ce1ee31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3901b8b9a442e4b71368650c2ce1ee31">&#9670;&#160;</a></span>identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::identity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complex identity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50cd5107369678c27b30dbae079283c5" name="a50cd5107369678c27b30dbae079283c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50cd5107369678c27b30dbae079283c5">&#9670;&#160;</a></span>ilog2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnsignedIntType  = uint64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnsignedIntType theoretica::ilog2 </td>
          <td>(</td>
          <td class="paramtype">UnsignedIntType&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the integer logarithm of x. </p>
<p>Defined as the biggest n so that 2^n is smaller than x. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An integer value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integer logarithm of x </dd></dl>

</div>
</div>
<a id="aaf3ddf8709dd260dcaee46719dc7f648" name="aaf3ddf8709dd260dcaee46719dc7f648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3ddf8709dd260dcaee46719dc7f648">&#9670;&#160;</a></span>integral() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Field  = real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; Field &gt; theoretica::integral </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the indefinite integral of a polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The polynomial to integrate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The indefinite polynomial integral, with zero constant term. </dd></dl>

</div>
</div>
<a id="a9f0e87bfeb1a4e484de143465a263465" name="a9f0e87bfeb1a4e484de143465a263465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0e87bfeb1a4e484de143465a263465">&#9670;&#160;</a></span>integral() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the definite integral of a polynomial over an interval. </p>
<p>In-place calculation with Horner's evaluation scheme is used, with linear complexity in the coefficients \(O(n)\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The polynomial to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The definite polynomial integral </dd></dl>

</div>
</div>
<a id="ae095e7eee4b03eddc3b035b2bde14a7e" name="ae095e7eee4b03eddc3b035b2bde14a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae095e7eee4b03eddc3b035b2bde14a7e">&#9670;&#160;</a></span>integral() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the best available algorithm to approximate the definite integral of a real function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the integral of f </dd></dl>

</div>
</div>
<a id="aa29abada0134095a6d9a120c241ce461" name="aa29abada0134095a6d9a120c241ce461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29abada0134095a6d9a120c241ce461">&#9670;&#160;</a></span>integral() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the best available algorithm to approximate the definite integral of a real function to a given tolerance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">tol</td><td>Tolerance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the integral of f </dd></dl>

</div>
</div>
<a id="a301de055cdb4b0a9888d68dc8382b5cf" name="a301de055cdb4b0a9888d68dc8382b5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301de055cdb4b0a9888d68dc8382b5cf">&#9670;&#160;</a></span>integral_crude() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_crude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, S &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a1f21bd68ba64b172c29d9fce15c8712d">vec2</a>, S &gt;&#160;</td>
          <td class="paramname"><em>extremes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Crude Monte Carlo integration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">extremes</td><td>A vector of the extremes of integration </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07652c066aaca0e41b16a21554bc5a28" name="a07652c066aaca0e41b16a21554bc5a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07652c066aaca0e41b16a21554bc5a28">&#9670;&#160;</a></span>integral_crude() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_crude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Crude Monte Carlo integration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96bf598b39c148bddb7ceebd7aa9b446" name="a96bf598b39c148bddb7ceebd7aa9b446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bf598b39c148bddb7ceebd7aa9b446">&#9670;&#160;</a></span>integral_gauss() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_gauss </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gaussian quadrature using the given points and weights. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">x</td><td>The points of evaluation </td></tr>
    <tr><td class="paramname">w</td><td>The weights of the linear combination </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa72ca0802148fca511bdb53d2cf958a8" name="aa72ca0802148fca511bdb53d2cf958a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72ca0802148fca511bdb53d2cf958a8">&#9670;&#160;</a></span>integral_gauss() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_gauss </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gaussian quadrature using the given points and weights. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">x</td><td>The points of evaluation </td></tr>
    <tr><td class="paramname">w</td><td>The weights of the linear combination </td></tr>
    <tr><td class="paramname">n</td><td>The number of points used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a500bb7c67e29e96e7f6c3655b8f7d3b3" name="a500bb7c67e29e96e7f6c3655b8f7d3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500bb7c67e29e96e7f6c3655b8f7d3b3">&#9670;&#160;</a></span>integral_gauss() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_gauss </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>Winv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gaussian quadrature using the given points and weights. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">x</td><td>The points of evaluation </td></tr>
    <tr><td class="paramname">w</td><td>The weights of the linear combination </td></tr>
    <tr><td class="paramname">n</td><td>The number of points used </td></tr>
    <tr><td class="paramname">Winv</td><td>The inverse of the weight function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbe2540b2ff381a14b61588280cb9016" name="abbe2540b2ff381a14b61588280cb9016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe2540b2ff381a14b61588280cb9016">&#9670;&#160;</a></span>integral_hermite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_hermite </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gauss-Hermite quadrature of arbitrary degree to approximate an integral over (-inf, +inf) providing the roots of the n degree Hermite polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">x</td><td>The roots of the n degree Hermite polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gauss-Hermite quadrature of the given function </dd></dl>

</div>
</div>
<a id="abd783739794f700157cc7f7d6f9d9632" name="abd783739794f700157cc7f7d6f9d9632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd783739794f700157cc7f7d6f9d9632">&#9670;&#160;</a></span>integral_hermite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_hermite </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gauss-Hermite quadrature of degree 2, 4, 8 or 16, using pre-computed values, to approximate an integral over (-inf, +inf). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">n</td><td>The order of the polynomial (available values are 2, 4, 8 or 16). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gauss-Hermite quadrature of the given function </dd></dl>

</div>
</div>
<a id="a369a64e60df5e45af0bb4581a9f213da" name="a369a64e60df5e45af0bb4581a9f213da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369a64e60df5e45af0bb4581a9f213da">&#9670;&#160;</a></span>integral_hom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_hom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Hit-or-miss Monte Carlo integration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">c</td><td>The function minimum in the domain [a, b] </td></tr>
    <tr><td class="paramname">d</td><td>The function maximum in the domain [a, b] </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd8b0a1c223e7bc79b04046d4e8502da" name="afd8b0a1c223e7bc79b04046d4e8502da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8b0a1c223e7bc79b04046d4e8502da">&#9670;&#160;</a></span>integral_hom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_hom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>f_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Hit-or-miss Monte Carlo integration. </p>
<dl class="section note"><dt>Note</dt><dd>This implementation considers only the portion of the function over zero (useful for distributions for example), if you need to consider all of the values of the function in the domain of integration, use the other implementation of integral_hom </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">f_max</td><td>The function maximum in the [a, b] interval </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1373c528867e33024d2975dfa7c41ca4" name="a1373c528867e33024d2975dfa7c41ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1373c528867e33024d2975dfa7c41ca4">&#9670;&#160;</a></span>integral_hom_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_hom_2d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>f_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the Hit-or-Miss Monte Carlo method to approximate a double integral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The multivariate function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration on x </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration on x </td></tr>
    <tr><td class="paramname">c</td><td>The lower extreme of integration on y </td></tr>
    <tr><td class="paramname">d</td><td>The upper extreme of integration on y </td></tr>
    <tr><td class="paramname">f_max</td><td>The function maximum in the [a, b]x[c, d] interval </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d1d65e5dba67ccf5199e5d5544e2484" name="a3d1d65e5dba67ccf5199e5d5544e2484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1d65e5dba67ccf5199e5d5544e2484">&#9670;&#160;</a></span>integral_impsamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_impsamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>Ginv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Crude Monte Carlo integration with importance sampling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">g</td><td>The importance function (normalized) </td></tr>
    <tr><td class="paramname">Ginv</td><td>The inverse of the primitive of g, with domain [0, 1] </td></tr>
    <tr><td class="paramname">gen</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4a53869de63d5c2daf7790511ce8aac" name="aa4a53869de63d5c2daf7790511ce8aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a53869de63d5c2daf7790511ce8aac">&#9670;&#160;</a></span>integral_laguerre() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_laguerre </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gauss-Laguerre quadrature of arbitrary degree to approximate an integral over [0, +inf) providing the roots of the n degree Legendre polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">x</td><td>The roots of the n degree Laguerre polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gauss-Laguerre quadrature of the given function </dd></dl>

</div>
</div>
<a id="a0c209d0975ad962d9b5e68a3661150ab" name="a0c209d0975ad962d9b5e68a3661150ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c209d0975ad962d9b5e68a3661150ab">&#9670;&#160;</a></span>integral_laguerre() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_laguerre </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gauss-Laguerre quadrature of arbitrary degree to approximate an integral over [a, b] providing the roots of the n degree Legendre polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">x</td><td>The roots of the n degree Laguerre polynomial </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gauss-Laguerre quadrature of the given function </dd></dl>

</div>
</div>
<a id="ab15d3b8d15def86bb228a46811100bca" name="ab15d3b8d15def86bb228a46811100bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15d3b8d15def86bb228a46811100bca">&#9670;&#160;</a></span>integral_laguerre() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_laguerre </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gauss-Laguerre quadrature of degree 2, 4, 8 or 16, using pre-computed values, to approximate an integral over [0, +inf). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">n</td><td>The order of the polynomial (available values are 2, 4, 8 or 16). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gauss-Legendre quadrature of the given function </dd></dl>

</div>
</div>
<a id="ad3f79a7b3f80ff901eba3340d1ba14a5" name="ad3f79a7b3f80ff901eba3340d1ba14a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f79a7b3f80ff901eba3340d1ba14a5">&#9670;&#160;</a></span>integral_legendre() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_legendre </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gauss-Legendre quadrature of arbitrary degree to approximate a definite integral providing the roots of the n degree Legendre polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">x</td><td>The roots of the n degree Legendre polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gauss-Legendre quadrature of the given function </dd></dl>

</div>
</div>
<a id="a62ca5edbbdee0a51f8c0bfddb4c71f69" name="a62ca5edbbdee0a51f8c0bfddb4c71f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ca5edbbdee0a51f8c0bfddb4c71f69">&#9670;&#160;</a></span>integral_legendre() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_legendre </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gauss-Legendre quadrature of arbitrary degree to approximate a definite integral providing the roots of the n degree Legendre polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">x</td><td>The roots of the n degree Legendre polynomial </td></tr>
    <tr><td class="paramname">w</td><td>The weights computed for the n-th order quadrature </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gauss-Legendre quadrature of the given function </dd></dl>

</div>
</div>
<a id="ad2038787a4650a9610cdf4639901677a" name="ad2038787a4650a9610cdf4639901677a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2038787a4650a9610cdf4639901677a">&#9670;&#160;</a></span>integral_legendre() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_legendre </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gauss-Legendre quadrature of arbitrary degree to approximate a definite integral providing the roots of the n degree Legendre polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">x</td><td>The roots of the n degree Legendre polynomial </td></tr>
    <tr><td class="paramname">w</td><td>The weights computed for the n-th order quadrature </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gauss-Legendre quadrature of the given function </dd></dl>

</div>
</div>
<a id="aa8406b9711bb256a289bb656c4c52e39" name="aa8406b9711bb256a289bb656c4c52e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8406b9711bb256a289bb656c4c52e39">&#9670;&#160;</a></span>integral_legendre() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_legendre </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gauss-Legendre quadrature of degree 2, 4, 8 or 16, using pre-computed values, to approximate an integral over [a, b]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">n</td><td>The order of the polynomial (available values are 2, 4, 8, 16 or 32). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gauss-Legendre quadrature of the given function </dd></dl>

</div>
</div>
<a id="ae48153156a44ef0245d23491aed11f81" name="ae48153156a44ef0245d23491aed11f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48153156a44ef0245d23491aed11f81">&#9670;&#160;</a></span>integral_midpoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_midpoint </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>steps</em> = <code><a class="el" href="namespacetheoretica.html#a92f59d0debe6a7cbdee72b28d4d53f16">CALCULUS_INTEGRAL_STEPS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the definite integral of an arbitrary function using the midpoint method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">steps</td><td>The number of steps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the integral of f </dd></dl>

</div>
</div>
<a id="abad6a42bf9fd0176e622e01e0f7446a9" name="abad6a42bf9fd0176e622e01e0f7446a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad6a42bf9fd0176e622e01e0f7446a9">&#9670;&#160;</a></span>integral_quasi_crude() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_quasi_crude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, S &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a1f21bd68ba64b172c29d9fce15c8712d">vec2</a>, S &gt;&#160;</td>
          <td class="paramname"><em>extremes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, S &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Crude Quasi-Monte Carlo integration by sampling from the Weyl sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">extremes</td><td>A vector of the extremes of integration </td></tr>
    <tr><td class="paramname">alpha</td><td>A vector of the irrational numbers to use for the Weyl sequence </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ed022df42e2b7152fc916433acbfbcc" name="a4ed022df42e2b7152fc916433acbfbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed022df42e2b7152fc916433acbfbcc">&#9670;&#160;</a></span>integral_quasi_crude() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_quasi_crude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, S &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a1f21bd68ba64b172c29d9fce15c8712d">vec2</a>, S &gt;&#160;</td>
          <td class="paramname"><em>extremes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Crude Quasi-Monte Carlo integration by sampling from the Weyl sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">extremes</td><td>A vector of the extremes of integration </td></tr>
    <tr><td class="paramname">alpha</td><td>An irrational number </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11c69bea27399e4d430e877b538ce777" name="a11c69bea27399e4d430e877b538ce777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c69bea27399e4d430e877b538ce777">&#9670;&#160;</a></span>integral_quasi_crude() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_quasi_crude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Crude Quasi-Monte Carlo integration by sampling from the Weyl sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2655b89d203adc197979dafd29fe518b" name="a2655b89d203adc197979dafd29fe518b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2655b89d203adc197979dafd29fe518b">&#9670;&#160;</a></span>integral_quasi_hom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_quasi_hom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Hit-or-miss Quasi-Monte Carlo integration, sampling points from the Weyl bi-dimensional sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">f_max</td><td>The function maximum in the [a, b] interval </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22f21b203e4325f357c2c84558239269" name="a22f21b203e4325f357c2c84558239269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f21b203e4325f357c2c84558239269">&#9670;&#160;</a></span>integral_quasi_hom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_quasi_hom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>f_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Hit-or-miss Quasi-Monte Carlo integration, sampling points from the Weyl bi-dimensional sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">f_max</td><td>The function maximum in the [a, b] interval </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0edff8be282482211b0cbc6cd022222e" name="a0edff8be282482211b0cbc6cd022222e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edff8be282482211b0cbc6cd022222e">&#9670;&#160;</a></span>integral_quasi_impsamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_quasi_impsamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>Ginv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Crude Quasi-Monte Carlo integration with importance sampling, using the Weyl sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">g</td><td>The importance function (normalized) </td></tr>
    <tr><td class="paramname">Ginv</td><td>The inverse of the primitive of g, with domain [0, 1] </td></tr>
    <tr><td class="paramname">gen</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f6c51cd5ff6287130ab25a6efbbe2e5" name="a8f6c51cd5ff6287130ab25a6efbbe2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6c51cd5ff6287130ab25a6efbbe2e5">&#9670;&#160;</a></span>integral_romberg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_romberg </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iter</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the definite integral of an arbitrary function using Romberg's method accurate to the given order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">order</td><td>The order of accuracy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the integral of f </dd></dl>

</div>
</div>
<a id="aa8715f45961d756064be2c06ba4784d4" name="aa8715f45961d756064be2c06ba4784d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8715f45961d756064be2c06ba4784d4">&#9670;&#160;</a></span>integral_romberg_tol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_romberg_tol </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>CALCULUS_INTEGRAL_TOL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the definite integral of an arbitrary function using Romberg's method to the given tolerance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">tolerance</td><td>Convergence tolerance for the algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the integral of f </dd></dl>

</div>
</div>
<a id="acc1c46c8f4022243fe207b05518c2740" name="acc1c46c8f4022243fe207b05518c2740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1c46c8f4022243fe207b05518c2740">&#9670;&#160;</a></span>integral_simpson()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_simpson </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>steps</em> = <code><a class="el" href="namespacetheoretica.html#a92f59d0debe6a7cbdee72b28d4d53f16">CALCULUS_INTEGRAL_STEPS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the definite integral of an arbitrary function using Simpson's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">steps</td><td>The number of steps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the integral of f </dd></dl>

</div>
</div>
<a id="aa4a89464c8faa686a7c8ade2df812493" name="aa4a89464c8faa686a7c8ade2df812493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a89464c8faa686a7c8ade2df812493">&#9670;&#160;</a></span>integral_trapezoid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_trapezoid </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>steps</em> = <code><a class="el" href="namespacetheoretica.html#a92f59d0debe6a7cbdee72b28d4d53f16">CALCULUS_INTEGRAL_STEPS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the definite integral of an arbitrary function using the trapezoid method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">steps</td><td>The number of steps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the integral of f </dd></dl>

</div>
</div>
<a id="a88f9a26f1ee40dea3fced3ee7e0c9aa9" name="a88f9a26f1ee40dea3fced3ee7e0c9aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f9a26f1ee40dea3fced3ee7e0c9aa9">&#9670;&#160;</a></span>interpolate_chebyshev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::interpolate_chebyshev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the interpolating polynomial of a real function using Chebyshev nodes as sampling points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to interpolate </td></tr>
    <tr><td class="paramname">a</td><td>Lower bound of the interval </td></tr>
    <tr><td class="paramname">b</td><td>Upper bound of the interval </td></tr>
    <tr><td class="paramname">order</td><td>Order of the resulting polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A polynomial of (n - 1) degree interpolating the function through the Chebyshev nodes.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#a25e8ede5b63e3e928ba06999468f33ef" title="Compute the n Chebyshev nodes on a given interval.">chebyshev_nodes</a> </dd>
<dd>
<a class="el" href="namespacetheoretica.html#ab8b367e4460b8aec5f8c29282f671006" title="Compute the Lagrange polynomial interpolating a set of points.">lagrange_polynomial</a> </dd></dl>

</div>
</div>
<a id="a9dc2216d71f0d7147b5c0dacdeea80db" name="a9dc2216d71f0d7147b5c0dacdeea80db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc2216d71f0d7147b5c0dacdeea80db">&#9670;&#160;</a></span>interpolate_grid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::interpolate_grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the interpolating polynomial of a real function on an equidistant point sample. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to interpolate </td></tr>
    <tr><td class="paramname">a</td><td>Lower bound of the interval </td></tr>
    <tr><td class="paramname">b</td><td>Upper bound of the interval </td></tr>
    <tr><td class="paramname">order</td><td>Order of the resulting polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A polynomial of (n - 1) degree interpolating the function </dd></dl>

</div>
</div>
<a id="a3e9b9fcd589d1358fb90effc83e1fc04" name="a3e9b9fcd589d1358fb90effc83e1fc04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9b9fcd589d1358fb90effc83e1fc04">&#9670;&#160;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the conjugate of a complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52e31c328bc34c0d2fca2aad3bf78ca7" name="a52e31c328bc34c0d2fca2aad3bf78ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e31c328bc34c0d2fca2aad3bf78ca7">&#9670;&#160;</a></span>ipow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T theoretica::ipow </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>neutral_element</em> = <code>T(1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the n-th positive power of x (where n is natural) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Any element of a multiplicative algebra </td></tr>
    <tr><td class="paramname">n</td><td>The integer exponent </td></tr>
    <tr><td class="paramname">neutral_element</td><td>The neutral element of the given type T </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x to the power n</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be preferred when computing the non-negative power of objects which are not strictly numbers but have a multiplication operation. </dd></dl>

</div>
</div>
<a id="a22e311a811c0c7e23c30e4496cfbe63d" name="a22e311a811c0c7e23c30e4496cfbe63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e311a811c0c7e23c30e4496cfbe63d">&#9670;&#160;</a></span>is_nan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool theoretica::is_nan </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a generic variable is (equivalent to) a NaN number. </p>
<p>NaN numbers are the only variables which do not compare equal to themselves in floating point operations. This is valid for real types but also for any mathematical structure, as NaNs are used to report failure inside the library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The mathematical structure to test for being a NaN or NaN-equivalent structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68914a563241494dfe7ac42f0462920c" name="a68914a563241494dfe7ac42f0462920c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68914a563241494dfe7ac42f0462920c">&#9670;&#160;</a></span>isqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnsignedIntType  = uint64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnsignedIntType theoretica::isqrt </td>
          <td>(</td>
          <td class="paramtype">UnsignedIntType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the integer square root of a positive integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A positive integer number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rounded down square root of n A binary search algorithm is used. </dd></dl>

</div>
</div>
<a id="a321928d10b6606c1cba0232a613e6dfe" name="a321928d10b6606c1cba0232a613e6dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321928d10b6606c1cba0232a613e6dfe">&#9670;&#160;</a></span>kronecker_delta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T theoretica::kronecker_delta </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kronecker delta, equals 1 if i is equal to j, 0 otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The first value to compare </td></tr>
    <tr><td class="paramname">j</td><td>The second value to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if i is equal to j, 0 otherwise </dd></dl>

</div>
</div>
<a id="ab8b367e4460b8aec5f8c29282f671006" name="ab8b367e4460b8aec5f8c29282f671006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b367e4460b8aec5f8c29282f671006">&#9670;&#160;</a></span>lagrange_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt; theoretica::lagrange_polynomial </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; T, 2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Lagrange polynomial interpolating a set of points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The set of n points to interpolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A polynomial of (n - 1) degree interpolating the points </dd></dl>

</div>
</div>
<a id="a4b528fc8814c1dd197a21d49f1ad6c93" name="a4b528fc8814c1dd197a21d49f1ad6c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b528fc8814c1dd197a21d49f1ad6c93">&#9670;&#160;</a></span>laguerre_weights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::laguerre_weights </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>roots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Laguerre weights for Gauss-Laguerre quadrature of n-th order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roots</td><td>The n roots of the n-th Laguerre polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Laguerre weights for Gauss-Laguerre quadrature </dd></dl>

</div>
</div>
<a id="acaa95392d9bfc3ddf34f3e82f4b6ae78" name="acaa95392d9bfc3ddf34f3e82f4b6ae78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa95392d9bfc3ddf34f3e82f4b6ae78">&#9670;&#160;</a></span>legendre_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::legendre_polynomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the nth Legendre polynomial. </p>
<dl class="section note"><dt>Note</dt><dd>The result is not normalized </dd></dl>

</div>
</div>
<a id="aebbaeffb922b25d5f1758296b473939f" name="aebbaeffb922b25d5f1758296b473939f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebbaeffb922b25d5f1758296b473939f">&#9670;&#160;</a></span>legendre_roots()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::legendre_roots </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Roots of the n-th Legendre polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The degree of the polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of the n roots of the Legendre polynomial </dd></dl>

</div>
</div>
<a id="a40aca2488b0466c4934fd050d3718760" name="a40aca2488b0466c4934fd050d3718760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40aca2488b0466c4934fd050d3718760">&#9670;&#160;</a></span>legendre_weights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::legendre_weights </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>roots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Legendre weights for Gauss-Legendre quadrature of n-th order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roots</td><td>The n roots of the n-th Legendre polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Legendre weights for Gauss-Legendre quadrature </dd></dl>

</div>
</div>
<a id="aeaa4a4d5af15f371b28d87d35b504aae" name="aeaa4a4d5af15f371b28d87d35b504aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa4a4d5af15f371b28d87d35b504aae">&#9670;&#160;</a></span>ln() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::ln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex logarithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a748eca731a8c05226332e5723b7a9d91" name="a748eca731a8c05226332e5723b7a9d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748eca731a8c05226332e5723b7a9d91">&#9670;&#160;</a></span>ln() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::ln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the natural logarithm of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number bigger than 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of x</dd></dl>
<p>Domain: (0, +inf] <br  />
On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fyl2x</code> instruction will be used. </p>

</div>
</div>
<a id="adb04217fd0bd9dd23daaa186d3756d1e" name="adb04217fd0bd9dd23daaa186d3756d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb04217fd0bd9dd23daaa186d3756d1e">&#9670;&#160;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::log10 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the base-10 logarithm of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number bigger than 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The base-10 logarithm of x</dd></dl>
<p>Domain: (0, +inf] <br  />
On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fyl2x</code> instruction will be used. </p>

</div>
</div>
<a id="abbd0ef7aa0b136fbd1b4579cec14f369" name="abbd0ef7aa0b136fbd1b4579cec14f369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd0ef7aa0b136fbd1b4579cec14f369">&#9670;&#160;</a></span>log2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::log2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the binary logarithm of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number bigger than 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binary logarithm of x</dd></dl>
<p>Domain: (0, +inf] <br  />
On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fyl2x</code> instruction will be used. </p>

</div>
</div>
<a id="aaac93661f565556c9740402f262e9a80" name="aaac93661f565556c9740402f262e9a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac93661f565556c9740402f262e9a80">&#9670;&#160;</a></span>make_vec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType , typename Type , typename ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void theoretica::make_vec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; ElementType &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates a vector with multiple elements using variadic arguments. </p>
<p>This function assigns the first element to the specified index, then recursively populates subsequent indices with remaining elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Reference to the vector being populated. </td></tr>
    <tr><td class="paramname">index</td><td>The current index to populate in the vector. </td></tr>
    <tr><td class="paramname">first</td><td>The first element to assign to the vector at the specified index. </td></tr>
    <tr><td class="paramname">elements</td><td>Remaining elements to populate in the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fe375758727a9f9a510a0898d69aaf4" name="a8fe375758727a9f9a510a0898d69aaf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe375758727a9f9a510a0898d69aaf4">&#9670;&#160;</a></span>make_vec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType , typename Type , typename ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void theoretica::make_vec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; ElementType &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates a vector with a single element at the specified index. </p>
<p>This function is the base case for recursive population.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Reference to the vector being populated. </td></tr>
    <tr><td class="paramname">index</td><td>The current index to populate in the vector. </td></tr>
    <tr><td class="paramname">last</td><td>The last element to assign to the vector at the specified index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bd4dbfccbb88413ccb29c93ae7254da" name="a1bd4dbfccbb88413ccb29c93ae7254da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd4dbfccbb88413ccb29c93ae7254da">&#9670;&#160;</a></span>map() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector , typename Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector theoretica::map </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a new vector obtained by applying the function element-wise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to apply </td></tr>
    <tr><td class="paramname">X</td><td>The input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified output vector </dd></dl>

</div>
</div>
<a id="a1b898a8449d723a807854f805f8be23e" name="a1b898a8449d723a807854f805f8be23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b898a8449d723a807854f805f8be23e">&#9670;&#160;</a></span>map() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector1 , typename Vector2  = Vector1, typename Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 &amp; theoretica::map </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector1 &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2 &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a new vector obtained by applying the function element-wise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to apply </td></tr>
    <tr><td class="paramname">src</td><td>The input vector </td></tr>
    <tr><td class="paramname">dest</td><td>The output vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the modified output vector </dd></dl>

</div>
</div>
<a id="ac43890de03a7e2c959fdabe4f7452042" name="ac43890de03a7e2c959fdabe4f7452042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43890de03a7e2c959fdabe4f7452042">&#9670;&#160;</a></span>map() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector2 , typename Vector1 , typename Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 theoretica::map </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector1 &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a new vector obtained by applying the function element-wise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to apply </td></tr>
    <tr><td class="paramname">X</td><td>The input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified output vector </dd></dl>

</div>
</div>
<a id="a07569756dda099ecabf425371da6a31d" name="a07569756dda099ecabf425371da6a31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07569756dda099ecabf425371da6a31d">&#9670;&#160;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the greatest number between two real numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
    <tr><td class="paramname">y</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greatest number between x and y</dd></dl>
<p>If <code>THEORETICA_BRANCHLESS</code> is defined, a branchless implementation will be used </p>

</div>
</div>
<a id="a5e295404d1712fb17851fe105715766e" name="a5e295404d1712fb17851fe105715766e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e295404d1712fb17851fe105715766e">&#9670;&#160;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T theoretica::max </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two objects and return the greatest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The first object to compare </td></tr>
    <tr><td class="paramname">y</td><td>The second object to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greatest between the objects</dd></dl>
<p>The templated T type must have comparison operators. </p>

</div>
</div>
<a id="a4e122e9c54b7f36043851a702fb7e79a" name="a4e122e9c54b7f36043851a702fb7e79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e122e9c54b7f36043851a702fb7e79a">&#9670;&#160;</a></span>maximize_bisection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::maximize_bisection </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>Df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate a function maximum inside an interval given the function and its first derivative using bisection on the derivative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to search a local minimum of. </td></tr>
    <tr><td class="paramname">Df</td><td>The derivative of the function. </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of the search interval. </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of the search interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate of the local maximum. </dd></dl>

</div>
</div>
<a id="aab8f4ab246c4b2b8ed36c3893880b6c4" name="aab8f4ab246c4b2b8ed36c3893880b6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8f4ab246c4b2b8ed36c3893880b6c4">&#9670;&#160;</a></span>maximize_goldensection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::maximize_goldensection </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate a function maximum using the Golden Section search algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to search a local maximum of. </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of the search interval. </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of the search interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate of the local maximum. </dd></dl>

</div>
</div>
<a id="accfdc59bb7d6b7bce2173add38cb7a89" name="accfdc59bb7d6b7bce2173add38cb7a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfdc59bb7d6b7bce2173add38cb7a89">&#9670;&#160;</a></span>maximize_newton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::maximize_newton </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>Df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>D2f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>guess</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate a function maximum given the function and the first two derivatives using Newton-Raphson's method to find a root of the derivative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to search a local maximum of. </td></tr>
    <tr><td class="paramname">Df</td><td>The derivative of the function. </td></tr>
    <tr><td class="paramname">D2f</td><td>The second derivative of the function. </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess (defaults to 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate of the local maximum. </dd></dl>

</div>
</div>
<a id="a66a8fc915915b6eff35dbf94c74b13bd" name="a66a8fc915915b6eff35dbf94c74b13bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a8fc915915b6eff35dbf94c74b13bd">&#9670;&#160;</a></span>metropolis() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::metropolis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>pdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1pdf__sampler.html">pdf_sampler</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>rnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em> = <code><a class="el" href="namespacetheoretica.html#a1a92480c95125647eabea5f15aa26f83">STATISTICS_METROPOLIS_DEPTH</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Metropolis algorithm for distribution sampling using a symmetric proposal distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdf</td><td>The target distribution </td></tr>
    <tr><td class="paramname">g</td><td>A <a class="el" href="structtheoretica_1_1pdf__sampler.html" title="A probability density function sampler which generates pseudorandom numbers following asymptotically ...">pdf_sampler</a> already initialized to sample from the proposal distribution </td></tr>
    <tr><td class="paramname">rnd</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">depth</td><td>The number of iterations of the algorithm (defaults to STATISTICS_METROPOLIS_DEPTH) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac91dfc5efe4fa412bd7ef46f142f7045" name="ac91dfc5efe4fa412bd7ef46f142f7045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91dfc5efe4fa412bd7ef46f142f7045">&#9670;&#160;</a></span>metropolis() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::metropolis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>pdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1pdf__sampler.html">pdf_sampler</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em> = <code><a class="el" href="namespacetheoretica.html#a1a92480c95125647eabea5f15aa26f83">STATISTICS_METROPOLIS_DEPTH</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Metropolis algorithm for distribution sampling using a symmetric proposal distribution. </p>
<p>This function uses the same <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> as the proposal distribution sampler to generate uniform samples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdf</td><td>The target distribution </td></tr>
    <tr><td class="paramname">g</td><td>A <a class="el" href="structtheoretica_1_1pdf__sampler.html" title="A probability density function sampler which generates pseudorandom numbers following asymptotically ...">pdf_sampler</a> already initialized to sample from the proposal distribution </td></tr>
    <tr><td class="paramname">depth</td><td>The number of iterations of the algorithm (defaults to STATISTICS_METROPOLIS_DEPTH) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac673920f8956ebea402eac4271f551ba" name="ac673920f8956ebea402eac4271f551ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac673920f8956ebea402eac4271f551ba">&#9670;&#160;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the smallest number between two real numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
    <tr><td class="paramname">y</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest number between x and y</dd></dl>
<p>If <code>THEORETICA_BRANCHLESS</code> is defined, a branchless implementation will be used </p>

</div>
</div>
<a id="a70f4122359c1f32ba0741d098a5fbe69" name="a70f4122359c1f32ba0741d098a5fbe69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f4122359c1f32ba0741d098a5fbe69">&#9670;&#160;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T theoretica::min </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two objects and return the greatest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The first object to compare </td></tr>
    <tr><td class="paramname">y</td><td>The second object to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest between the objects</dd></dl>
<p>The templated T type must have comparison operators. </p>

</div>
</div>
<a id="a0f9db1a3ca3da10bd76a8af20bb513ae" name="a0f9db1a3ca3da10bd76a8af20bb513ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9db1a3ca3da10bd76a8af20bb513ae">&#9670;&#160;</a></span>minimize_bisection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::minimize_bisection </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>Df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate a function minimum inside an interval given the function and its first derivative using bisection on the derivative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to search a local minimum of. </td></tr>
    <tr><td class="paramname">Df</td><td>The derivative of the function. </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of the search interval. </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of the search interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate of the local minimum. </dd></dl>

</div>
</div>
<a id="ac3a7880ad0abc4b7b03198d90001631c" name="ac3a7880ad0abc4b7b03198d90001631c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a7880ad0abc4b7b03198d90001631c">&#9670;&#160;</a></span>minimize_goldensection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::minimize_goldensection </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate a function minimum using the Golden Section search algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to search a local minimum of. </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of the search interval. </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of the search interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate of the local minimum. </dd></dl>

</div>
</div>
<a id="ae9dc22f3165357c127c26aa2a4b6c5e5" name="ae9dc22f3165357c127c26aa2a4b6c5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9dc22f3165357c127c26aa2a4b6c5e5">&#9670;&#160;</a></span>minimize_newton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::minimize_newton </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>Df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>D2f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>guess</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate a function minimum given the function and the first two derivatives using Newton-Raphson's method to find a root of the derivative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to search a local minimum of. </td></tr>
    <tr><td class="paramname">Df</td><td>The derivative of the function. </td></tr>
    <tr><td class="paramname">D2f</td><td>The second derivative of the function. </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess (defaults to 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate of the local minimum. </dd></dl>

</div>
</div>
<a id="a672dbbc0ea824c71d7ca0dc26b346200" name="a672dbbc0ea824c71d7ca0dc26b346200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672dbbc0ea824c71d7ca0dc26b346200">&#9670;&#160;</a></span>mix_mum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::mix_mum </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MUM bit mixing function, computes the 128-bit product of a and b and the XOR of their high and low 64-bit parts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first operand </td></tr>
    <tr><td class="paramname">b</td><td>The second operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The XOR of the high and low bits of the 128-bit product of a and b. </dd></dl>

</div>
</div>
<a id="aca2b51694a7dd4ded3a140f92366aaed" name="aca2b51694a7dd4ded3a140f92366aaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2b51694a7dd4ded3a140f92366aaed">&#9670;&#160;</a></span>mul_uint128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void theoretica::mul_uint128 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>c_low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>c_high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two 64-bit unsigned integers and store the result in two 64-bit variables, keeping 128 bits of the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number to multiply </td></tr>
    <tr><td class="paramname">b</td><td>The second number to multiply </td></tr>
    <tr><td class="paramname">c_low</td><td>The variable to store the lowest 64 bits of the result. </td></tr>
    <tr><td class="paramname">c_high</td><td>The variable to store the highest 64 bits of the result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5703b4f09d1f4a018d2cca9e8aeaa3c2" name="a5703b4f09d1f4a018d2cca9e8aeaa3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5703b4f09d1f4a018d2cca9e8aeaa3c2">&#9670;&#160;</a></span>multi_maximize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::multi_maximize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt;<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>,&#160;N&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a5a801e1df1e3281002e402a3f310bfb0">OPTIMIZATION_MINGRAD_TOLERANCE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the best available algorithm to find a local maximum of the given multivariate function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to multi_maximize </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess </td></tr>
    <tr><td class="paramname">tolerance</td><td>The minimum magnitude of the gradient to stop the algorithm at, defaults to OPTIMIZATION_MINGRAD_TOLERANCE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates of the local maximum, NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="a9f1e891bf9ed955c5d05a1a41c01d832" name="a9f1e891bf9ed955c5d05a1a41c01d832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1e891bf9ed955c5d05a1a41c01d832">&#9670;&#160;</a></span>multi_maximize_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::multi_maximize_grad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt;<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>,&#160;N&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>gamma</em> = <code><a class="el" href="namespacetheoretica.html#aec69cb2482367d47a3d966c573b04fd6">OPTIMIZATION_MINGRAD_GAMMA</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a5a801e1df1e3281002e402a3f310bfb0">OPTIMIZATION_MINGRAD_TOLERANCE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#a86e5dd300ac007074bcf54bfc9e59c6d">OPTIMIZATION_MINGRAD_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a local maximum of the given multivariate function using fixed-step gradient descent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to multi_maximize </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess, defaults to the origin </td></tr>
    <tr><td class="paramname">gamma</td><td>The fixed step size, defaults to OPTIMIZATION_MINGRAD_GAMMA </td></tr>
    <tr><td class="paramname">tolerance</td><td>The maximum magnitude of the gradient to stop the algorithm at, defaults to OPTIMIZATION_MINGRAD_TOLERANCE. </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform before stopping execution of the routine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates of the local maximum, NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="a7006f83864895393d90045a16a31bd04" name="a7006f83864895393d90045a16a31bd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7006f83864895393d90045a16a31bd04">&#9670;&#160;</a></span>multi_maximize_lingrad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::multi_maximize_lingrad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt;<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>,&#160;N&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a5a801e1df1e3281002e402a3f310bfb0">OPTIMIZATION_MINGRAD_TOLERANCE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#a86e5dd300ac007074bcf54bfc9e59c6d">OPTIMIZATION_MINGRAD_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a local maximum of the given multivariate function using gradient descent with linear search. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to multi_maximize </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess, defaults to the origin </td></tr>
    <tr><td class="paramname">tolerance</td><td>The minimum magnitude of the gradient to stop the algorithm at, defaults to OPTIMIZATION_MINGRAD_TOLERANCE. </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform before stopping execution of the routine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates of the local maximum, NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="a1448b081afb964641757cc81cee35d7d" name="a1448b081afb964641757cc81cee35d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1448b081afb964641757cc81cee35d7d">&#9670;&#160;</a></span>multi_minimize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::multi_minimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt;<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>,&#160;N&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a5a801e1df1e3281002e402a3f310bfb0">OPTIMIZATION_MINGRAD_TOLERANCE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the best available algorithm to find a local minimum of the given multivariate function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to multi_minimize </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess </td></tr>
    <tr><td class="paramname">tolerance</td><td>The minimum magnitude of the gradient to stop the algorithm at, defaults to OPTIMIZATION_MINGRAD_TOLERANCE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates of the local minimum, NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="aaf55462e13265d39fef3afe0cc375c92" name="aaf55462e13265d39fef3afe0cc375c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf55462e13265d39fef3afe0cc375c92">&#9670;&#160;</a></span>multi_minimize_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::multi_minimize_grad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt;<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>,&#160;N&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>gamma</em> = <code><a class="el" href="namespacetheoretica.html#aec69cb2482367d47a3d966c573b04fd6">OPTIMIZATION_MINGRAD_GAMMA</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a5a801e1df1e3281002e402a3f310bfb0">OPTIMIZATION_MINGRAD_TOLERANCE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#a86e5dd300ac007074bcf54bfc9e59c6d">OPTIMIZATION_MINGRAD_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a local minimum of the given multivariate function using fixed-step gradient descent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to multi_minimize </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess, defaults to the origin </td></tr>
    <tr><td class="paramname">gamma</td><td>The fixed step size, defaults to OPTIMIZATION_MINGRAD_GAMMA </td></tr>
    <tr><td class="paramname">tolerance</td><td>The maximum magnitude of the gradient to stop the algorithm at, defaults to OPTIMIZATION_MINGRAD_TOLERANCE. </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform before stopping execution of the routine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates of the local minimum, NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="a006aae49f3c2e2d8a91c13d3485c902a" name="a006aae49f3c2e2d8a91c13d3485c902a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006aae49f3c2e2d8a91c13d3485c902a">&#9670;&#160;</a></span>multi_minimize_lingrad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::multi_minimize_lingrad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt;<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>,&#160;N&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a5a801e1df1e3281002e402a3f310bfb0">OPTIMIZATION_MINGRAD_TOLERANCE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#a86e5dd300ac007074bcf54bfc9e59c6d">OPTIMIZATION_MINGRAD_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a local minimum of the given multivariate function using gradient descent with linear search. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to multi_minimize </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess, defaults to the origin </td></tr>
    <tr><td class="paramname">tolerance</td><td>The maximum magnitude of the gradient to stop the algorithm at, defaults to OPTIMIZATION_MINGRAD_TOLERANCE. </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform before stopping execution of the routine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates of the local minimum, NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="a266e22e5ea430f0524e91f2cc377387f" name="a266e22e5ea430f0524e91f2cc377387f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266e22e5ea430f0524e91f2cc377387f">&#9670;&#160;</a></span>multiroot_newton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::multiroot_newton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica_1_1autodiff.html#abdc7bdd230700601e24de68a05d7ec08">autodiff::dvec_t</a>&lt; N &gt;(*)(<a class="el" href="namespacetheoretica_1_1autodiff.html#abdc7bdd230700601e24de68a05d7ec08">autodiff::dvec_t</a>&lt; N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt;<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>,&#160;N&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a5a801e1df1e3281002e402a3f310bfb0">OPTIMIZATION_MINGRAD_TOLERANCE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#a86e5dd300ac007074bcf54bfc9e59c6d">OPTIMIZATION_MINGRAD_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the root of a multivariate function using Newton's method with pure Jacobian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to find the root of </td></tr>
    <tr><td class="paramname">guess</td><td>The first guess (defaults to the origin) </td></tr>
    <tr><td class="paramname">tolerance</td><td>The tolerance over the final result (defaults to OPTIMIZATION_MINGRAD_TOLERANCE) </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations before stopping the algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed vector at which f is approximately zero </dd></dl>

</div>
</div>
<a id="aa9628d333f307cc0dfe8578f29146615" name="aa9628d333f307cc0dfe8578f29146615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9628d333f307cc0dfe8578f29146615">&#9670;&#160;</a></span>pad2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnsignedIntType  = uint64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnsignedIntType theoretica::pad2 </td>
          <td>(</td>
          <td class="paramtype">UnsignedIntType&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the smallest power of 2 bigger than or equal to x. </p>
<p>This function is useful to add padding to vectors and matrices to apply recursive algorithms such as the FFT. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An integer number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest power of 2 bigger or equal to x </dd></dl>

</div>
</div>
<a id="a13248f2e439afdb6f72e0f2c1e79cc55" name="a13248f2e439afdb6f72e0f2c1e79cc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13248f2e439afdb6f72e0f2c1e79cc55">&#9670;&#160;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T theoretica::pow </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the n-th power of x (where n is natural) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Any element of a multiplicative algebra </td></tr>
    <tr><td class="paramname">n</td><td>The integer exponent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x to the power n </dd></dl>

</div>
</div>
<a id="a6f12dd8e0fc650fa75c9961e51d1406c" name="a6f12dd8e0fc650fa75c9961e51d1406c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f12dd8e0fc650fa75c9961e51d1406c">&#9670;&#160;</a></span>powf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::powf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate x elevated to a real exponent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
    <tr><td class="paramname">a</td><td>A real exponent</td></tr>
  </table>
  </dd>
</dl>
<p>Approximated as \(e^{a ln(|x|) sgn(x)}\) </p>

</div>
</div>
<a id="aa7e523c1cc3621e7cbc1ac0df01913c3" name="aa7e523c1cc3621e7cbc1ac0df01913c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e523c1cc3621e7cbc1ac0df01913c3">&#9670;&#160;</a></span>qrand_weyl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::qrand_weyl </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code><a class="el" href="namespacetheoretica.html#a6a6de16e5ee81d340ff91dbadb99edde">INVPHI</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weyl quasi-random sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element in the sequence </td></tr>
    <tr><td class="paramname">alpha</td><td>The base of the sequence, defaults to the inverse of the Golden Section</td></tr>
  </table>
  </dd>
</dl>
<p>The Weyl sequence is defined as \(x_n = \{n \alpha\}\), where \(\{ \}\) is the fractional part. </p><dl class="section note"><dt>Note</dt><dd>The alpha argument should be an irrational number. </dd></dl>

</div>
</div>
<a id="ac1d4be50bf77c6b368c94bb627305224" name="ac1d4be50bf77c6b368c94bb627305224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d4be50bf77c6b368c94bb627305224">&#9670;&#160;</a></span>qrand_weyl2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a1f21bd68ba64b172c29d9fce15c8712d">vec2</a> theoretica::qrand_weyl2 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.7548776662466927</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weyl quasi-random sequence in 2 dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element in the sequence </td></tr>
    <tr><td class="paramname">alpha</td><td>The base of the sequence</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The alpha argument should be an irrational number. </dd></dl>

</div>
</div>
<a id="a216195a1bbd4fed54c50cce034e48bfa" name="a216195a1bbd4fed54c50cce034e48bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216195a1bbd4fed54c50cce034e48bfa">&#9670;&#160;</a></span>qrand_weyl_multi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::qrand_weyl_multi </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weyl quasi-random sequence in N dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element in the sequence </td></tr>
    <tr><td class="paramname">alpha</td><td>The base of the sequence</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The alpha argument should be an irrational number. </dd></dl>

</div>
</div>
<a id="a6c5001951408c716ce4e6414cc45f420" name="a6c5001951408c716ce4e6414cc45f420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5001951408c716ce4e6414cc45f420">&#9670;&#160;</a></span>qrand_weyl_recurr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::qrand_weyl_recurr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>prev</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code><a class="el" href="namespacetheoretica.html#a6a6de16e5ee81d340ff91dbadb99edde">INVPHI</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weyl quasi-random sequence (computed with recurrence relation) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>The previously computed value </td></tr>
    <tr><td class="paramname">alpha</td><td>The base of the sequence, defaults to the inverse of the Golden Section</td></tr>
  </table>
  </dd>
</dl>
<p>If no arguments are provided or prev is zero, the function computes the first element of the Weyl sequence associated to the parameter alpha. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#aa7e523c1cc3621e7cbc1ac0df01913c3" title="Weyl quasi-random sequence.">qrand_weyl</a> </dd></dl>

</div>
</div>
<a id="a286f4d2ae42de1965c86c999927f128b" name="a286f4d2ae42de1965c86c999927f128b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286f4d2ae42de1965c86c999927f128b">&#9670;&#160;</a></span>radians()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::radians </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>degrees</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert degrees to radians. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>An angle in degrees </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted angle in radians</dd></dl>
<p>The <code>DEG2RAD</code> scalar factor is used. </p>

</div>
</div>
<a id="a473df88a9edd9ccc8dcf03665591575b" name="a473df88a9edd9ccc8dcf03665591575b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473df88a9edd9ccc8dcf03665591575b">&#9670;&#160;</a></span>rand_cauchy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_cauchy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_cauchy(real, real, PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada12d3bc9842b85e97e14f0eb975e132" name="ada12d3bc9842b85e97e14f0eb975e132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada12d3bc9842b85e97e14f0eb975e132">&#9670;&#160;</a></span>rand_cointoss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_cointoss </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_cointoss(PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99ddd9fc13f4c8b28ea4025640cbadf4" name="a99ddd9fc13f4c8b28ea4025640cbadf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ddd9fc13f4c8b28ea4025640cbadf4">&#9670;&#160;</a></span>rand_cointoss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_cointoss </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Coin toss random generator. </p>
<p>Extracts 1 or -1 with equal probability.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a709a55686cbd545429284beb16eef7b7" name="a709a55686cbd545429284beb16eef7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a709a55686cbd545429284beb16eef7b7">&#9670;&#160;</a></span>rand_diceroll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_diceroll </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_diceroll(PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a968bc8465bcb421983d457b96469e9ef" name="a968bc8465bcb421983d457b96469e9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968bc8465bcb421983d457b96469e9ef">&#9670;&#160;</a></span>rand_diceroll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_diceroll </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dice roll random generator. </p>
<p>Extracts a random natural number in [1, faces] with equal probability.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faces</td><td>The number of faces of the dice </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2e6165f6c783179d1b3c2e321b3e7d4" name="aa2e6165f6c783179d1b3c2e321b3e7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e6165f6c783179d1b3c2e321b3e7d4">&#9670;&#160;</a></span>rand_exponential()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_exponential </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_exponential(real, PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad2c1865b7a5639ed82643a069554e3d" name="aad2c1865b7a5639ed82643a069554e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2c1865b7a5639ed82643a069554e3d">&#9670;&#160;</a></span>rand_gaussian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_gaussian </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_gaussian(real, real, PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91d0c9531b268c00e759cb571422e01f" name="a91d0c9531b268c00e759cb571422e01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d0c9531b268c00e759cb571422e01f">&#9670;&#160;</a></span>rand_gaussian_boxmuller()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_gaussian_boxmuller </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random number following a Gaussian distribution using the Box-Muller method. </p>
<dl class="section note"><dt>Note</dt><dd>This function may not be thread-safe as it uses static variables to keep track of spare generated values. </dd></dl>

</div>
</div>
<a id="a8c36b22d9b1f9f2beeab1c7be35fe8b3" name="a8c36b22d9b1f9f2beeab1c7be35fe8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c36b22d9b1f9f2beeab1c7be35fe8b3">&#9670;&#160;</a></span>rand_gaussian_clt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_gaussian_clt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random number in a range following a Gaussian distribution by exploiting the Central Limit Theorem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mean</td><td>The mean of the target distribution </td></tr>
    <tr><td class="paramname">sigma</td><td>The sigma of the target distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a></td></tr>
  </table>
  </dd>
</dl>
<p>Exactly 12 real numbers in a range are generated and the mean is computed to get a single real number following (asymptotically) a Gaussian distribution. </p>

</div>
</div>
<a id="af2b8d1fc98c8429d4b342e860cab6ed1" name="af2b8d1fc98c8429d4b342e860cab6ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b8d1fc98c8429d4b342e860cab6ed1">&#9670;&#160;</a></span>rand_gaussian_clt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_gaussian_clt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random number in a range following a Gaussian distribution by exploiting the Central Limit Theorem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mean</td><td>The mean of the target distribution </td></tr>
    <tr><td class="paramname">sigma</td><td>The sigma of the target distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of random numbers to generate</td></tr>
  </table>
  </dd>
</dl>
<p>Many real numbers in a range are generated and the mean is computed to get a single real number following (asymptotically) a Gaussian distribution.</p>
<dl class="section note"><dt>Note</dt><dd>This function uses a square root (<a class="el" href="namespacetheoretica.html#a19dd33456cffdbba3f29d85061779e7c" title="Compute the square root of a second order dual number.">th::sqrt</a>) to rescale the output for variable N, the constant N implementation has better performance. </dd></dl>

</div>
</div>
<a id="ac8bdf0dc89459fedaf6950c0f9b96df5" name="ac8bdf0dc89459fedaf6950c0f9b96df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bdf0dc89459fedaf6950c0f9b96df5">&#9670;&#160;</a></span>rand_gaussian_polar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_gaussian_polar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random number following a Gaussian distribution using Marsaglia's polar method. </p>
<dl class="section note"><dt>Note</dt><dd>This function may not be thread-safe as it uses static variables to keep track of spare generated values. </dd></dl>

</div>
</div>
<a id="ae66a655f57ef0f6e436dfc03e800585b" name="ae66a655f57ef0f6e436dfc03e800585b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66a655f57ef0f6e436dfc03e800585b">&#9670;&#160;</a></span>rand_pareto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_pareto </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_pareto(real, real, PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a012d14c9ef85d6f3028bf8ceb1008787" name="a012d14c9ef85d6f3028bf8ceb1008787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012d14c9ef85d6f3028bf8ceb1008787">&#9670;&#160;</a></span>rand_rayleigh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_rayleigh </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_rayleigh(real, PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e708ed0859828011f0d262c93274ec3" name="a7e708ed0859828011f0d262c93274ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e708ed0859828011f0d262c93274ec3">&#9670;&#160;</a></span>rand_rejectsamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_rejectsamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ac7a0bafb035970e4921b84f75661e2b1">stat_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>Pinv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_tries</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random number following any given distribution using rejection sampling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Target distribution </td></tr>
    <tr><td class="paramname">theta</td><td>The parameters of the target distribution </td></tr>
    <tr><td class="paramname">p</td><td>Proposal distribution </td></tr>
    <tr><td class="paramname">Pinv</td><td>Inverse cumulative function of the proposal distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">max_tries</td><td>Maximum number of tries before stopping execution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accbe6df09ae3883660614f02f70a2ade" name="accbe6df09ae3883660614f02f70a2ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbe6df09ae3883660614f02f70a2ade">&#9670;&#160;</a></span>rand_trycatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_trycatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ac7a0bafb035970e4921b84f75661e2b1">stat_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#a69a848b21acb5341a013db4baa629bde">STATISTICS_TRYANDCATCH_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pseudorandom value following any probability distribution function using the Try-and-Catch (rejection) algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A probability distribution function </td></tr>
    <tr><td class="paramname">theta</td><td>The parameters of the pdf </td></tr>
    <tr><td class="paramname">x1</td><td>The left extreme of the rectangle </td></tr>
    <tr><td class="paramname">x2</td><td>The right extreme of the rectangle </td></tr>
    <tr><td class="paramname">y1</td><td>The lower extreme of the rectangle </td></tr>
    <tr><td class="paramname">y2</td><td>The upper extreme of the rectangle </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> to use for number generation </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of failed generations before stopping execution (defaults to STATISTICS_TRYANDCATCH_ITER) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A real number following the given pdf</dd></dl>
<p>Random real numbers are generated inside a rectangle defined by x1, x2, y1 and y2 following a uniform distribution. Only numbers below the pdf are returned. </p>

</div>
</div>
<a id="ad7e77a1836e1b966cdbb0934d5ebbbf2" name="ad7e77a1836e1b966cdbb0934d5ebbbf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e77a1836e1b966cdbb0934d5ebbbf2">&#9670;&#160;</a></span>rand_uniform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_uniform </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_uniform(real, real, PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a579b4ccc4078b67b7ec795b744e436d5" name="a579b4ccc4078b67b7ec795b744e436d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579b4ccc4078b67b7ec795b744e436d5">&#9670;&#160;</a></span>rand_uniform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_uniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="namespacetheoretica.html#a2ab0dc413ccb1d809e2269de05dbf48d">STATISTICS_RAND_PREC</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pseudorandom real number in [a, b] using a preexisting generator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The lower extreme of the interval </td></tr>
    <tr><td class="paramname">b</td><td>The higher extreme of the interval </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized pseudorandom number generator </td></tr>
    <tr><td class="paramname">prec</td><td>Precision parameters for the normalization, defaults to STATISTICS_RAND_PREC.</td></tr>
  </table>
  </dd>
</dl>
<p>The algorithm generates a random integer number, computes its modulus and divides it by prec: \(x = \frac{(n mod p)}{2^p}\), where n is the random integer and p is the prec parameter </p>

</div>
</div>
<a id="a01565fc76eac80418a68b0076f0e5c1d" name="a01565fc76eac80418a68b0076f0e5c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01565fc76eac80418a68b0076f0e5c1d">&#9670;&#160;</a></span>randgen_congruential() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::randgen_congruential </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pseudorandom natural number using the congruential pseudorandom number generation algorithm (wrapper) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The current recurrence value of the algorithm ( \(x_n\)) </td></tr>
    <tr><td class="paramname">state</td><td>A vector containing the state of the algorithm (a, c, m in this order) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next generated pseudorandom number</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#aafab10ea5cdd0da85e7eca301936c0d0" title="Generate a pseudorandom natural number using the congruential pseudorandom number generation algorith...">randgen_congruential</a> </dd></dl>

</div>
</div>
<a id="aafab10ea5cdd0da85e7eca301936c0d0" name="aafab10ea5cdd0da85e7eca301936c0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafab10ea5cdd0da85e7eca301936c0d0">&#9670;&#160;</a></span>randgen_congruential() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::randgen_congruential </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em> = <code>48271</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>c</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>m</em> = <code>((uint64_t)&#160;1&#160;&lt;&lt;&#160;31)&#160;-&#160;1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pseudorandom natural number using the congruential pseudorandom number generation algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The current recurrence value of the algorithm (x_n) </td></tr>
    <tr><td class="paramname">a</td><td>The multiplier term </td></tr>
    <tr><td class="paramname">c</td><td>The increment term </td></tr>
    <tr><td class="paramname">m</td><td>The modulus term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next generated pseudorandom number</dd></dl>
<p>The congruential generator is defined by the recurrence formula \(x_{n+1} = (a x_n + c) mod m\) <br  />
If no parameters are passed, the generator defaults to a = 48271, c = 0, m = (1 &lt;&lt; 31) - 1. </p>

</div>
</div>
<a id="aa8a82c81ffa9c26b29666bee9c4255a7" name="aa8a82c81ffa9c26b29666bee9c4255a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a82c81ffa9c26b29666bee9c4255a7">&#9670;&#160;</a></span>randgen_middlesquare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::randgen_middlesquare </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>765872292751861</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pseudorandom natural number using the middle-square pseudorandom number generation algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The (changing) seed of the algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit pseudorandom number</dd></dl>
<p>An offset is added to the 64-bit seed and the result is squared, taking the middle 64-bit of the 128-bit result. </p>

</div>
</div>
<a id="a0e0eae50ce4c989d7120cab32259f965" name="a0e0eae50ce4c989d7120cab32259f965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0eae50ce4c989d7120cab32259f965">&#9670;&#160;</a></span>randgen_middlesquare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::randgen_middlesquare </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pseudorandom natural number using the middle-square pseudorandom number generation algorithm (wrapper) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The seed of the algorithm </td></tr>
    <tr><td class="paramname">p</td><td>Algorithm parameters, p[0] is the offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit pseudorandom number </dd></dl>

</div>
</div>
<a id="a8c543b2a35f826b5cbac8d2c55423cb3" name="a8c543b2a35f826b5cbac8d2c55423cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c543b2a35f826b5cbac8d2c55423cb3">&#9670;&#160;</a></span>randgen_splitmix64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::randgen_splitmix64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pseudorandom natural number using the SplitMix64 pseudorandom number generation algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The 64-bit state of the algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit pseudorandom number</dd></dl>
<p>Adapted from the reference implementation by Sebastiano Vigna. </p>

</div>
</div>
<a id="a6e1748188bd7af18f43b175f39b52aa9" name="a6e1748188bd7af18f43b175f39b52aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1748188bd7af18f43b175f39b52aa9">&#9670;&#160;</a></span>randgen_splitmix64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::randgen_splitmix64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pseudorandom natural number using the SplitMix64 pseudorandom number generation algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The 64-bit state of the algorithm </td></tr>
    <tr><td class="paramname">p</td><td>Dummy variable (needed for function signature) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit pseudorandom number </dd></dl>

</div>
</div>
<a id="acaa4e075d9a95b8a060832e053eede81" name="acaa4e075d9a95b8a060832e053eede81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa4e075d9a95b8a060832e053eede81">&#9670;&#160;</a></span>randgen_wyrand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::randgen_wyrand </td>
          <td>(</td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pseudorandom natural number using the Wyrand pseudorandom number generation, as invented by Yi Wang. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The (changing) seed of the algorithm </td></tr>
    <tr><td class="paramname">p0</td><td>Additive constant (ideally a large prime number) </td></tr>
    <tr><td class="paramname">p1</td><td>Mask for the algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit pseudorandom number </dd></dl>

</div>
</div>
<a id="ac6556353391af45a096cc875c7c535f5" name="ac6556353391af45a096cc875c7c535f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6556353391af45a096cc875c7c535f5">&#9670;&#160;</a></span>randgen_wyrand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::randgen_wyrand </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pseudorandom natural number using the Wyrand pseudorandom number generation, as invented by Yi Wang (wrapper) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Dummy variable </td></tr>
    <tr><td class="paramname">p</td><td>Algorithm parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit pseudorandom number</dd></dl>
<p>p[0] is the initial seed, p[1] a large prime number and p[2] is the bit mask. </p>

</div>
</div>
<a id="a32b453326547b2d165f095733e67a10d" name="a32b453326547b2d165f095733e67a10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b453326547b2d165f095733e67a10d">&#9670;&#160;</a></span>randgen_xoshiro() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::randgen_xoshiro </td>
          <td>(</td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pseudorandom natural number using the xoshiro256++ pseudorandom number generation algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Dummy parameter (needed for function signature) </td></tr>
    <tr><td class="paramname">state</td><td>The four 64-bit integer state of the algorithm which will be updated during the iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit pseudorandom number</dd></dl>
<p>Adapted from the reference implementation by Sebastiano Vigna. </p>

</div>
</div>
<a id="aae939f7e9a1eaee809da226cbfbd883e" name="aae939f7e9a1eaee809da226cbfbd883e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae939f7e9a1eaee809da226cbfbd883e">&#9670;&#160;</a></span>randgen_xoshiro() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::randgen_xoshiro </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pseudorandom natural number using the xoshiro256++ pseudorandom number generation algorithm (wrapper) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Dummy parameter (needed for function signature) </td></tr>
    <tr><td class="paramname">state</td><td>The four 64-bit integer state of the algorithm which will be updated during the iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit pseudorandom number </dd></dl>

</div>
</div>
<a id="acf52f04c3a1cefbb9dabab21cac0abbb" name="acf52f04c3a1cefbb9dabab21cac0abbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf52f04c3a1cefbb9dabab21cac0abbb">&#9670;&#160;</a></span>root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the n-th root of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
    <tr><td class="paramname">n</td><td>The root number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The n-th real root of x</dd></dl>
<p>The Newton-Raphson method is used, limited by the <code>THEORETICA_OPTIMIZATION_NEWTON_ITER</code> macro constant. </p>

</div>
</div>
<a id="aa0649a3f31e025510b86dc7031c35f08" name="aa0649a3f31e025510b86dc7031c35f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0649a3f31e025510b86dc7031c35f08">&#9670;&#160;</a></span>root_bisect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::root_bisect </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code><a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#ab2a935663988c6d893699a70ddfd7bdd">OPTIMIZATION_BISECTION_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the root of a univariate real function using bisection inside a compact interval [a, b] where \(f(a) * f(b) &lt; 0\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The univariate real function. </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of the interval. </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of the interval. </td></tr>
    <tr><td class="paramname">tol</td><td>The minimum half-length of the bracketing interval to stop the algorithm, so that \(|x_r - x_l| \leq 2\epsilon\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate of the root of the function, or NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="a3e9e164e51e8ed01e633dfa36633e439" name="a3e9e164e51e8ed01e633dfa36633e439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9e164e51e8ed01e633dfa36633e439">&#9670;&#160;</a></span>root_chebyshev() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::root_chebyshev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1dual2.html">dual2</a>(*)(<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>guess</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code><a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#ab147579539a73fa79bc4e13852eb53e9">OPTIMIZATION_CHEBYSHEV_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a root of a univariate real function using Chebyshev's method, by computing the first and second derivatives using automatic differentiation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The real function to search the root of, with <a class="el" href="classtheoretica_1_1dual2.html" title="Second order dual number class.">dual2</a> argument and return value. </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess (defaults to 0). </td></tr>
    <tr><td class="paramname">tol</td><td>The \(\epsilon\) tolerance value to stop the algorithm when \(|f(x_n)| \leq \epsilon\). </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform, after which the algorithm is assumed to not have converged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate of the root of the function, or NaN if the algorithm did not converge.</dd></dl>
<p>Chebyshev's method can be derived by expanding the inverse of the function around the zero and truncating the series. This method is particularly suited when the derivatives of the function are easy to compute, especially when using automatic differentiation. For example, the exponential needs to be computed only once to evaluate the function and its derivatives. </p>

</div>
</div>
<a id="ac8f9fbd5182e447c5f16a48617e16aa4" name="ac8f9fbd5182e447c5f16a48617e16aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f9fbd5182e447c5f16a48617e16aa4">&#9670;&#160;</a></span>root_chebyshev() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::root_chebyshev </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>Df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>D2f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>guess</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code><a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#ab147579539a73fa79bc4e13852eb53e9">OPTIMIZATION_CHEBYSHEV_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a root of a univariate real function using Chebyshev's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The real function to search the root of. </td></tr>
    <tr><td class="paramname">Df</td><td>The first derivative of the function. </td></tr>
    <tr><td class="paramname">D2f</td><td>The second derivative of the function. </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess (defaults to 0). </td></tr>
    <tr><td class="paramname">tol</td><td>The \(\epsilon\) tolerance value to stop the algorithm when \(|f(x_n)| \leq \epsilon\). </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform, after which the algorithm is assumed to not have converged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate of the root of the function, or NaN if the algorithm did not converge.</dd></dl>
<p>Chebyshev's method can be derived by expanding the inverse of the function around the zero and truncating the series. This method is particularly suited when the derivatives of the function are easy to compute, especially when using automatic differentiation. </p>

</div>
</div>
<a id="a1bdea1fd73b49016d4d7bec2e829eb7e" name="a1bdea1fd73b49016d4d7bec2e829eb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdea1fd73b49016d4d7bec2e829eb7e">&#9670;&#160;</a></span>root_halley() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::root_halley </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1dual2.html">dual2</a>(*)(<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>guess</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code><a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#ae648762992e4710d0d7d2c9d01c0e66d">OPTIMIZATION_HALLEY_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a root of a univariate real function using Halley's method, leveraging automatic differentiation to compute the first and second derivatives of the function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The real function to search the root of, with <a class="el" href="classtheoretica_1_1dual2.html" title="Second order dual number class.">dual2</a> argument and return value. </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess (defaults to 0). </td></tr>
    <tr><td class="paramname">tol</td><td>The \(\epsilon\) tolerance value to stop the algorithm when \(|f(x_n)| &lt; \epsilon\). </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform, after which the algorithm is assumed to not have converged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate of the root of the function, or NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="a1feafa93b8400245b1004281f75ed39f" name="a1feafa93b8400245b1004281f75ed39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1feafa93b8400245b1004281f75ed39f">&#9670;&#160;</a></span>root_halley() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::root_halley </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>Df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>D2f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>guess</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code><a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#ae648762992e4710d0d7d2c9d01c0e66d">OPTIMIZATION_HALLEY_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a root of a univariate real function using Halley's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The real function to search the root of. </td></tr>
    <tr><td class="paramname">Df</td><td>The first derivative of the function. </td></tr>
    <tr><td class="paramname">D2f</td><td>The second derivative of the function. </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess (defaults to 0). </td></tr>
    <tr><td class="paramname">tol</td><td>The \(\epsilon\) tolerance value to stop the algorithm when \(|f(x_n)| \leq \epsilon\). </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform, after which the algorithm is assumed to not have converged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate of the root of the function, or NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="aa3de94cffc4e11a1a0fbaaa11db16d65" name="aa3de94cffc4e11a1a0fbaaa11db16d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3de94cffc4e11a1a0fbaaa11db16d65">&#9670;&#160;</a></span>root_itp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::root_itp </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code><a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n0</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>k1</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a root of a univariate real function using the ITP (Interpolate-Truncate-Project) method, by bracketing the zero inside a compact interval [a, b] where \(f(a) * f(b) &lt; 0\). </p>
<p>The \(k_2\) parameter is chosen to be 2, avoiding expensive operations while retaining good convergence. This method is the best choice when the function is not smooth and is expensive to compute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The univariate real function. </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of the interval. </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of the interval. </td></tr>
    <tr><td class="paramname">tol</td><td>The minimum half-length of the bracketing interval to stop the algorithm, so that \(|x_r - x_l| \leq 2\epsilon\). </td></tr>
    <tr><td class="paramname">n0</td><td>A hyper-parameter of the algorithm, must be zero or greater. Bigger values give more importance to the regula falsi estimate. </td></tr>
    <tr><td class="paramname">k1</td><td>A hyper-parameter of the algorithm, influences the truncation step (defaults to \(0.2 / (b - a)\), following the authors' results). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate of the root of the function, or NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="aefd038a12f3d962ecf4ee8c63ae0a22e" name="aefd038a12f3d962ecf4ee8c63ae0a22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd038a12f3d962ecf4ee8c63ae0a22e">&#9670;&#160;</a></span>root_jarrat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::root_jarrat </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>Df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>guess</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code><a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#a10e44603eb761970ec19fd740bda6c21">OPTIMIZATION_JARRAT_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a root of a univariate real function using Jarrat's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The real function to search the root of. </td></tr>
    <tr><td class="paramname">Df</td><td>The first derivative of the function. </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess (defaults to 0). </td></tr>
    <tr><td class="paramname">tol</td><td>The \(\epsilon\) tolerance value to stop the algorithm when \(|f(x_n)| \leq \epsilon\). </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform, after which the algorithm is assumed to not have converged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate of the root of the function, or NaN if the algorithm did not converge.</dd></dl>
<p>Jarrat's method is a 4-th order method which is particularly suited when the derivative of the function is less computationally expensive than the function itself, like in the case of integrals. This method does not have an overload using automatic differentiation as it would hinder the performance benefit. </p>

</div>
</div>
<a id="a33ab9446feae0a1abf496061fae55d99" name="a33ab9446feae0a1abf496061fae55d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ab9446feae0a1abf496061fae55d99">&#9670;&#160;</a></span>root_newton() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type  = real, typename ComplexFunction  = std::function&lt;complex&lt;Type&gt;(complex&lt;Type&gt;)&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; Type &gt; theoretica::root_newton </td>
          <td>(</td>
          <td class="paramtype">ComplexFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComplexFunction&#160;</td>
          <td class="paramname"><em>Df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code><a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#ac83f2fa2a615e5fe6bf4acafa0549c3f">OPTIMIZATION_NEWTON_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a root of a complex function using Newton's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The complex function to search the root of. </td></tr>
    <tr><td class="paramname">df</td><td>The derivative of the function. </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess (defaults to 0). </td></tr>
    <tr><td class="paramname">tol</td><td>The \(\epsilon\) tolerance value to stop the algorithm when \(|f(z_n)|^2 \leq \epsilon^2\). </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations before stopping the algorithm (defaults to OPTIMIZATION_NEWTON_ITER). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate of the root of the function, or a complex NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="a13f0ff1bc27c68e40b1da5c870e1b15e" name="a13f0ff1bc27c68e40b1da5c870e1b15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f0ff1bc27c68e40b1da5c870e1b15e">&#9670;&#160;</a></span>root_newton() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::root_newton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1dual.html">dual</a>(*)(<a class="el" href="classtheoretica_1_1dual.html">dual</a>)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>guess</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code><a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#ac83f2fa2a615e5fe6bf4acafa0549c3f">OPTIMIZATION_NEWTON_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a root of a univariate real function using Newton's method, computing the derivative using automatic differentiation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The real function to search the root of, with dual argument and return value. </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess (defaults to 0). </td></tr>
    <tr><td class="paramname">tol</td><td>The \(\epsilon\) tolerance value to stop the algorithm when \(|f(x_n)| \leq \epsilon\). </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform, after which the algorithm is assumed to not have converged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate of the root of the function, or NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="a12682ec4d92c0ad2c459f7a1ae2bfda4" name="a12682ec4d92c0ad2c459f7a1ae2bfda4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12682ec4d92c0ad2c459f7a1ae2bfda4">&#9670;&#160;</a></span>root_newton() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::root_newton </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>Df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>guess</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code><a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#ac83f2fa2a615e5fe6bf4acafa0549c3f">OPTIMIZATION_NEWTON_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a root of a univariate real function using Newton's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The real function to search the root of. </td></tr>
    <tr><td class="paramname">Df</td><td>The derivative of the function. </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess (defaults to 0). </td></tr>
    <tr><td class="paramname">tol</td><td>The \(\epsilon\) tolerance value to stop the algorithm when \(|f(x_n)| \leq \epsilon\). </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform, after which the algorithm is assumed to not have converged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate of the root of the function, or NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="ab9662690d148c3037300c4f34c6c9d07" name="ab9662690d148c3037300c4f34c6c9d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9662690d148c3037300c4f34c6c9d07">&#9670;&#160;</a></span>root_ostrowski()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::root_ostrowski </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>Df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>guess</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code><a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#a6a8f4ef82e19e3dc1b382c03df5d15f9">OPTIMIZATION_OSTROWSKI_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a root of a univariate real function using Ostrowski's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The real function to search the root of. </td></tr>
    <tr><td class="paramname">Df</td><td>The first derivative of the function. </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess (defaults to 0). </td></tr>
    <tr><td class="paramname">tol</td><td>The \(\epsilon\) tolerance value to stop the algorithm when \(|f(x_n)| \leq \epsilon\). </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform, after which the algorithm is assumed to not have converged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate of the root of the function, or NaN if the algorithm did not converge.</dd></dl>
<p>Ostrowski's method is a 4-th order method using 2 function evaluations and 1 function evaluation. It combines a Newton step with a corrective coefficient. This method does not have an overload using automatic differentiation as it would hinder the performance benefit. </p>

</div>
</div>
<a id="aafa127bcc16e700cfee3ae2105df3307" name="aafa127bcc16e700cfee3ae2105df3307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa127bcc16e700cfee3ae2105df3307">&#9670;&#160;</a></span>root_steffensen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::root_steffensen </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>guess</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code><a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#ab4d71500ca8667ee14c30bc90605db9d">OPTIMIZATION_STEFFENSEN_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a root of a univariate real function using Steffensen's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The real function to search the root of. </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess (defaults to 0). </td></tr>
    <tr><td class="paramname">tol</td><td>The \(\epsilon\) tolerance value to stop the algorithm when \(|f(x_n)| \leq \epsilon\). </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform, after which the algorithm is assumed to not have converged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinate of the root of the function, or NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="adabba19eeae5346a421f26e13e6a7e89" name="adabba19eeae5346a421f26e13e6a7e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabba19eeae5346a421f26e13e6a7e89">&#9670;&#160;</a></span>roots() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Field &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Field &gt; theoretica::roots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>steps</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the roots of a polynomial. </p>
<p>An interval bound on the roots is found using Cauchy's theorem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The polynomial to search the roots of. </td></tr>
    <tr><td class="paramname">steps</td><td>The number of steps to use (defaults to twice the polynomial's order). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the roots of the polynomial that were found. </dd></dl>

</div>
</div>
<a id="a602a45107ab7d777486a587e8f032ed0" name="a602a45107ab7d777486a587e8f032ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602a45107ab7d777486a587e8f032ed0">&#9670;&#160;</a></span>roots() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::roots </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code><a class="el" href="namespacetheoretica.html#a5effdda5848839bedf4a3aace62edc09">OPTIMIZATION_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>steps</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the roots of a univariate real function inside a given interval, by first searching for candidate intervals and then applying bracketing methods. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The real function to search the root of. </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of the search interval. </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of the search interval. </td></tr>
    <tr><td class="paramname">tol</td><td>The \(\epsilon\) tolerance value to stop the algorithm when \(|x_r - x_l| \leq 2\epsilon\). </td></tr>
    <tr><td class="paramname">steps</td><td>The number of sub-intervals to check for alternating sign (defaults to 10). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the roots of the function that were found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the number of roots inside the interval is completely unknown, using many more steps should be preferred, to ensure all roots are found. </dd></dl>

</div>
</div>
<a id="a891845bdf03e80b72925c16db545606f" name="a891845bdf03e80b72925c16db545606f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891845bdf03e80b72925c16db545606f">&#9670;&#160;</a></span>sample_mc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector  = std::vector&lt;real&gt;, typename Function  = std::function&lt;real(vec&lt;real&gt;)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vector theoretica::sample_mc </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structtheoretica_1_1pdf__sampler.html">pdf_sampler</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a Monte Carlo sample of values of a given function of arbitrary variables following the given distributions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function with argument <a class="el" href="classtheoretica_1_1vec.html">vec&lt;real&gt;</a> </td></tr>
    <tr><td class="paramname">rv</td><td>A vector of distribution samplers from the distributions of the random variables </td></tr>
    <tr><td class="paramname">N</td><td>The size of the sample </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sampled values </dd></dl>

</div>
</div>
<a id="ad61e39abd4fd4cd8cd83add5d0752e2f" name="ad61e39abd4fd4cd8cd83add5d0752e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61e39abd4fd4cd8cd83add5d0752e2f">&#9670;&#160;</a></span>sgn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int theoretica::sgn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sign of x (1 if positive, -1 if negative, 0 if null) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sign of x </dd></dl>

</div>
</div>
<a id="a8679d2642c8820e78e33f7aa3294f7eb" name="a8679d2642c8820e78e33f7aa3294f7eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8679d2642c8820e78e33f7aa3294f7eb">&#9670;&#160;</a></span>shuffle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void theoretica::shuffle </td>
          <td>(</td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rounds</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shuffle a set by exchanging random couples of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The set to shuffle (as a Vector with [] and .size() methods) </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">rounds</td><td>The number of pairs to exchange (defaults to (N - 1)^2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a76685197faa15403e24b836830cf5d" name="a7a76685197faa15403e24b836830cf5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a76685197faa15403e24b836830cf5d">&#9670;&#160;</a></span>sigmoid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sigmoid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sigmoid function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sigmoid function for x defined as \(\frac{1}{1 + e^{-x}}\) </dd></dl>

</div>
</div>
<a id="a2dbb7d4dc0c7a5138e34212ddd8dcda2" name="a2dbb7d4dc0c7a5138e34212ddd8dcda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dbb7d4dc0c7a5138e34212ddd8dcda2">&#9670;&#160;</a></span>sin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::sin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computer the complex sine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c2ea0b1258dfe34df321901707d1808" name="a2c2ea0b1258dfe34df321901707d1808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2ea0b1258dfe34df321901707d1808">&#9670;&#160;</a></span>sin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sine of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sine of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fsin</code> instruction will be used. </p>

</div>
</div>
<a id="a1efe3bd7ff87719aab92b67cec535096" name="a1efe3bd7ff87719aab92b67cec535096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1efe3bd7ff87719aab92b67cec535096">&#9670;&#160;</a></span>sinc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sinc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the normalized sinc function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized sinc function for x defined as \(\frac{sin(\pi x)}{\pi x}\) </dd></dl>

</div>
</div>
<a id="a0650ea8e1435cc518e960bfcecf5b66e" name="a0650ea8e1435cc518e960bfcecf5b66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0650ea8e1435cc518e960bfcecf5b66e">&#9670;&#160;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sinh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hyperbolic sine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic sine of x</dd></dl>
<p>\(sinh = \frac{e^x - e^{-x}}{2}\) </p>

</div>
</div>
<a id="a42af84f096a0f9e11fdb72d13990bd52" name="a42af84f096a0f9e11fdb72d13990bd52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42af84f096a0f9e11fdb72d13990bd52">&#9670;&#160;</a></span>sqrt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex square root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2e4cf02f9bcb4caf5371ee05d67df8d" name="aa2e4cf02f9bcb4caf5371ee05d67df8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e4cf02f9bcb4caf5371ee05d67df8d">&#9670;&#160;</a></span>sqrt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the square root of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square root of x</dd></dl>
<p>Domain: [0, +inf] <br  />
The Newton-Raphson algorithm, optimized for the square root and limited by the <code>THEORETICA_OPTIMIZATION_NEWTON_ITER</code> macro constant, is used. Domain reduction to [0, 1] is applied to ensure convergence of the algorithm. On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fsqrt</code> instruction will be used. </p>

</div>
</div>
<a id="af13ddee06543aa9aa3deb827efd44f63" name="af13ddee06543aa9aa3deb827efd44f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13ddee06543aa9aa3deb827efd44f63">&#9670;&#160;</a></span>square() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::square </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the square of a complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a726a5e18c863dc41040f5df134553fa9" name="a726a5e18c863dc41040f5df134553fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726a5e18c863dc41040f5df134553fa9">&#9670;&#160;</a></span>square() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::square </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the square of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square of x</dd></dl>
<p>Domain: [-inf, +inf] </p>

</div>
</div>
<a id="a551e6c640e2580e8756526e015f2ad04" name="a551e6c640e2580e8756526e015f2ad04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551e6c640e2580e8756526e015f2ad04">&#9670;&#160;</a></span>sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector , std::enable_if_t&lt; has_real_elements&lt; Vector &gt;::value &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::sum </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sum of a vector of real values using pairwise summation to reduce round-off error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The vector of values to sum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec3305c4f7617c88a3e8ee4deb5b7ef0" name="aec3305c4f7617c88a3e8ee4deb5b7ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3305c4f7617c88a3e8ee4deb5b7ef0">&#9670;&#160;</a></span>sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::sum </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sum of a set of values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The vector of values to sum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a173a64c4f73cb7abd476b739005d94e7" name="a173a64c4f73cb7abd476b739005d94e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173a64c4f73cb7abd476b739005d94e7">&#9670;&#160;</a></span>sum_compensated()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sum_compensated </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sum of a set of values using the compensated Neumaier-Kahan-Babushka summation algorithm to reduce round-off error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The vector of real values to sum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a97cfad96b9bb73d76b8f5cc20f2896" name="a2a97cfad96b9bb73d76b8f5cc20f2896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a97cfad96b9bb73d76b8f5cc20f2896">&#9670;&#160;</a></span>sum_pairwise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sum_pairwise </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>begin</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>base_size</em> = <code>128</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sum of a set of values using pairwise summation to reduce round-off error. </p>
<p>The function does not check for validity of begin and end indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The vector of real values to sum </td></tr>
    <tr><td class="paramname">begin</td><td>The starting index of the sum, defaults to 0 </td></tr>
    <tr><td class="paramname">end</td><td>One plus the last index of the sum, defaults to X.size() </td></tr>
    <tr><td class="paramname">base_size</td><td>The size of the base case, defaults to 128 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc3702e8779681c1323f7a98f7f6a3cb" name="afc3702e8779681c1323f7a98f7f6a3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3702e8779681c1323f7a98f7f6a3cb">&#9670;&#160;</a></span>swap_bit_reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector , enable_vector&lt; Vector &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void theoretica::swap_bit_reverse </td>
          <td>(</td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the elements of a vector pair-wise, by exchanging elements with indices related by bit reversion (e.g. </p>
<p>\(110_2\) and \(011_2\)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The vector of elements to swap in-place </td></tr>
    <tr><td class="paramname">m</td><td>The maximum bit to consider when computing bit reversion </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92971816c6dda74903738b66ff69fb9c" name="a92971816c6dda74903738b66ff69fb9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92971816c6dda74903738b66ff69fb9c">&#9670;&#160;</a></span>tan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::tan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex tangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe9d9a32dc2c9f00de35c1b1a49b218e" name="abe9d9a32dc2c9f00de35c1b1a49b218e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9d9a32dc2c9f00de35c1b1a49b218e">&#9670;&#160;</a></span>tan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::tan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the tangent of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tangent of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fsincos</code> instruction will be used if supported by the compiler. </p>

</div>
</div>
<a id="aaf6b8fc4bb2609507cd1fae0f7d6c8a7" name="aaf6b8fc4bb2609507cd1fae0f7d6c8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6b8fc4bb2609507cd1fae0f7d6c8a7">&#9670;&#160;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::tanh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hyperbolic tangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic tangent of x </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetheoretica.html">theoretica</a></li>
    <li class="footer">Generated on Sat May 31 2025 14:28:38 for Theoretica by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
