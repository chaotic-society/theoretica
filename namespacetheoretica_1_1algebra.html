<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Theoretica: theoretica::algebra Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Theoretica
   </div>
   <div id="projectbrief">Mathematical Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacetheoretica_1_1algebra.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">theoretica::algebra Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Linear algebra routines.  
<a href="namespacetheoretica_1_1algebra.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a70f8a0fa365f11722ac6ca9d0086d8ba" id="r_a70f8a0fa365f11722ac6ca9d0086d8ba"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a70f8a0fa365f11722ac6ca9d0086d8ba"><td class="memTemplItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a70f8a0fa365f11722ac6ca9d0086d8ba">mat_error</a> (Matrix &amp;m)</td></tr>
<tr class="memdesc:a70f8a0fa365f11722ac6ca9d0086d8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite the given matrix with the error matrix with NaN values on the diagonal and zeroes everywhere else.  <br /></td></tr>
<tr class="separator:a70f8a0fa365f11722ac6ca9d0086d8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acedb7a30970499d5e6a1f7f6137b6451" id="r_acedb7a30970499d5e6a1f7f6137b6451"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:acedb7a30970499d5e6a1f7f6137b6451"><td class="memTemplItemLeft" align="right" valign="top">Vector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#acedb7a30970499d5e6a1f7f6137b6451">vec_error</a> (Vector &amp;v)</td></tr>
<tr class="memdesc:acedb7a30970499d5e6a1f7f6137b6451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite the given vector with the error vector with NaN values.  <br /></td></tr>
<tr class="separator:acedb7a30970499d5e6a1f7f6137b6451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdbfbad332a15de0037edb0116b6023" id="r_a2fdbfbad332a15de0037edb0116b6023"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a2fdbfbad332a15de0037edb0116b6023"><td class="memTemplItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a2fdbfbad332a15de0037edb0116b6023">make_identity</a> (Matrix &amp;m)</td></tr>
<tr class="memdesc:a2fdbfbad332a15de0037edb0116b6023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite a matrix with the identity matrix.  <br /></td></tr>
<tr class="separator:a2fdbfbad332a15de0037edb0116b6023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a2f381c9e87d82b362982d910f2111" id="r_a80a2f381c9e87d82b362982d910f2111"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a80a2f381c9e87d82b362982d910f2111"><td class="memTemplItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a80a2f381c9e87d82b362982d910f2111">mat_zeroes</a> (Matrix &amp;m)</td></tr>
<tr class="memdesc:a80a2f381c9e87d82b362982d910f2111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite a matrix with all zeroes.  <br /></td></tr>
<tr class="separator:a80a2f381c9e87d82b362982d910f2111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e8fa43f30568039c57c3f2996fcc97" id="r_ac5e8fa43f30568039c57c3f2996fcc97"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:ac5e8fa43f30568039c57c3f2996fcc97"><td class="memTemplItemLeft" align="right" valign="top">Vector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#ac5e8fa43f30568039c57c3f2996fcc97">vec_zeroes</a> (Vector &amp;v)</td></tr>
<tr class="memdesc:ac5e8fa43f30568039c57c3f2996fcc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite a vector with all zeroes.  <br /></td></tr>
<tr class="separator:ac5e8fa43f30568039c57c3f2996fcc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7340e67961ded04bd80d80771f353f4" id="r_aa7340e67961ded04bd80d80771f353f4"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:aa7340e67961ded04bd80d80771f353f4"><td class="memTemplItemLeft" align="right" valign="top">Matrix1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#aa7340e67961ded04bd80d80771f353f4">mat_copy</a> (Matrix1 &amp;dest, const Matrix2 &amp;src)</td></tr>
<tr class="memdesc:aa7340e67961ded04bd80d80771f353f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a matrix by overwriting another.  <br /></td></tr>
<tr class="separator:aa7340e67961ded04bd80d80771f353f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425738669ab6decff8d928400d19c82f" id="r_a425738669ab6decff8d928400d19c82f"><td class="memTemplParams" colspan="2">template&lt;typename Vector1 , typename Vector2 &gt; </td></tr>
<tr class="memitem:a425738669ab6decff8d928400d19c82f"><td class="memTemplItemLeft" align="right" valign="top">Vector1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a425738669ab6decff8d928400d19c82f">vec_copy</a> (Vector1 &amp;dest, const Vector2 &amp;src)</td></tr>
<tr class="memdesc:a425738669ab6decff8d928400d19c82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a vector by overwriting another.  <br /></td></tr>
<tr class="separator:a425738669ab6decff8d928400d19c82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c75a96ed813cfbcb8b116024a318995" id="r_a6c75a96ed813cfbcb8b116024a318995"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a6c75a96ed813cfbcb8b116024a318995"><td class="memTemplItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a6c75a96ed813cfbcb8b116024a318995">mat_swap_rows</a> (Matrix &amp;A, unsigned int row1, unsigned int row2)</td></tr>
<tr class="memdesc:a6c75a96ed813cfbcb8b116024a318995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two rows of a matrix, given the matrix and the two indices of the rows.  <br /></td></tr>
<tr class="separator:a6c75a96ed813cfbcb8b116024a318995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1ea1fa7d1c6976640fceb455684b16" id="r_a3a1ea1fa7d1c6976640fceb455684b16"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a3a1ea1fa7d1c6976640fceb455684b16"><td class="memTemplItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a3a1ea1fa7d1c6976640fceb455684b16">mat_swap_cols</a> (Matrix &amp;A, unsigned int col1, unsigned int col2)</td></tr>
<tr class="memdesc:a3a1ea1fa7d1c6976640fceb455684b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two columns of a matrix, given the matrix and the two indices of the columns.  <br /></td></tr>
<tr class="separator:a3a1ea1fa7d1c6976640fceb455684b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c5d22e34332185f2eea0b23de4a9ac" id="r_a92c5d22e34332185f2eea0b23de4a9ac"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Type  = matrix_element_t&lt;Matrix&gt;&gt; </td></tr>
<tr class="memitem:a92c5d22e34332185f2eea0b23de4a9ac"><td class="memTemplItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a92c5d22e34332185f2eea0b23de4a9ac">mat_shift_diagonal</a> (Matrix &amp;A, const Type &amp;sigma)</td></tr>
<tr class="memdesc:a92c5d22e34332185f2eea0b23de4a9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the diagonal of a matrix by the given amount, overwriting the matrix itself, as \((A + \sigma I)\).  <br /></td></tr>
<tr class="separator:a92c5d22e34332185f2eea0b23de4a9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838277b2f0e59831f5f0b3f5d388c925" id="r_a838277b2f0e59831f5f0b3f5d388c925"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a838277b2f0e59831f5f0b3f5d388c925"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a838277b2f0e59831f5f0b3f5d388c925">pair_inner_product</a> (const Type &amp;v_i, const Type &amp;w_i)</td></tr>
<tr class="memdesc:a838277b2f0e59831f5f0b3f5d388c925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the contribution of the inner product between a pair of elements of two vectors, automatically selecting whether to compute the conjugate or not.  <br /></td></tr>
<tr class="separator:a838277b2f0e59831f5f0b3f5d388c925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7925dcde9e30aaf83965f094c79199ac" id="r_a7925dcde9e30aaf83965f094c79199ac"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a7925dcde9e30aaf83965f094c79199ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a7925dcde9e30aaf83965f094c79199ac">pair_inner_product</a> (const <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; Type &gt; &amp;v_i, const <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; Type &gt; &amp;w_i)</td></tr>
<tr class="memdesc:a7925dcde9e30aaf83965f094c79199ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the contribution of the inner product between a pair of elements of two vectors, automatically selecting whether to compute the conjugate or not.  <br /></td></tr>
<tr class="separator:a7925dcde9e30aaf83965f094c79199ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bea2f231e34937ede290fd070f7f21" id="r_a90bea2f231e34937ede290fd070f7f21"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a90bea2f231e34937ede290fd070f7f21"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a90bea2f231e34937ede290fd070f7f21">sqr_norm</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:a90bea2f231e34937ede290fd070f7f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the square of the Euclidean/Hermitian norm of the given vector.  <br /></td></tr>
<tr class="separator:a90bea2f231e34937ede290fd070f7f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1521a586075b668b4a8765dadcdd1a3" id="r_ae1521a586075b668b4a8765dadcdd1a3"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:ae1521a586075b668b4a8765dadcdd1a3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#ae1521a586075b668b4a8765dadcdd1a3">norm</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:ae1521a586075b668b4a8765dadcdd1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Euclidean/Hermitian norm of the given vector.  <br /></td></tr>
<tr class="separator:ae1521a586075b668b4a8765dadcdd1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f76287e1f911f7223ebf865ee16eea" id="r_af3f76287e1f911f7223ebf865ee16eea"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:af3f76287e1f911f7223ebf865ee16eea"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#af3f76287e1f911f7223ebf865ee16eea">normalize</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:af3f76287e1f911f7223ebf865ee16eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the normalized vector.  <br /></td></tr>
<tr class="separator:af3f76287e1f911f7223ebf865ee16eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b62d14e94e493460b4eb6b9c9b716ae" id="r_a3b62d14e94e493460b4eb6b9c9b716ae"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a3b62d14e94e493460b4eb6b9c9b716ae"><td class="memTemplItemLeft" align="right" valign="top">Vector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a3b62d14e94e493460b4eb6b9c9b716ae">make_normalized</a> (Vector &amp;v)</td></tr>
<tr class="memdesc:a3b62d14e94e493460b4eb6b9c9b716ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a given vector overwriting it.  <br /></td></tr>
<tr class="separator:a3b62d14e94e493460b4eb6b9c9b716ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78eaf414de804da51ccf4ee4dc20d31c" id="r_a78eaf414de804da51ccf4ee4dc20d31c"><td class="memTemplParams" colspan="2">template&lt;typename Vector1 , typename Vector2 &gt; </td></tr>
<tr class="memitem:a78eaf414de804da51ccf4ee4dc20d31c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a78eaf414de804da51ccf4ee4dc20d31c">dot</a> (const Vector1 &amp;v, const Vector2 &amp;w)</td></tr>
<tr class="memdesc:a78eaf414de804da51ccf4ee4dc20d31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot product between two vectors, using the Hermitian form if needed.  <br /></td></tr>
<tr class="separator:a78eaf414de804da51ccf4ee4dc20d31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038ef7f20afa9fbbdd052c020c90f581" id="r_a038ef7f20afa9fbbdd052c020c90f581"><td class="memTemplParams" colspan="2">template&lt;typename Vector1 , typename Vector2 &gt; </td></tr>
<tr class="memitem:a038ef7f20afa9fbbdd052c020c90f581"><td class="memTemplItemLeft" align="right" valign="top">Vector1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a038ef7f20afa9fbbdd052c020c90f581">cross</a> (const Vector1 &amp;v1, const Vector2 &amp;v2)</td></tr>
<tr class="memdesc:a038ef7f20afa9fbbdd052c020c90f581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cross product between two tridimensional vectors.  <br /></td></tr>
<tr class="separator:a038ef7f20afa9fbbdd052c020c90f581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe362b810eac7593d63e67afaaf66836" id="r_afe362b810eac7593d63e67afaaf66836"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename MatrixT  = Matrix&gt; </td></tr>
<tr class="memitem:afe362b810eac7593d63e67afaaf66836"><td class="memTemplItemLeft" align="right" valign="top">MatrixT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#afe362b810eac7593d63e67afaaf66836">transpose</a> (const Matrix &amp;m)</td></tr>
<tr class="memdesc:afe362b810eac7593d63e67afaaf66836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transpose of the given matrix.  <br /></td></tr>
<tr class="separator:afe362b810eac7593d63e67afaaf66836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60d6c05b8a2947cccc33d4dad1d8803" id="r_ab60d6c05b8a2947cccc33d4dad1d8803"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:ab60d6c05b8a2947cccc33d4dad1d8803"><td class="memTemplItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#ab60d6c05b8a2947cccc33d4dad1d8803">make_transposed</a> (Matrix &amp;m)</td></tr>
<tr class="memdesc:ab60d6c05b8a2947cccc33d4dad1d8803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose the given matrix.  <br /></td></tr>
<tr class="separator:ab60d6c05b8a2947cccc33d4dad1d8803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fb1b942d9ec2548b7677e67d2f9235" id="r_ac5fb1b942d9ec2548b7677e67d2f9235"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:ac5fb1b942d9ec2548b7677e67d2f9235"><td class="memTemplItemLeft" align="right" valign="top">Matrix1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#ac5fb1b942d9ec2548b7677e67d2f9235">transpose</a> (Matrix1 &amp;dest, const Matrix2 &amp;src)</td></tr>
<tr class="memdesc:ac5fb1b942d9ec2548b7677e67d2f9235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the transpose matrix and write the result to another matrix.  <br /></td></tr>
<tr class="separator:ac5fb1b942d9ec2548b7677e67d2f9235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27e1f7cb91803bcaa589262d38e32e5" id="r_ab27e1f7cb91803bcaa589262d38e32e5"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename MatrixT  = Matrix&gt; </td></tr>
<tr class="memitem:ab27e1f7cb91803bcaa589262d38e32e5"><td class="memTemplItemLeft" align="right" valign="top">MatrixT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#ab27e1f7cb91803bcaa589262d38e32e5">hermitian</a> (const Matrix &amp;m)</td></tr>
<tr class="memdesc:ab27e1f7cb91803bcaa589262d38e32e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the hermitian of the given matrix.  <br /></td></tr>
<tr class="separator:ab27e1f7cb91803bcaa589262d38e32e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5ae85e773f42a3d4dca948067f5324" id="r_afc5ae85e773f42a3d4dca948067f5324"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:afc5ae85e773f42a3d4dca948067f5324"><td class="memTemplItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#afc5ae85e773f42a3d4dca948067f5324">make_hermitian</a> (Matrix &amp;m)</td></tr>
<tr class="memdesc:afc5ae85e773f42a3d4dca948067f5324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hermitian of a given matrix and overwrite it.  <br /></td></tr>
<tr class="separator:afc5ae85e773f42a3d4dca948067f5324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d8810ef51e6d38c45132998b481740" id="r_af0d8810ef51e6d38c45132998b481740"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:af0d8810ef51e6d38c45132998b481740"><td class="memTemplItemLeft" align="right" valign="top">Matrix1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#af0d8810ef51e6d38c45132998b481740">hermitian</a> (Matrix1 &amp;dest, const Matrix2 &amp;src)</td></tr>
<tr class="memdesc:af0d8810ef51e6d38c45132998b481740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermitian (conjugate transpose) of a matrix.  <br /></td></tr>
<tr class="separator:af0d8810ef51e6d38c45132998b481740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc18f1cdbcf6eef1e543a54eec0b004" id="r_a2dc18f1cdbcf6eef1e543a54eec0b004"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a2dc18f1cdbcf6eef1e543a54eec0b004"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a2dc18f1cdbcf6eef1e543a54eec0b004">trace</a> (const Matrix &amp;m)</td></tr>
<tr class="memdesc:a2dc18f1cdbcf6eef1e543a54eec0b004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the trace of the given matrix.  <br /></td></tr>
<tr class="separator:a2dc18f1cdbcf6eef1e543a54eec0b004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84cf5d732779f650d7a6807177d71ffa" id="r_a84cf5d732779f650d7a6807177d71ffa"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a84cf5d732779f650d7a6807177d71ffa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a84cf5d732779f650d7a6807177d71ffa">diagonal_product</a> (const Matrix &amp;m)</td></tr>
<tr class="memdesc:a84cf5d732779f650d7a6807177d71ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of the elements of the main diagonal of a generic matrix.  <br /></td></tr>
<tr class="separator:a84cf5d732779f650d7a6807177d71ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1757fff7a273fbebc8c10e658e36e747" id="r_a1757fff7a273fbebc8c10e658e36e747"><td class="memTemplParams" colspan="2">template&lt;typename Field , typename Matrix &gt; </td></tr>
<tr class="memitem:a1757fff7a273fbebc8c10e658e36e747"><td class="memTemplItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a1757fff7a273fbebc8c10e658e36e747">mat_scalmul</a> (Field a, Matrix &amp;m)</td></tr>
<tr class="memdesc:a1757fff7a273fbebc8c10e658e36e747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a matrix by a scalar of any compatible type.  <br /></td></tr>
<tr class="separator:a1757fff7a273fbebc8c10e658e36e747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fd6e5c9bd2041ddc0d372f4fda6d70" id="r_a53fd6e5c9bd2041ddc0d372f4fda6d70"><td class="memTemplParams" colspan="2">template&lt;typename Field , typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:a53fd6e5c9bd2041ddc0d372f4fda6d70"><td class="memTemplItemLeft" align="right" valign="top">Matrix1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a53fd6e5c9bd2041ddc0d372f4fda6d70">mat_scalmul</a> (Matrix1 &amp;dest, Field a, const Matrix2 &amp;src)</td></tr>
<tr class="memdesc:a53fd6e5c9bd2041ddc0d372f4fda6d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a matrix by a scalar of any compatible type which can be cast to the type of element of the output matrix.  <br /></td></tr>
<tr class="separator:a53fd6e5c9bd2041ddc0d372f4fda6d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afceadb5165f258a031449bc262f66f73" id="r_afceadb5165f258a031449bc262f66f73"><td class="memTemplParams" colspan="2">template&lt;typename Field , typename Vector &gt; </td></tr>
<tr class="memitem:afceadb5165f258a031449bc262f66f73"><td class="memTemplItemLeft" align="right" valign="top">Vector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#afceadb5165f258a031449bc262f66f73">vec_scalmul</a> (Field a, Vector &amp;v)</td></tr>
<tr class="memdesc:afceadb5165f258a031449bc262f66f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector by a scalar of any compatible type.  <br /></td></tr>
<tr class="separator:afceadb5165f258a031449bc262f66f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b3fdeb09b24462b60c7b15cfcc1e2b" id="r_a60b3fdeb09b24462b60c7b15cfcc1e2b"><td class="memTemplParams" colspan="2">template&lt;typename Field , typename Vector1 , typename Vector2 &gt; </td></tr>
<tr class="memitem:a60b3fdeb09b24462b60c7b15cfcc1e2b"><td class="memTemplItemLeft" align="right" valign="top">Vector1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a60b3fdeb09b24462b60c7b15cfcc1e2b">vec_scalmul</a> (Vector1 &amp;dest, Field a, const Vector2 &amp;src)</td></tr>
<tr class="memdesc:a60b3fdeb09b24462b60c7b15cfcc1e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector by a scalar of any compatible type which can be cast to the type of element of the output vector.  <br /></td></tr>
<tr class="separator:a60b3fdeb09b24462b60c7b15cfcc1e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd35667d4c7efd0365456ac7f681f2c" id="r_a5cd35667d4c7efd0365456ac7f681f2c"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:a5cd35667d4c7efd0365456ac7f681f2c"><td class="memTemplItemLeft" align="right" valign="top">Vector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a5cd35667d4c7efd0365456ac7f681f2c">apply_transform</a> (const Matrix &amp;A, Vector &amp;v)</td></tr>
<tr class="memdesc:a5cd35667d4c7efd0365456ac7f681f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a matrix transformation to a vector and store the result in the vector.  <br /></td></tr>
<tr class="separator:a5cd35667d4c7efd0365456ac7f681f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539f9f16151e9fad1e53c653c252f522" id="r_a539f9f16151e9fad1e53c653c252f522"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:a539f9f16151e9fad1e53c653c252f522"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a539f9f16151e9fad1e53c653c252f522">transform</a> (const Matrix &amp;A, const Vector &amp;v)</td></tr>
<tr class="memdesc:a539f9f16151e9fad1e53c653c252f522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matrix transformation of a vector.  <br /></td></tr>
<tr class="separator:a539f9f16151e9fad1e53c653c252f522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5867fd83e4589708adb02545564200d" id="r_ab5867fd83e4589708adb02545564200d"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector1 , typename Vector2 &gt; </td></tr>
<tr class="memitem:ab5867fd83e4589708adb02545564200d"><td class="memTemplItemLeft" align="right" valign="top">Vector1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#ab5867fd83e4589708adb02545564200d">transform</a> (Vector1 &amp;res, const Matrix &amp;A, const Vector2 &amp;v)</td></tr>
<tr class="memdesc:ab5867fd83e4589708adb02545564200d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a matrix transformation to a vector and store the result in the vector.  <br /></td></tr>
<tr class="separator:ab5867fd83e4589708adb02545564200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0fb9692dbe481cc96fc7dea38f5fc5" id="r_a0e0fb9692dbe481cc96fc7dea38f5fc5"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:a0e0fb9692dbe481cc96fc7dea38f5fc5"><td class="memTemplItemLeft" align="right" valign="top">Matrix2 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a0e0fb9692dbe481cc96fc7dea38f5fc5">mat_sum</a> (Matrix1 &amp;A, const Matrix2 &amp;B)</td></tr>
<tr class="memdesc:a0e0fb9692dbe481cc96fc7dea38f5fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum two matrices and store the result in the first matrix.  <br /></td></tr>
<tr class="separator:a0e0fb9692dbe481cc96fc7dea38f5fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d386e7bd52acd0ecea1a5923777254" id="r_a04d386e7bd52acd0ecea1a5923777254"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 , typename Matrix3 &gt; </td></tr>
<tr class="memitem:a04d386e7bd52acd0ecea1a5923777254"><td class="memTemplItemLeft" align="right" valign="top">Matrix1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a04d386e7bd52acd0ecea1a5923777254">mat_sum</a> (Matrix1 &amp;res, const Matrix2 &amp;A, const Matrix3 &amp;B)</td></tr>
<tr class="memdesc:a04d386e7bd52acd0ecea1a5923777254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum two matrices and store the result in another matrix Equivalent to the operation res = A + B.  <br /></td></tr>
<tr class="separator:a04d386e7bd52acd0ecea1a5923777254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ec73f2d73bc746501ed0b5a6ed377b" id="r_a33ec73f2d73bc746501ed0b5a6ed377b"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:a33ec73f2d73bc746501ed0b5a6ed377b"><td class="memTemplItemLeft" align="right" valign="top">Matrix2 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a33ec73f2d73bc746501ed0b5a6ed377b">mat_diff</a> (Matrix1 &amp;A, const Matrix2 &amp;B)</td></tr>
<tr class="memdesc:a33ec73f2d73bc746501ed0b5a6ed377b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two matrices and store the result in the first matrix.  <br /></td></tr>
<tr class="separator:a33ec73f2d73bc746501ed0b5a6ed377b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af995b3382cb47c72000b14755d3eba76" id="r_af995b3382cb47c72000b14755d3eba76"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 , typename Matrix3 &gt; </td></tr>
<tr class="memitem:af995b3382cb47c72000b14755d3eba76"><td class="memTemplItemLeft" align="right" valign="top">Matrix1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#af995b3382cb47c72000b14755d3eba76">mat_diff</a> (Matrix1 &amp;res, const Matrix2 &amp;A, const Matrix3 &amp;B)</td></tr>
<tr class="memdesc:af995b3382cb47c72000b14755d3eba76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two matrices and store the result in another matrix Equivalent to the operation res = A - B.  <br /></td></tr>
<tr class="separator:af995b3382cb47c72000b14755d3eba76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da43216b89e292e7e09248a5a64bbc7" id="r_a9da43216b89e292e7e09248a5a64bbc7"><td class="memTemplParams" colspan="2">template&lt;typename Field1 , typename Matrix1 , typename Field2 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:a9da43216b89e292e7e09248a5a64bbc7"><td class="memTemplItemLeft" align="right" valign="top">Matrix2 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a9da43216b89e292e7e09248a5a64bbc7">mat_lincomb</a> (Field1 alpha, Matrix1 &amp;A, Field2 beta, const Matrix2 &amp;B)</td></tr>
<tr class="memdesc:a9da43216b89e292e7e09248a5a64bbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the linear combination of two matrices and store the result in the first matrix.  <br /></td></tr>
<tr class="separator:a9da43216b89e292e7e09248a5a64bbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac341a35e84e0817e9996cb1f68dc1d92" id="r_ac341a35e84e0817e9996cb1f68dc1d92"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Field1 , typename Matrix2 , typename Field2 , typename Matrix3 &gt; </td></tr>
<tr class="memitem:ac341a35e84e0817e9996cb1f68dc1d92"><td class="memTemplItemLeft" align="right" valign="top">Matrix1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#ac341a35e84e0817e9996cb1f68dc1d92">mat_lincomb</a> (Matrix1 &amp;res, Field1 alpha, const Matrix2 &amp;A, Field2 beta, const Matrix3 &amp;B)</td></tr>
<tr class="memdesc:ac341a35e84e0817e9996cb1f68dc1d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the linear combination of two matrices and store the result in the first matrix.  <br /></td></tr>
<tr class="separator:ac341a35e84e0817e9996cb1f68dc1d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fe225d79cff4f7b5b8edbdae04dd50" id="r_a78fe225d79cff4f7b5b8edbdae04dd50"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 , typename Matrix3  = Matrix1&gt; </td></tr>
<tr class="memitem:a78fe225d79cff4f7b5b8edbdae04dd50"><td class="memTemplItemLeft" align="right" valign="top">Matrix3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a78fe225d79cff4f7b5b8edbdae04dd50">mat_mul</a> (const Matrix1 &amp;A, const Matrix2 &amp;B)</td></tr>
<tr class="memdesc:a78fe225d79cff4f7b5b8edbdae04dd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two matrices and store the result in the first matrix, equivalent to the operation \(R = A B\).  <br /></td></tr>
<tr class="separator:a78fe225d79cff4f7b5b8edbdae04dd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ee34d97b633e5075732524a85d0ce0" id="r_a47ee34d97b633e5075732524a85d0ce0"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 , typename Matrix3 &gt; </td></tr>
<tr class="memitem:a47ee34d97b633e5075732524a85d0ce0"><td class="memTemplItemLeft" align="right" valign="top">Matrix1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a47ee34d97b633e5075732524a85d0ce0">mat_mul</a> (Matrix1 &amp;R, const Matrix2 &amp;A, const Matrix3 &amp;B)</td></tr>
<tr class="memdesc:a47ee34d97b633e5075732524a85d0ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two matrices and store the result in another matrix, equivalent to the operation \(R = A B\).  <br /></td></tr>
<tr class="separator:a47ee34d97b633e5075732524a85d0ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8c8a9cfcb525db569989486105e324" id="r_a0e8c8a9cfcb525db569989486105e324"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 , typename Matrix3  = Matrix1&gt; </td></tr>
<tr class="memitem:a0e8c8a9cfcb525db569989486105e324"><td class="memTemplItemLeft" align="right" valign="top">Matrix3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a0e8c8a9cfcb525db569989486105e324">mat_transpose_mul</a> (const Matrix1 &amp;A, const Matrix2 &amp;B)</td></tr>
<tr class="memdesc:a0e8c8a9cfcb525db569989486105e324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply the transpose of a matrix by another matrix, equivalent to the operation \(R = A^T B\).  <br /></td></tr>
<tr class="separator:a0e8c8a9cfcb525db569989486105e324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5409959842e07390e2834cc99139a5d" id="r_aa5409959842e07390e2834cc99139a5d"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 , typename Matrix3  = Matrix1&gt; </td></tr>
<tr class="memitem:aa5409959842e07390e2834cc99139a5d"><td class="memTemplItemLeft" align="right" valign="top">Matrix3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#aa5409959842e07390e2834cc99139a5d">mat_mul_transpose</a> (const Matrix1 &amp;A, const Matrix2 &amp;B)</td></tr>
<tr class="memdesc:aa5409959842e07390e2834cc99139a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a matrix by the transpose of another matrix, equivalent to the operation \(R = A B^T\).  <br /></td></tr>
<tr class="separator:aa5409959842e07390e2834cc99139a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ae546299bfa1f1e9c01af80ba48f43" id="r_a48ae546299bfa1f1e9c01af80ba48f43"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:a48ae546299bfa1f1e9c01af80ba48f43"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a48ae546299bfa1f1e9c01af80ba48f43">mat_equals</a> (const Matrix1 &amp;A, const Matrix2 &amp;B, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=10 *<a class="el" href="namespacetheoretica.html#aa34d8798921a9b3b78e885a455ff4211">MACH_EPSILON</a>)</td></tr>
<tr class="memdesc:a48ae546299bfa1f1e9c01af80ba48f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two matrices are equal.  <br /></td></tr>
<tr class="separator:a48ae546299bfa1f1e9c01af80ba48f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dfff35041d5071c7c44b10b3f00716" id="r_aa3dfff35041d5071c7c44b10b3f00716"><td class="memTemplParams" colspan="2">template&lt;typename Vector1 , typename Vector2 &gt; </td></tr>
<tr class="memitem:aa3dfff35041d5071c7c44b10b3f00716"><td class="memTemplItemLeft" align="right" valign="top">Vector2 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#aa3dfff35041d5071c7c44b10b3f00716">vec_sum</a> (Vector1 &amp;v1, const Vector2 &amp;v2)</td></tr>
<tr class="memdesc:aa3dfff35041d5071c7c44b10b3f00716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum two vectors and store the result in the first vector.  <br /></td></tr>
<tr class="separator:aa3dfff35041d5071c7c44b10b3f00716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d05776d64b85e0b2de6a6e3939c701" id="r_a26d05776d64b85e0b2de6a6e3939c701"><td class="memTemplParams" colspan="2">template&lt;typename Vector1 , typename Vector2 , typename Vector3 &gt; </td></tr>
<tr class="memitem:a26d05776d64b85e0b2de6a6e3939c701"><td class="memTemplItemLeft" align="right" valign="top">Vector1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a26d05776d64b85e0b2de6a6e3939c701">vec_sum</a> (Vector1 &amp;res, const Vector2 &amp;v1, const Vector3 &amp;v2)</td></tr>
<tr class="memdesc:a26d05776d64b85e0b2de6a6e3939c701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum two vectors and store the result in another vector Equivalent to the operation res = v1 + v2.  <br /></td></tr>
<tr class="separator:a26d05776d64b85e0b2de6a6e3939c701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4487895be628508f067a215df9de0e" id="r_aad4487895be628508f067a215df9de0e"><td class="memTemplParams" colspan="2">template&lt;typename Vector1 , typename Vector2 &gt; </td></tr>
<tr class="memitem:aad4487895be628508f067a215df9de0e"><td class="memTemplItemLeft" align="right" valign="top">Vector2 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#aad4487895be628508f067a215df9de0e">vec_diff</a> (Vector1 &amp;v1, const Vector2 &amp;v2)</td></tr>
<tr class="memdesc:aad4487895be628508f067a215df9de0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two vectors and store the result in the first vector.  <br /></td></tr>
<tr class="separator:aad4487895be628508f067a215df9de0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afcd5de93f3c5bb57f7a1964a768075" id="r_a6afcd5de93f3c5bb57f7a1964a768075"><td class="memTemplParams" colspan="2">template&lt;typename Vector1 , typename Vector2 , typename Vector3 &gt; </td></tr>
<tr class="memitem:a6afcd5de93f3c5bb57f7a1964a768075"><td class="memTemplItemLeft" align="right" valign="top">Vector1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a6afcd5de93f3c5bb57f7a1964a768075">vec_diff</a> (Vector1 &amp;res, const Vector2 &amp;v1, const Vector3 &amp;v2)</td></tr>
<tr class="memdesc:a6afcd5de93f3c5bb57f7a1964a768075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two vectors and store the result in another vector Equivalent to the operation res = v1 - v2.  <br /></td></tr>
<tr class="separator:a6afcd5de93f3c5bb57f7a1964a768075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab552f2067f23dfab8473ff098810d1" id="r_a1ab552f2067f23dfab8473ff098810d1"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a1ab552f2067f23dfab8473ff098810d1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a1ab552f2067f23dfab8473ff098810d1">is_square</a> (const Matrix &amp;m)</td></tr>
<tr class="memdesc:a1ab552f2067f23dfab8473ff098810d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix is square.  <br /></td></tr>
<tr class="separator:a1ab552f2067f23dfab8473ff098810d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f3fc72c395411ca964ef50dc6c8303" id="r_a58f3fc72c395411ca964ef50dc6c8303"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a58f3fc72c395411ca964ef50dc6c8303"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a58f3fc72c395411ca964ef50dc6c8303">is_diagonal</a> (const Matrix &amp;m, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=10 *<a class="el" href="namespacetheoretica.html#aa34d8798921a9b3b78e885a455ff4211">MACH_EPSILON</a>)</td></tr>
<tr class="memdesc:a58f3fc72c395411ca964ef50dc6c8303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix is diagonal.  <br /></td></tr>
<tr class="separator:a58f3fc72c395411ca964ef50dc6c8303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4752e001d3198f3be8ae8f05f4fb06bf" id="r_a4752e001d3198f3be8ae8f05f4fb06bf"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a4752e001d3198f3be8ae8f05f4fb06bf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a4752e001d3198f3be8ae8f05f4fb06bf">is_symmetric</a> (const Matrix &amp;m, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a431f69ddc5ada0242f703284a54726f9">ALGEBRA_ELEMENT_TOL</a>)</td></tr>
<tr class="memdesc:a4752e001d3198f3be8ae8f05f4fb06bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix is symmetric.  <br /></td></tr>
<tr class="separator:a4752e001d3198f3be8ae8f05f4fb06bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01182d050ae939b2fb0647806478882c" id="r_a01182d050ae939b2fb0647806478882c"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a01182d050ae939b2fb0647806478882c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a01182d050ae939b2fb0647806478882c">is_lower_triangular</a> (const Matrix &amp;m, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a431f69ddc5ada0242f703284a54726f9">ALGEBRA_ELEMENT_TOL</a>)</td></tr>
<tr class="memdesc:a01182d050ae939b2fb0647806478882c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix is lower triangular.  <br /></td></tr>
<tr class="separator:a01182d050ae939b2fb0647806478882c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580a1460c4ab6eb87cd12d461e0ff675" id="r_a580a1460c4ab6eb87cd12d461e0ff675"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a580a1460c4ab6eb87cd12d461e0ff675"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a580a1460c4ab6eb87cd12d461e0ff675">is_upper_triangular</a> (const Matrix &amp;m, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a431f69ddc5ada0242f703284a54726f9">ALGEBRA_ELEMENT_TOL</a>)</td></tr>
<tr class="memdesc:a580a1460c4ab6eb87cd12d461e0ff675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix is upper triangular.  <br /></td></tr>
<tr class="separator:a580a1460c4ab6eb87cd12d461e0ff675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e560ebb9321de24c7c29f568c5182b" id="r_a60e560ebb9321de24c7c29f568c5182b"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , enable_matrix&lt; Matrix &gt;  = true&gt; </td></tr>
<tr class="memitem:a60e560ebb9321de24c7c29f568c5182b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a60e560ebb9321de24c7c29f568c5182b">density</a> (const Matrix &amp;A, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=1<a class="el" href="namespacetheoretica.html#aa3c0a5082e6b4428b15b7b02d16eafc7">E</a>-12)</td></tr>
<tr class="memdesc:a60e560ebb9321de24c7c29f568c5182b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the density of a matrix, counting the proportion of non-zero (bigger in module than the given tolerance) elements with respect to the total number of elements.  <br /></td></tr>
<tr class="separator:a60e560ebb9321de24c7c29f568c5182b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec388888fe8bed059d86349d80aa5f0" id="r_a6ec388888fe8bed059d86349d80aa5f0"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , enable_matrix&lt; Matrix &gt;  = true&gt; </td></tr>
<tr class="memitem:a6ec388888fe8bed059d86349d80aa5f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a6ec388888fe8bed059d86349d80aa5f0">sparsity</a> (const Matrix &amp;A, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=1<a class="el" href="namespacetheoretica.html#aa3c0a5082e6b4428b15b7b02d16eafc7">E</a>-12)</td></tr>
<tr class="memdesc:a6ec388888fe8bed059d86349d80aa5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sparsity of a matrix, counting the proportion of zero (smaller in module than the given tolerance) elements with respect to the total number of elements.  <br /></td></tr>
<tr class="separator:a6ec388888fe8bed059d86349d80aa5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66aafc0be7602bcdbf7b09dd130ebc38" id="r_a66aafc0be7602bcdbf7b09dd130ebc38"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 , typename Matrix3 &gt; </td></tr>
<tr class="memitem:a66aafc0be7602bcdbf7b09dd130ebc38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a66aafc0be7602bcdbf7b09dd130ebc38">decompose_lu</a> (const Matrix1 &amp;A, Matrix2 &amp;L, Matrix3 &amp;U)</td></tr>
<tr class="memdesc:a66aafc0be7602bcdbf7b09dd130ebc38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a square matrix to two triangular matrices, L and U where L is lower and U is upper, so that \(A = LU\).  <br /></td></tr>
<tr class="separator:a66aafc0be7602bcdbf7b09dd130ebc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8eb412dcf657020ebe3d5b8ec25b1e8" id="r_af8eb412dcf657020ebe3d5b8ec25b1e8"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:af8eb412dcf657020ebe3d5b8ec25b1e8"><td class="memTemplItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#af8eb412dcf657020ebe3d5b8ec25b1e8">decompose_lu_inplace</a> (Matrix &amp;A)</td></tr>
<tr class="memdesc:af8eb412dcf657020ebe3d5b8ec25b1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a square matrix to two triangular matrices, L and U where L is lower and U is upper, so that \(A = LU\) overwriting the matrix A with the elements of both matrices, omitting the diagonal of L (equal to all ones).  <br /></td></tr>
<tr class="separator:af8eb412dcf657020ebe3d5b8ec25b1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752dce461a75811726c0f2c63fa0411a" id="r_a752dce461a75811726c0f2c63fa0411a"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a752dce461a75811726c0f2c63fa0411a"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a752dce461a75811726c0f2c63fa0411a">decompose_cholesky</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a752dce461a75811726c0f2c63fa0411a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a symmetric positive definite matrix into a triangular matrix so that \(A = L L^T\) using Cholesky decomposition.  <br /></td></tr>
<tr class="separator:a752dce461a75811726c0f2c63fa0411a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01947bf47e15390d8031eb2c78a9fc8" id="r_aa01947bf47e15390d8031eb2c78a9fc8"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:aa01947bf47e15390d8031eb2c78a9fc8"><td class="memTemplItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#aa01947bf47e15390d8031eb2c78a9fc8">decompose_cholesky_inplace</a> (Matrix &amp;A)</td></tr>
<tr class="memdesc:aa01947bf47e15390d8031eb2c78a9fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a symmetric positive definite matrix in-place, overwriting the starting matrix, without using additional space.  <br /></td></tr>
<tr class="separator:aa01947bf47e15390d8031eb2c78a9fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7074a581766dad1465f4ea1264c229" id="r_a9b7074a581766dad1465f4ea1264c229"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:a9b7074a581766dad1465f4ea1264c229"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a9b7074a581766dad1465f4ea1264c229">solve_triangular_lower</a> (const Matrix &amp;L, const Vector &amp;b)</td></tr>
<tr class="memdesc:a9b7074a581766dad1465f4ea1264c229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the linear system \(L \vec x = b\) for lower triangular \(L\).  <br /></td></tr>
<tr class="separator:a9b7074a581766dad1465f4ea1264c229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64a6205ec3c0bbddcdd3aee26aec6dd" id="r_ab64a6205ec3c0bbddcdd3aee26aec6dd"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:ab64a6205ec3c0bbddcdd3aee26aec6dd"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#ab64a6205ec3c0bbddcdd3aee26aec6dd">solve_triangular_upper</a> (const Matrix &amp;U, const Vector &amp;b)</td></tr>
<tr class="memdesc:ab64a6205ec3c0bbddcdd3aee26aec6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the linear system \(U \vec x = b\) for upper triangular \(U\).  <br /></td></tr>
<tr class="separator:ab64a6205ec3c0bbddcdd3aee26aec6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc85f89aafd490490d0a7b36bed8e15" id="r_a6fc85f89aafd490490d0a7b36bed8e15"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:a6fc85f89aafd490490d0a7b36bed8e15"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a6fc85f89aafd490490d0a7b36bed8e15">solve_triangular</a> (const Matrix &amp;T, const Vector &amp;b)</td></tr>
<tr class="memdesc:a6fc85f89aafd490490d0a7b36bed8e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the linear system \(T \vec x = b\) for triangular \(T\).  <br /></td></tr>
<tr class="separator:a6fc85f89aafd490490d0a7b36bed8e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45de7be9adda20b8c9f59a578ff46937" id="r_a45de7be9adda20b8c9f59a578ff46937"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:a45de7be9adda20b8c9f59a578ff46937"><td class="memTemplItemLeft" align="right" valign="top">Vector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a45de7be9adda20b8c9f59a578ff46937">solve_lu_inplace</a> (const Matrix &amp;A, Vector &amp;b)</td></tr>
<tr class="memdesc:a45de7be9adda20b8c9f59a578ff46937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the linear system \(A \vec x = \vec b\), finding \(\vec x\), where the matrix A has <b>already undergone in-place LU decomposition</b>.  <br /></td></tr>
<tr class="separator:a45de7be9adda20b8c9f59a578ff46937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc8b5c2fa93053f3370b22b5fad2089" id="r_a6dc8b5c2fa93053f3370b22b5fad2089"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:a6dc8b5c2fa93053f3370b22b5fad2089"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a6dc8b5c2fa93053f3370b22b5fad2089">solve_lu</a> (Matrix A, Vector b)</td></tr>
<tr class="memdesc:a6dc8b5c2fa93053f3370b22b5fad2089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the linear system \(A \vec x = \vec b\), finding \(\vec x\).  <br /></td></tr>
<tr class="separator:a6dc8b5c2fa93053f3370b22b5fad2089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea88b9c22e1b32d1a32519aa02ea4e4" id="r_a8ea88b9c22e1b32d1a32519aa02ea4e4"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 , typename Vector &gt; </td></tr>
<tr class="memitem:a8ea88b9c22e1b32d1a32519aa02ea4e4"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a8ea88b9c22e1b32d1a32519aa02ea4e4">solve_lu</a> (const Matrix1 &amp;L, const Matrix2 &amp;U, const Vector &amp;b)</td></tr>
<tr class="memdesc:a8ea88b9c22e1b32d1a32519aa02ea4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the LU decomposition of a matrix to solve its associated linear system, solving \(A \vec x = \vec b\) for \(\vec b\).  <br /></td></tr>
<tr class="separator:a8ea88b9c22e1b32d1a32519aa02ea4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b885344f6ad8216871eae18dd0a1d1" id="r_ad6b885344f6ad8216871eae18dd0a1d1"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:ad6b885344f6ad8216871eae18dd0a1d1"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#ad6b885344f6ad8216871eae18dd0a1d1">solve_cholesky</a> (const Matrix &amp;L, const Vector &amp;b)</td></tr>
<tr class="memdesc:ad6b885344f6ad8216871eae18dd0a1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a linear system \(A \vec x = \vec b\) defined by a symmetric positive definite matrix, using the Cholesky decomposition \(L\) constructed so that \(A = LL^T\).  <br /></td></tr>
<tr class="separator:ad6b885344f6ad8216871eae18dd0a1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d7736bbdcc4b5c721923592f6a65e4" id="r_a47d7736bbdcc4b5c721923592f6a65e4"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:a47d7736bbdcc4b5c721923592f6a65e4"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a47d7736bbdcc4b5c721923592f6a65e4">solve</a> (const Matrix &amp;A, const Vector &amp;b)</td></tr>
<tr class="memdesc:a47d7736bbdcc4b5c721923592f6a65e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the linear system \(A \vec x = \vec b\), finding \(\vec x\) using the best available algorithm.  <br /></td></tr>
<tr class="separator:a47d7736bbdcc4b5c721923592f6a65e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5dca1646577df0e8f2c74ee007a032" id="r_ada5dca1646577df0e8f2c74ee007a032"><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 &gt; </td></tr>
<tr class="memitem:ada5dca1646577df0e8f2c74ee007a032"><td class="memTemplItemLeft" align="right" valign="top">Matrix1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#ada5dca1646577df0e8f2c74ee007a032">inverse</a> (Matrix1 &amp;dest, const Matrix2 &amp;src)</td></tr>
<tr class="memdesc:ada5dca1646577df0e8f2c74ee007a032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the given matrix.  <br /></td></tr>
<tr class="separator:ada5dca1646577df0e8f2c74ee007a032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5adc77960e5924940603eb503c12828" id="r_aa5adc77960e5924940603eb503c12828"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename MatrixInv  = Matrix&gt; </td></tr>
<tr class="memitem:aa5adc77960e5924940603eb503c12828"><td class="memTemplItemLeft" align="right" valign="top">MatrixInv&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#aa5adc77960e5924940603eb503c12828">inverse</a> (const Matrix &amp;m)</td></tr>
<tr class="memdesc:aa5adc77960e5924940603eb503c12828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of the given matrix.  <br /></td></tr>
<tr class="separator:aa5adc77960e5924940603eb503c12828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8e7f8039577df122fd34d187792787" id="r_a1d8e7f8039577df122fd34d187792787"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a1d8e7f8039577df122fd34d187792787"><td class="memTemplItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a1d8e7f8039577df122fd34d187792787">invert</a> (Matrix &amp;m)</td></tr>
<tr class="memdesc:a1d8e7f8039577df122fd34d187792787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the given matrix and overwrite it.  <br /></td></tr>
<tr class="separator:a1d8e7f8039577df122fd34d187792787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ab2652982540b574dc6890f1af8c5d" id="r_a92ab2652982540b574dc6890f1af8c5d"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a92ab2652982540b574dc6890f1af8c5d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a92ab2652982540b574dc6890f1af8c5d">det</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a92ab2652982540b574dc6890f1af8c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the determinant of a square matrix.  <br /></td></tr>
<tr class="separator:a92ab2652982540b574dc6890f1af8c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90657bcb7de860059ab5c52087c5d37b" id="r_a90657bcb7de860059ab5c52087c5d37b"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:a90657bcb7de860059ab5c52087c5d37b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a90657bcb7de860059ab5c52087c5d37b">rayleigh_quotient</a> (const Matrix &amp;A, const Vector &amp;x)</td></tr>
<tr class="memdesc:a90657bcb7de860059ab5c52087c5d37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Rayleigh quotient \(\frac{x^T A x}{x^T x}\) of a vector with respect to a matrix.  <br /></td></tr>
<tr class="separator:a90657bcb7de860059ab5c52087c5d37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6035b384fb9c7f30c6e96f112925a0" id="r_a2c6035b384fb9c7f30c6e96f112925a0"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:a2c6035b384fb9c7f30c6e96f112925a0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a2c6035b384fb9c7f30c6e96f112925a0">eigenvalue_power</a> (const Matrix &amp;A, const Vector &amp;x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#af8b9679476be607282a44a7f7f8b38c4">ALGEBRA_EIGEN_TOL</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#ae203c518f0274c29d78167c457cac65b">ALGEBRA_EIGEN_ITER</a>)</td></tr>
<tr class="memdesc:a2c6035b384fb9c7f30c6e96f112925a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the biggest eigenvalue in module \(|\lambda_i|\) of a square matrix using the power method (Von Mises iteration).  <br /></td></tr>
<tr class="separator:a2c6035b384fb9c7f30c6e96f112925a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b050141618e40f336c4ef549ac96a4" id="r_a13b050141618e40f336c4ef549ac96a4"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector1 , typename Vector2  = Vector1&gt; </td></tr>
<tr class="memitem:a13b050141618e40f336c4ef549ac96a4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a13b050141618e40f336c4ef549ac96a4">eigenpair_power</a> (const Matrix &amp;A, const Vector1 &amp;x, Vector2 &amp;v, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#af8b9679476be607282a44a7f7f8b38c4">ALGEBRA_EIGEN_TOL</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#ae203c518f0274c29d78167c457cac65b">ALGEBRA_EIGEN_ITER</a>)</td></tr>
<tr class="memdesc:a13b050141618e40f336c4ef549ac96a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the biggest eigenvalue in module \(|\lambda_i|\) of a square matrix and its corresponding eigenvector (eigenpair), using the power method (Von Mises iteration).  <br /></td></tr>
<tr class="separator:a13b050141618e40f336c4ef549ac96a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fa83f097e3a9a5fa2abe41e90aa23c" id="r_af4fa83f097e3a9a5fa2abe41e90aa23c"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:af4fa83f097e3a9a5fa2abe41e90aa23c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#af4fa83f097e3a9a5fa2abe41e90aa23c">eigenvalue_inverse</a> (const Matrix &amp;A, const Vector &amp;x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#af8b9679476be607282a44a7f7f8b38c4">ALGEBRA_EIGEN_TOL</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#ae203c518f0274c29d78167c457cac65b">ALGEBRA_EIGEN_ITER</a>)</td></tr>
<tr class="memdesc:af4fa83f097e3a9a5fa2abe41e90aa23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the eigenvalue with the smallest inverse \(\frac{1}{|\lambda_i|}\) of a square matrix, using the inverse power method with parameter equal to 0.  <br /></td></tr>
<tr class="separator:af4fa83f097e3a9a5fa2abe41e90aa23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5fb558e9bab3673b71959bcf08aa6a" id="r_a2f5fb558e9bab3673b71959bcf08aa6a"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector1 , typename Vector2 &gt; </td></tr>
<tr class="memitem:a2f5fb558e9bab3673b71959bcf08aa6a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a2f5fb558e9bab3673b71959bcf08aa6a">eigenpair_inverse</a> (const Matrix &amp;A, const Vector1 &amp;x, Vector2 &amp;v, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#af8b9679476be607282a44a7f7f8b38c4">ALGEBRA_EIGEN_TOL</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#ae203c518f0274c29d78167c457cac65b">ALGEBRA_EIGEN_ITER</a>)</td></tr>
<tr class="memdesc:a2f5fb558e9bab3673b71959bcf08aa6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the eigenvalue with the smallest inverse \(\frac{1}{|\lambda_i|}\) of a square matrix and its corresponding eigenvector, using the inverse power method with parameter equal to 0.  <br /></td></tr>
<tr class="separator:a2f5fb558e9bab3673b71959bcf08aa6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ae9dadad96bc74a76b49f46cad90e2" id="r_a65ae9dadad96bc74a76b49f46cad90e2"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector , typename T  = matrix_element_t&lt;Matrix&gt;&gt; </td></tr>
<tr class="memitem:a65ae9dadad96bc74a76b49f46cad90e2"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a65ae9dadad96bc74a76b49f46cad90e2">eigenvector_inverse</a> (const Matrix &amp;A, const T &amp;lambda, const Vector &amp;x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#af8b9679476be607282a44a7f7f8b38c4">ALGEBRA_EIGEN_TOL</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#ae203c518f0274c29d78167c457cac65b">ALGEBRA_EIGEN_ITER</a>)</td></tr>
<tr class="memdesc:a65ae9dadad96bc74a76b49f46cad90e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the eigenvector associated with a given approximated eigenvalue using the inverse power method.  <br /></td></tr>
<tr class="separator:a65ae9dadad96bc74a76b49f46cad90e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858a7ed886d0fc9b2a484aed88186cae" id="r_a858a7ed886d0fc9b2a484aed88186cae"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector , typename T  = matrix_element_t&lt;Matrix&gt;&gt; </td></tr>
<tr class="memitem:a858a7ed886d0fc9b2a484aed88186cae"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a858a7ed886d0fc9b2a484aed88186cae">eigenvalue_rayleigh</a> (const Matrix &amp;A, const T &amp;lambda, const Vector &amp;x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#af8b9679476be607282a44a7f7f8b38c4">ALGEBRA_EIGEN_TOL</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#ae203c518f0274c29d78167c457cac65b">ALGEBRA_EIGEN_ITER</a>)</td></tr>
<tr class="memdesc:a858a7ed886d0fc9b2a484aed88186cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an eigenvalue of a square matrix using the Rayleigh quotient iteration method.  <br /></td></tr>
<tr class="separator:a858a7ed886d0fc9b2a484aed88186cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2af7de1123511d864c4531894d8417" id="r_a8b2af7de1123511d864c4531894d8417"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector1 , typename Vector2 , typename T  = matrix_element_t&lt;Matrix&gt;&gt; </td></tr>
<tr class="memitem:a8b2af7de1123511d864c4531894d8417"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a8b2af7de1123511d864c4531894d8417">eigenpair_rayleigh</a> (const Matrix &amp;A, const T &amp;lambda, const Vector1 &amp;x, Vector2 &amp;v, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#af8b9679476be607282a44a7f7f8b38c4">ALGEBRA_EIGEN_TOL</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#ae203c518f0274c29d78167c457cac65b">ALGEBRA_EIGEN_ITER</a>)</td></tr>
<tr class="memdesc:a8b2af7de1123511d864c4531894d8417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an eigenvalue of a square matrix and its corresponding eigenvector (eigenpair) using the Rayleigh quotient iteration method.  <br /></td></tr>
<tr class="separator:a8b2af7de1123511d864c4531894d8417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add67a433fe0cbfca717f7556afaabdbf" id="r_add67a433fe0cbfca717f7556afaabdbf"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:add67a433fe0cbfca717f7556afaabdbf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#add67a433fe0cbfca717f7556afaabdbf">lp_norm</a> (const Vector &amp;v, unsigned int p)</td></tr>
<tr class="memdesc:add67a433fe0cbfca717f7556afaabdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Norms.  <br /></td></tr>
<tr class="separator:add67a433fe0cbfca717f7556afaabdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517742cc82be888526f2e5c6f7836220" id="r_a517742cc82be888526f2e5c6f7836220"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a517742cc82be888526f2e5c6f7836220"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a517742cc82be888526f2e5c6f7836220">l1_norm</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:a517742cc82be888526f2e5c6f7836220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the l1 norm of a vector: \(\mathcal{l}^1(\vec v) = \Sigma_i \ |v_i|\).  <br /></td></tr>
<tr class="separator:a517742cc82be888526f2e5c6f7836220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec28ec5a0ac0dc055108a9d37fd5326" id="r_a0ec28ec5a0ac0dc055108a9d37fd5326"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a0ec28ec5a0ac0dc055108a9d37fd5326"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a0ec28ec5a0ac0dc055108a9d37fd5326">l2_norm</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:a0ec28ec5a0ac0dc055108a9d37fd5326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the l2 norm of a vector: \(\mathcal{l}^2(\vec v) = \sqrt{\Sigma_i \ v_i^2}\).  <br /></td></tr>
<tr class="separator:a0ec28ec5a0ac0dc055108a9d37fd5326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb07bbcc3f136d05ab51d06dc46052d9" id="r_abb07bbcc3f136d05ab51d06dc46052d9"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:abb07bbcc3f136d05ab51d06dc46052d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#abb07bbcc3f136d05ab51d06dc46052d9">linf_norm</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:abb07bbcc3f136d05ab51d06dc46052d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the linf norm of a vector: \(\mathcal{l}^{\infty}(\vec v) = max(|v_i|)\).  <br /></td></tr>
<tr class="separator:abb07bbcc3f136d05ab51d06dc46052d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e09c1648a8787bc459402860380dad4" id="r_a6e09c1648a8787bc459402860380dad4"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a6e09c1648a8787bc459402860380dad4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a6e09c1648a8787bc459402860380dad4">euclidean_distance</a> (const Vector &amp;v1, const Vector &amp;v2)</td></tr>
<tr class="memdesc:a6e09c1648a8787bc459402860380dad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distances.  <br /></td></tr>
<tr class="separator:a6e09c1648a8787bc459402860380dad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25b06886bf908eaf56d20bce02da5b2" id="r_ac25b06886bf908eaf56d20bce02da5b2"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:ac25b06886bf908eaf56d20bce02da5b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#ac25b06886bf908eaf56d20bce02da5b2">distance</a> (const Vector &amp;v1, const Vector &amp;v2)</td></tr>
<tr class="memdesc:ac25b06886bf908eaf56d20bce02da5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidean distance between two vectors: \(d(\vec v_1, \vec v_2) = \mathcal{l}^2(\vec v_1 - \vec v_2)\).  <br /></td></tr>
<tr class="separator:ac25b06886bf908eaf56d20bce02da5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326d624702e7b8c7645f917e6e8df946" id="r_a326d624702e7b8c7645f917e6e8df946"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a326d624702e7b8c7645f917e6e8df946">euclidean_distance</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:a326d624702e7b8c7645f917e6e8df946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidian distance between two real values: \(d(a, b) = |a - b|\).  <br /></td></tr>
<tr class="separator:a326d624702e7b8c7645f917e6e8df946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cfadd3815e357ab79c40213a556fd3" id="r_ab3cfadd3815e357ab79c40213a556fd3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab3cfadd3815e357ab79c40213a556fd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#ab3cfadd3815e357ab79c40213a556fd3">euclidean_distance</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z1, <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z2)</td></tr>
<tr class="memdesc:ab3cfadd3815e357ab79c40213a556fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidean distance between two complex numbers: \(d(z_1, z_2) = |z_1 - z_2|\).  <br /></td></tr>
<tr class="separator:ab3cfadd3815e357ab79c40213a556fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58e3f5a6b4d0db51bbeec5bfc789da1" id="r_ae58e3f5a6b4d0db51bbeec5bfc789da1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#ae58e3f5a6b4d0db51bbeec5bfc789da1">distance</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:ae58e3f5a6b4d0db51bbeec5bfc789da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidian distance between two values: \(d(a, b) = |a - b|\).  <br /></td></tr>
<tr class="separator:ae58e3f5a6b4d0db51bbeec5bfc789da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64de98c3ce227a917740f98db5a5a89" id="r_ae64de98c3ce227a917740f98db5a5a89"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae64de98c3ce227a917740f98db5a5a89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#ae64de98c3ce227a917740f98db5a5a89">distance</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z1, <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z2)</td></tr>
<tr class="memdesc:ae64de98c3ce227a917740f98db5a5a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidean distance between two complex numbers: \(d(z_1, z_2) = |z_1 - z_2|\).  <br /></td></tr>
<tr class="separator:ae64de98c3ce227a917740f98db5a5a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520f67f6985860e7cf39b31141b7bc32" id="r_a520f67f6985860e7cf39b31141b7bc32"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a520f67f6985860e7cf39b31141b7bc32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a520f67f6985860e7cf39b31141b7bc32">minkowski_distance</a> (const Vector &amp;v1, const Vector &amp;v2, unsigned int p)</td></tr>
<tr class="memdesc:a520f67f6985860e7cf39b31141b7bc32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Minkowski distance between two vectors: \(d(\vec v_1, \vec v_2) = \mathcal{l}^p(\vec v_1 - \vec v_2)\).  <br /></td></tr>
<tr class="separator:a520f67f6985860e7cf39b31141b7bc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22507b333d714ba60bd5045ea3c3adf" id="r_ae22507b333d714ba60bd5045ea3c3adf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#ae22507b333d714ba60bd5045ea3c3adf">minkowski_distance</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int p)</td></tr>
<tr class="memdesc:ae22507b333d714ba60bd5045ea3c3adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Minkowski distance between two real values: \(d(a, b) = \mathcal{l}^p(a - b)\).  <br /></td></tr>
<tr class="separator:ae22507b333d714ba60bd5045ea3c3adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf68fe2919fe81fba86b870912dad30b" id="r_adf68fe2919fe81fba86b870912dad30b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf68fe2919fe81fba86b870912dad30b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#adf68fe2919fe81fba86b870912dad30b">minkowski_distance</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z1, <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z2, unsigned int p)</td></tr>
<tr class="memdesc:adf68fe2919fe81fba86b870912dad30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Minkowski distance between two complex values: \(d(z_1, z_2) = \mathcal{l}^p(z_1 - z_2)\).  <br /></td></tr>
<tr class="separator:adf68fe2919fe81fba86b870912dad30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58980fd04564631dab6b2f76e0f0013c" id="r_a58980fd04564631dab6b2f76e0f0013c"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a58980fd04564631dab6b2f76e0f0013c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a58980fd04564631dab6b2f76e0f0013c">manhattan_distance</a> (const Vector &amp;v1, const Vector &amp;v2)</td></tr>
<tr class="memdesc:a58980fd04564631dab6b2f76e0f0013c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Manhattan distance between two vectors: \(d(\vec v_1, \vec v_2) = \mathcal{l}^1(\vec v_1 - \vec v_2)\).  <br /></td></tr>
<tr class="separator:a58980fd04564631dab6b2f76e0f0013c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda85103719a7a69d69670a8ae6dc13b" id="r_afda85103719a7a69d69670a8ae6dc13b"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:afda85103719a7a69d69670a8ae6dc13b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#afda85103719a7a69d69670a8ae6dc13b">chebyshev_distance</a> (const Vector &amp;v1, const Vector &amp;v2)</td></tr>
<tr class="memdesc:afda85103719a7a69d69670a8ae6dc13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Chebyshev distance between two vectors: \(d(\vec v_1, \vec v_2) = \mathcal{l}^{\infty}(\vec v_1 - \vec v_2)\).  <br /></td></tr>
<tr class="separator:afda85103719a7a69d69670a8ae6dc13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42adc6116acb2e08f4331f34d9f5ba45" id="r_a42adc6116acb2e08f4331f34d9f5ba45"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a42adc6116acb2e08f4331f34d9f5ba45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a42adc6116acb2e08f4331f34d9f5ba45">discrete_distance</a> (const Vector &amp;v1, const Vector &amp;v2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#aa34d8798921a9b3b78e885a455ff4211">MACH_EPSILON</a>)</td></tr>
<tr class="memdesc:a42adc6116acb2e08f4331f34d9f5ba45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the discrete distance between two vectors.  <br /></td></tr>
<tr class="separator:a42adc6116acb2e08f4331f34d9f5ba45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6ca28bf9594eb59ea71a3d5ddf3373" id="r_abc6ca28bf9594eb59ea71a3d5ddf3373"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:abc6ca28bf9594eb59ea71a3d5ddf3373"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#abc6ca28bf9594eb59ea71a3d5ddf3373">canberra_distance</a> (const Vector &amp;v1, const Vector &amp;v2)</td></tr>
<tr class="memdesc:abc6ca28bf9594eb59ea71a3d5ddf3373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Canberra distance between two vectors.  <br /></td></tr>
<tr class="separator:abc6ca28bf9594eb59ea71a3d5ddf3373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5df713bdfd130cf67acbc28bf38095" id="r_a7a5df713bdfd130cf67acbc28bf38095"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a7a5df713bdfd130cf67acbc28bf38095"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a7a5df713bdfd130cf67acbc28bf38095">cosine_distance</a> (const Vector &amp;v1, const Vector &amp;v2)</td></tr>
<tr class="memdesc:a7a5df713bdfd130cf67acbc28bf38095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine distance between two vectors.  <br /></td></tr>
<tr class="separator:a7a5df713bdfd130cf67acbc28bf38095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63fa32f52f7801f0a2ab570d9ea5cd4" id="r_af63fa32f52f7801f0a2ab570d9ea5cd4"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:af63fa32f52f7801f0a2ab570d9ea5cd4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#af63fa32f52f7801f0a2ab570d9ea5cd4">hamming_distance</a> (const Vector &amp;v1, const Vector &amp;v2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#aa34d8798921a9b3b78e885a455ff4211">MACH_EPSILON</a>)</td></tr>
<tr class="memdesc:af63fa32f52f7801f0a2ab570d9ea5cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Hamming distance between two vectors.  <br /></td></tr>
<tr class="separator:af63fa32f52f7801f0a2ab570d9ea5cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd28fad57af499af2e6684cb08bab273" id="r_acd28fad57af499af2e6684cb08bab273"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:acd28fad57af499af2e6684cb08bab273"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#acd28fad57af499af2e6684cb08bab273">identity</a> (unsigned int rows=0, unsigned int cols=0)</td></tr>
<tr class="memdesc:acd28fad57af499af2e6684cb08bab273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the identity matrix.  <br /></td></tr>
<tr class="separator:acd28fad57af499af2e6684cb08bab273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08fe667743b70ad522893dca767f1ef" id="r_ac08fe667743b70ad522893dca767f1ef"><td class="memTemplParams" colspan="2">template&lt;typename Vector , typename Matrix &gt; </td></tr>
<tr class="memitem:ac08fe667743b70ad522893dca767f1ef"><td class="memTemplItemLeft" align="right" valign="top">Matrix &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#ac08fe667743b70ad522893dca767f1ef">diagonal</a> (Matrix &amp;res, const Vector &amp;v)</td></tr>
<tr class="memdesc:ac08fe667743b70ad522893dca767f1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix with the given vector as diagonal and zeroes everywhere else, overwriting the given matrix.  <br /></td></tr>
<tr class="separator:ac08fe667743b70ad522893dca767f1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30801ece0c3185cc1da7d02f6e339de1" id="r_a30801ece0c3185cc1da7d02f6e339de1"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:a30801ece0c3185cc1da7d02f6e339de1"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a30801ece0c3185cc1da7d02f6e339de1">diagonal</a> (const Vector &amp;v, unsigned int rows=0, unsigned int cols=0)</td></tr>
<tr class="memdesc:a30801ece0c3185cc1da7d02f6e339de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the a matrix with the given diagonal.  <br /></td></tr>
<tr class="separator:a30801ece0c3185cc1da7d02f6e339de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea5d17fa90dc48629d2028208e4b8d1" id="r_aeea5d17fa90dc48629d2028208e4b8d1"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:aeea5d17fa90dc48629d2028208e4b8d1"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#aeea5d17fa90dc48629d2028208e4b8d1">translation</a> (const Vector &amp;v, unsigned int rows=0, unsigned int cols=0)</td></tr>
<tr class="memdesc:aeea5d17fa90dc48629d2028208e4b8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a translation matrix, that is, an NxN matrix which describes a translation in N-1 dimensions.  <br /></td></tr>
<tr class="separator:aeea5d17fa90dc48629d2028208e4b8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f892f84cf60902500fc4a4f114f8fe" id="r_a38f892f84cf60902500fc4a4f114f8fe"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a38f892f84cf60902500fc4a4f114f8fe"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a38f892f84cf60902500fc4a4f114f8fe">rotation_2d</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theta, unsigned int rows=0, unsigned int cols=0)</td></tr>
<tr class="memdesc:a38f892f84cf60902500fc4a4f114f8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representing a 2D rotation.  <br /></td></tr>
<tr class="separator:a38f892f84cf60902500fc4a4f114f8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc19e58fd39649b8e9d2c48a2d7fa90e" id="r_abc19e58fd39649b8e9d2c48a2d7fa90e"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:abc19e58fd39649b8e9d2c48a2d7fa90e"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#abc19e58fd39649b8e9d2c48a2d7fa90e">rotation_3d</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theta, const Vector &amp;axis, unsigned int rows=0, unsigned int cols=0)</td></tr>
<tr class="memdesc:abc19e58fd39649b8e9d2c48a2d7fa90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representing a 3D rotation around a given axis.  <br /></td></tr>
<tr class="separator:abc19e58fd39649b8e9d2c48a2d7fa90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e41df03a4e0f1273b41aea2fc1dee3a" id="r_a7e41df03a4e0f1273b41aea2fc1dee3a"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a7e41df03a4e0f1273b41aea2fc1dee3a"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a7e41df03a4e0f1273b41aea2fc1dee3a">rotation_3d_xaxis</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theta, unsigned int rows=0, unsigned int cols=0)</td></tr>
<tr class="memdesc:a7e41df03a4e0f1273b41aea2fc1dee3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representing a 3D rotation around the x axis.  <br /></td></tr>
<tr class="separator:a7e41df03a4e0f1273b41aea2fc1dee3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d11b57ca82a631907f4eb1b1d67438" id="r_ab5d11b57ca82a631907f4eb1b1d67438"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:ab5d11b57ca82a631907f4eb1b1d67438"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#ab5d11b57ca82a631907f4eb1b1d67438">rotation_3d_yaxis</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theta, unsigned int rows=0, unsigned int cols=0)</td></tr>
<tr class="memdesc:ab5d11b57ca82a631907f4eb1b1d67438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representing a 3D rotation around the y axis.  <br /></td></tr>
<tr class="separator:ab5d11b57ca82a631907f4eb1b1d67438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb980ed1301d1e78fc2232181d93b9a" id="r_acfb980ed1301d1e78fc2232181d93b9a"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:acfb980ed1301d1e78fc2232181d93b9a"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#acfb980ed1301d1e78fc2232181d93b9a">rotation_3d_zaxis</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theta, unsigned int rows=0, unsigned int cols=0)</td></tr>
<tr class="memdesc:acfb980ed1301d1e78fc2232181d93b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representing a 3D rotation around the z axis.  <br /></td></tr>
<tr class="separator:acfb980ed1301d1e78fc2232181d93b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ff5243f09e983bb1e391a80abfa2b1" id="r_ae7ff5243f09e983bb1e391a80abfa2b1"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:ae7ff5243f09e983bb1e391a80abfa2b1"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#ae7ff5243f09e983bb1e391a80abfa2b1">perspective</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> left, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> right, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> bottom, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> top, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> near, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> far, unsigned int rows=0, unsigned int cols=0)</td></tr>
<tr class="memdesc:ae7ff5243f09e983bb1e391a80abfa2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a perspective projection matrix with adjustable view volume boundaries.  <br /></td></tr>
<tr class="separator:ae7ff5243f09e983bb1e391a80abfa2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46e373f6bb911ece83eb74a9d2cbeb7" id="r_ab46e373f6bb911ece83eb74a9d2cbeb7"><td class="memTemplParams" colspan="2"><a id="ab46e373f6bb911ece83eb74a9d2cbeb7" name="ab46e373f6bb911ece83eb74a9d2cbeb7"></a>
template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:ab46e373f6bb911ece83eb74a9d2cbeb7"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>perspective_fov</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> fov, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> aspect, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> near, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> far, unsigned int rows=0, unsigned int cols=0)</td></tr>
<tr class="memdesc:ab46e373f6bb911ece83eb74a9d2cbeb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a perspective projection matrix, using the Field of View as parameter. <br /></td></tr>
<tr class="separator:ab46e373f6bb911ece83eb74a9d2cbeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca924f650d8b397b61d252dc01c71826" id="r_aca924f650d8b397b61d252dc01c71826"><td class="memTemplParams" colspan="2"><a id="aca924f650d8b397b61d252dc01c71826" name="aca924f650d8b397b61d252dc01c71826"></a>
template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:aca924f650d8b397b61d252dc01c71826"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ortho</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> left, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> right, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> bottom, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> top, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> near, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> far, unsigned int rows=0, unsigned int cols=0)</td></tr>
<tr class="memdesc:aca924f650d8b397b61d252dc01c71826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an orthogonal projection matrix. <br /></td></tr>
<tr class="separator:aca924f650d8b397b61d252dc01c71826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2796454efe36f2b64f6f813113ff4830" id="r_a2796454efe36f2b64f6f813113ff4830"><td class="memTemplParams" colspan="2"><a id="a2796454efe36f2b64f6f813113ff4830" name="a2796454efe36f2b64f6f813113ff4830"></a>
template&lt;typename Matrix , typename Vector1 , typename Vector2 , typename Vector3 &gt; </td></tr>
<tr class="memitem:a2796454efe36f2b64f6f813113ff4830"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>look_at</b> (Vector1 camera, Vector2 target, Vector3 up)</td></tr>
<tr class="memdesc:a2796454efe36f2b64f6f813113ff4830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a transformation matrix that points the field of view towards a given point from the &lt;camera&gt; point. <br /></td></tr>
<tr class="separator:a2796454efe36f2b64f6f813113ff4830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e77b387067938a20b4da8bdf642718" id="r_a02e77b387067938a20b4da8bdf642718"><td class="memTemplParams" colspan="2"><a id="a02e77b387067938a20b4da8bdf642718" name="a02e77b387067938a20b4da8bdf642718"></a>
template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a02e77b387067938a20b4da8bdf642718"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>symplectic</b> (unsigned int rows=0, unsigned int cols=0)</td></tr>
<tr class="memdesc:a02e77b387067938a20b4da8bdf642718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a NxN symplectic matrix where N is even. <br /></td></tr>
<tr class="separator:a02e77b387067938a20b4da8bdf642718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8959e6c5653f2a821935ca4a1d4cd2" id="r_a6d8959e6c5653f2a821935ca4a1d4cd2"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a6d8959e6c5653f2a821935ca4a1d4cd2"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a6d8959e6c5653f2a821935ca4a1d4cd2">hilbert</a> (unsigned int rows=0)</td></tr>
<tr class="memdesc:a6d8959e6c5653f2a821935ca4a1d4cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the Hilbert matrix of arbitrary dimension.  <br /></td></tr>
<tr class="separator:a6d8959e6c5653f2a821935ca4a1d4cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517bdd1d7ac545a5f3ccfab6e627caca" id="r_a517bdd1d7ac545a5f3ccfab6e627caca"><td class="memTemplParams" colspan="2">template&lt;typename Vector1 , typename Vector2 &gt; </td></tr>
<tr class="memitem:a517bdd1d7ac545a5f3ccfab6e627caca"><td class="memTemplItemLeft" align="right" valign="top">Vector1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html#a517bdd1d7ac545a5f3ccfab6e627caca">sphere_inversion</a> (const Vector1 &amp;p, const Vector2 &amp;c=Vector2(0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> r=1)</td></tr>
<tr class="memdesc:a517bdd1d7ac545a5f3ccfab6e627caca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sphere inversion of a point with respect to a sphere of radius r centered at a point c.  <br /></td></tr>
<tr class="separator:a517bdd1d7ac545a5f3ccfab6e627caca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Linear algebra routines. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a5cd35667d4c7efd0365456ac7f681f2c" name="a5cd35667d4c7efd0365456ac7f681f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd35667d4c7efd0365456ac7f681f2c">&#9670;&#160;</a></span>apply_transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector &amp; theoretica::algebra::apply_transform </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a matrix transformation to a vector and store the result in the vector. </p>
<p>Equivalent to the operation v = A * v </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix transformation </td></tr>
    <tr><td class="paramname">v</td><td>The vector to transform </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten vector </dd></dl>

</div>
</div>
<a id="abc6ca28bf9594eb59ea71a3d5ddf3373" name="abc6ca28bf9594eb59ea71a3d5ddf3373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6ca28bf9594eb59ea71a3d5ddf3373">&#9670;&#160;</a></span>canberra_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::canberra_distance </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Canberra distance between two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first vector </td></tr>
    <tr><td class="paramname">v2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Canberra distance between v1 and v2 </dd></dl>

</div>
</div>
<a id="afda85103719a7a69d69670a8ae6dc13b" name="afda85103719a7a69d69670a8ae6dc13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda85103719a7a69d69670a8ae6dc13b">&#9670;&#160;</a></span>chebyshev_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::chebyshev_distance </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Chebyshev distance between two vectors: \(d(\vec v_1, \vec v_2) = \mathcal{l}^{\infty}(\vec v_1 - \vec v_2)\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first vector </td></tr>
    <tr><td class="paramname">v2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Chebyshev distance between v1 and v2 </dd></dl>

</div>
</div>
<a id="a7a5df713bdfd130cf67acbc28bf38095" name="a7a5df713bdfd130cf67acbc28bf38095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5df713bdfd130cf67acbc28bf38095">&#9670;&#160;</a></span>cosine_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::cosine_distance </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cosine distance between two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first vector </td></tr>
    <tr><td class="paramname">v2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cosine distance between v1 and v2 </dd></dl>

</div>
</div>
<a id="a038ef7f20afa9fbbdd052c020c90f581" name="a038ef7f20afa9fbbdd052c020c90f581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038ef7f20afa9fbbdd052c020c90f581">&#9670;&#160;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector1 , typename Vector2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector1 theoretica::algebra::cross </td>
          <td>(</td>
          <td class="paramtype">const Vector1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cross product between two tridimensional vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first tridimensional vector </td></tr>
    <tr><td class="paramname">w</td><td>The second tridimensional vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of the two vectors </dd></dl>

</div>
</div>
<a id="a752dce461a75811726c0f2c63fa0411a" name="a752dce461a75811726c0f2c63fa0411a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752dce461a75811726c0f2c63fa0411a">&#9670;&#160;</a></span>decompose_cholesky()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix theoretica::algebra::decompose_cholesky </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompose a symmetric positive definite matrix into a triangular matrix so that \(A = L L^T\) using Cholesky decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to decompose </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Cholesky decomposition of the matrix </dd></dl>

</div>
</div>
<a id="aa01947bf47e15390d8031eb2c78a9fc8" name="aa01947bf47e15390d8031eb2c78a9fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01947bf47e15390d8031eb2c78a9fc8">&#9670;&#160;</a></span>decompose_cholesky_inplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix &amp; theoretica::algebra::decompose_cholesky_inplace </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompose a symmetric positive definite matrix in-place, overwriting the starting matrix, without using additional space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The symmetric, positive definite matrix to decompose and overwrite with the lower triangular matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66aafc0be7602bcdbf7b09dd130ebc38" name="a66aafc0be7602bcdbf7b09dd130ebc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66aafc0be7602bcdbf7b09dd130ebc38">&#9670;&#160;</a></span>decompose_lu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 , typename Matrix3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void theoretica::algebra::decompose_lu </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix3 &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompose a square matrix to two triangular matrices, L and U where L is lower and U is upper, so that \(A = LU\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to decompose </td></tr>
    <tr><td class="paramname">L</td><td>The matrix to overwrite with the lower triangular one </td></tr>
    <tr><td class="paramname">U</td><td>The matrix to overwrite with the upper triangular one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The LU decomposition of the matrix </dd></dl>

</div>
</div>
<a id="af8eb412dcf657020ebe3d5b8ec25b1e8" name="af8eb412dcf657020ebe3d5b8ec25b1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8eb412dcf657020ebe3d5b8ec25b1e8">&#9670;&#160;</a></span>decompose_lu_inplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix &amp; theoretica::algebra::decompose_lu_inplace </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompose a square matrix to two triangular matrices, L and U where L is lower and U is upper, so that \(A = LU\) overwriting the matrix A with the elements of both matrices, omitting the diagonal of L (equal to all ones). </p>
<p>Particularly useful for solving linear systems.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to decompose and overwrite </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten matrix A </dd></dl>

</div>
</div>
<a id="a60e560ebb9321de24c7c29f568c5182b" name="a60e560ebb9321de24c7c29f568c5182b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e560ebb9321de24c7c29f568c5182b">&#9670;&#160;</a></span>density()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , enable_matrix&lt; Matrix &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::density </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1<a class="el" href="namespacetheoretica.html#aa3c0a5082e6b4428b15b7b02d16eafc7">E</a>-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the density of a matrix, counting the proportion of non-zero (bigger in module than the given tolerance) elements with respect to the total number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to compute the density of </td></tr>
    <tr><td class="paramname">tolerance</td><td>The minimum tolerance in absolute value to consider an element non-zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A real number between 0 and 1 representing the proportion of non-zero elements of the matrix. </dd></dl>

</div>
</div>
<a id="a92ab2652982540b574dc6890f1af8c5d" name="a92ab2652982540b574dc6890f1af8c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ab2652982540b574dc6890f1af8c5d">&#9670;&#160;</a></span>det()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::algebra::det </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the determinant of a square matrix. </p>
<p>In-place LU decomposition is used to reduce the matrix to triangular form.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to compute the determinant of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The determinant of the matrix </dd></dl>

</div>
</div>
<a id="a30801ece0c3185cc1da7d02f6e339de1" name="a30801ece0c3185cc1da7d02f6e339de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30801ece0c3185cc1da7d02f6e339de1">&#9670;&#160;</a></span>diagonal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix theoretica::algebra::diagonal </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cols</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the a matrix with the given diagonal. </p>
<p>The function without any parameters is used for statically allocated matrix types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector of the diagonal elements </td></tr>
    <tr><td class="paramname">rows</td><td>The number of rows of the matrix </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns of the matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The diagonal matrix of the given type </dd></dl>

</div>
</div>
<a id="ac08fe667743b70ad522893dca767f1ef" name="ac08fe667743b70ad522893dca767f1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08fe667743b70ad522893dca767f1ef">&#9670;&#160;</a></span>diagonal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector , typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix &amp; theoretica::algebra::diagonal </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a matrix with the given vector as diagonal and zeroes everywhere else, overwriting the given matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>vector of diagonal elements </td></tr>
    <tr><td class="paramname">res</td><td>The matrix to overwrite </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten matrix </dd></dl>

</div>
</div>
<a id="a84cf5d732779f650d7a6807177d71ffa" name="a84cf5d732779f650d7a6807177d71ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84cf5d732779f650d7a6807177d71ffa">&#9670;&#160;</a></span>diagonal_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::algebra::diagonal_product </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the product of the elements of the main diagonal of a generic matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of all the elements of the main diagonal of the input matrix </dd></dl>

</div>
</div>
<a id="a42adc6116acb2e08f4331f34d9f5ba45" name="a42adc6116acb2e08f4331f34d9f5ba45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42adc6116acb2e08f4331f34d9f5ba45">&#9670;&#160;</a></span>discrete_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::discrete_distance </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#aa34d8798921a9b3b78e885a455ff4211">MACH_EPSILON</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the discrete distance between two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first vector </td></tr>
    <tr><td class="paramname">v2</td><td>The second vector </td></tr>
    <tr><td class="paramname">tolerance</td><td>The minimum absolute difference between elements to consider them different (defaults to MACH_EPSILON). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The discrete distance between v1 and v2 </dd></dl>

</div>
</div>
<a id="ae64de98c3ce227a917740f98db5a5a89" name="ae64de98c3ce227a917740f98db5a5a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64de98c3ce227a917740f98db5a5a89">&#9670;&#160;</a></span>distance() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Euclidean distance between two complex numbers: \(d(z_1, z_2) = |z_1 - z_2|\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z1</td><td>The first complex value </td></tr>
    <tr><td class="paramname">z2</td><td>The second complex value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between z1 and z2 </dd></dl>

</div>
</div>
<a id="ac25b06886bf908eaf56d20bce02da5b2" name="ac25b06886bf908eaf56d20bce02da5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25b06886bf908eaf56d20bce02da5b2">&#9670;&#160;</a></span>distance() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::distance </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Euclidean distance between two vectors: \(d(\vec v_1, \vec v_2) = \mathcal{l}^2(\vec v_1 - \vec v_2)\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first vector </td></tr>
    <tr><td class="paramname">v2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Euclidean distance between v1 and v2 </dd></dl>

</div>
</div>
<a id="ae58e3f5a6b4d0db51bbeec5bfc789da1" name="ae58e3f5a6b4d0db51bbeec5bfc789da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58e3f5a6b4d0db51bbeec5bfc789da1">&#9670;&#160;</a></span>distance() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Euclidian distance between two values: \(d(a, b) = |a - b|\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first real value </td></tr>
    <tr><td class="paramname">b</td><td>The second real value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Euclidean distance between a and b </dd></dl>

</div>
</div>
<a id="a78eaf414de804da51ccf4ee4dc20d31c" name="a78eaf414de804da51ccf4ee4dc20d31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78eaf414de804da51ccf4ee4dc20d31c">&#9670;&#160;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector1 , typename Vector2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::algebra::dot </td>
          <td>(</td>
          <td class="paramtype">const Vector1 &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the dot product between two vectors, using the Hermitian form if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The first vector </td></tr>
    <tr><td class="paramname">w</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dot product of the two vectors </dd></dl>

</div>
</div>
<a id="a2f5fb558e9bab3673b71959bcf08aa6a" name="a2f5fb558e9bab3673b71959bcf08aa6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f5fb558e9bab3673b71959bcf08aa6a">&#9670;&#160;</a></span>eigenpair_inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector1 , typename Vector2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::algebra::eigenpair_inverse </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#af8b9679476be607282a44a7f7f8b38c4">ALGEBRA_EIGEN_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#ae203c518f0274c29d78167c457cac65b">ALGEBRA_EIGEN_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the eigenvalue with the smallest inverse \(\frac{1}{|\lambda_i|}\) of a square matrix and its corresponding eigenvector, using the inverse power method with parameter equal to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to find the smallest eigenvalue of </td></tr>
    <tr><td class="paramname">x</td><td>The starting vector (a random vector is a good choice) </td></tr>
    <tr><td class="paramname">v</td><td>The vector to overwrite with the eigenvector </td></tr>
    <tr><td class="paramname">tolerance</td><td>The minimum difference in norm between subsequent steps to stop the algorithm at (defaults to ALGEBRA_EIGEN_TOL). </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to use (defaults to ALGEBRA_EIGEN_ITER). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The eigenvalue with the smallest inverse of the matrix, or NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="a13b050141618e40f336c4ef549ac96a4" name="a13b050141618e40f336c4ef549ac96a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b050141618e40f336c4ef549ac96a4">&#9670;&#160;</a></span>eigenpair_power()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector1 , typename Vector2  = Vector1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::algebra::eigenpair_power </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#af8b9679476be607282a44a7f7f8b38c4">ALGEBRA_EIGEN_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#ae203c518f0274c29d78167c457cac65b">ALGEBRA_EIGEN_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the biggest eigenvalue in module \(|\lambda_i|\) of a square matrix and its corresponding eigenvector (eigenpair), using the power method (Von Mises iteration). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to find the biggest eigenvalue of </td></tr>
    <tr><td class="paramname">x</td><td>The starting vector (a random vector is a good choice) </td></tr>
    <tr><td class="paramname">v</td><td>The vector to overwrite with the eigenvector </td></tr>
    <tr><td class="paramname">tolerance</td><td>The minimum difference in norm between subsequent steps to stop the algorithm at (defaults to ALGEBRA_EIGEN_TOL). </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to use (defaults to ALGEBRA_EIGEN_ITER). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The biggest eigenvalue of the matrix, or NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="a8b2af7de1123511d864c4531894d8417" name="a8b2af7de1123511d864c4531894d8417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2af7de1123511d864c4531894d8417">&#9670;&#160;</a></span>eigenpair_rayleigh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector1 , typename Vector2 , typename T  = matrix_element_t&lt;Matrix&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::algebra::eigenpair_rayleigh </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#af8b9679476be607282a44a7f7f8b38c4">ALGEBRA_EIGEN_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#ae203c518f0274c29d78167c457cac65b">ALGEBRA_EIGEN_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute an eigenvalue of a square matrix and its corresponding eigenvector (eigenpair) using the Rayleigh quotient iteration method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to compute the eigenvalue of </td></tr>
    <tr><td class="paramname">lambda</td><td>The starting value for the Rayleigh quotient </td></tr>
    <tr><td class="paramname">x</td><td>The starting approximation for the eigenvector (a random vector is a good choice). </td></tr>
    <tr><td class="paramname">v</td><td>The vector to overwrite with the eigenvector </td></tr>
    <tr><td class="paramname">tolerance</td><td>The minimum difference in norm between subsequent steps to stop the algorithm at (defaults to ALGEBRA_EIGEN_TOL). </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to use (defaults to ALGEBRA_EIGEN_ITER). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximate eigenvalue of the matrix, or NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="af4fa83f097e3a9a5fa2abe41e90aa23c" name="af4fa83f097e3a9a5fa2abe41e90aa23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4fa83f097e3a9a5fa2abe41e90aa23c">&#9670;&#160;</a></span>eigenvalue_inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::algebra::eigenvalue_inverse </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#af8b9679476be607282a44a7f7f8b38c4">ALGEBRA_EIGEN_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#ae203c518f0274c29d78167c457cac65b">ALGEBRA_EIGEN_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the eigenvalue with the smallest inverse \(\frac{1}{|\lambda_i|}\) of a square matrix, using the inverse power method with parameter equal to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to find the smallest eigenvalue of </td></tr>
    <tr><td class="paramname">x</td><td>The starting vector (a random vector is a good choice) </td></tr>
    <tr><td class="paramname">tolerance</td><td>The minimum difference in norm between subsequent steps to stop the algorithm at (defaults to ALGEBRA_EIGEN_TOL). </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to use (defaults to ALGEBRA_EIGEN_ITER). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The eigenvalue with the smallest inverse of the matrix, or NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="a2c6035b384fb9c7f30c6e96f112925a0" name="a2c6035b384fb9c7f30c6e96f112925a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6035b384fb9c7f30c6e96f112925a0">&#9670;&#160;</a></span>eigenvalue_power()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::algebra::eigenvalue_power </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#af8b9679476be607282a44a7f7f8b38c4">ALGEBRA_EIGEN_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#ae203c518f0274c29d78167c457cac65b">ALGEBRA_EIGEN_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the biggest eigenvalue in module \(|\lambda_i|\) of a square matrix using the power method (Von Mises iteration). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to find the biggest eigenvalue of </td></tr>
    <tr><td class="paramname">x</td><td>The starting vector (a random vector is a good choice) </td></tr>
    <tr><td class="paramname">tolerance</td><td>The minimum difference in norm between subsequent steps to stop the algorithm at (defaults to ALGEBRA_EIGEN_TOL). </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to use (defaults to ALGEBRA_EIGEN_ITER). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The biggest eigenvalue of the matrix, or NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="a858a7ed886d0fc9b2a484aed88186cae" name="a858a7ed886d0fc9b2a484aed88186cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858a7ed886d0fc9b2a484aed88186cae">&#9670;&#160;</a></span>eigenvalue_rayleigh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector , typename T  = matrix_element_t&lt;Matrix&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::algebra::eigenvalue_rayleigh </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#af8b9679476be607282a44a7f7f8b38c4">ALGEBRA_EIGEN_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#ae203c518f0274c29d78167c457cac65b">ALGEBRA_EIGEN_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute an eigenvalue of a square matrix using the Rayleigh quotient iteration method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to compute the eigenvalue of </td></tr>
    <tr><td class="paramname">lambda</td><td>The starting value for the Rayleigh quotient </td></tr>
    <tr><td class="paramname">x</td><td>The starting approximation for the eigenvector (a random vector is a good choice). </td></tr>
    <tr><td class="paramname">tolerance</td><td>The minimum difference in norm between subsequent steps to stop the algorithm at (defaults to ALGEBRA_EIGEN_TOL). </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to use (defaults to ALGEBRA_EIGEN_ITER). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximate eigenvalue of the matrix, or NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="a65ae9dadad96bc74a76b49f46cad90e2" name="a65ae9dadad96bc74a76b49f46cad90e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ae9dadad96bc74a76b49f46cad90e2">&#9670;&#160;</a></span>eigenvector_inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector , typename T  = matrix_element_t&lt;Matrix&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector theoretica::algebra::eigenvector_inverse </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#af8b9679476be607282a44a7f7f8b38c4">ALGEBRA_EIGEN_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#ae203c518f0274c29d78167c457cac65b">ALGEBRA_EIGEN_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the eigenvector associated with a given approximated eigenvalue using the inverse power method. </p>
<dl class="section note"><dt>Note</dt><dd>The algorithm is unstable when the approximation of the eigenvalue is too close to the true value. A value not too close to the actual eigenvalue and far away from the other eigenvalues should be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to find the eigenvector of </td></tr>
    <tr><td class="paramname">lambda</td><td>The eigenvalue </td></tr>
    <tr><td class="paramname">x</td><td>The starting vector (a random vector is a good choice) </td></tr>
    <tr><td class="paramname">tolerance</td><td>The minimum difference in norm between subsequent steps to stop the algorithm at (defaults to ALGEBRA_EIGEN_TOL). </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to use (defaults to ALGEBRA_EIGEN_ITER). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximate eigenvector associated with the eigenvalue </dd></dl>

</div>
</div>
<a id="ab3cfadd3815e357ab79c40213a556fd3" name="ab3cfadd3815e357ab79c40213a556fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3cfadd3815e357ab79c40213a556fd3">&#9670;&#160;</a></span>euclidean_distance() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::euclidean_distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Euclidean distance between two complex numbers: \(d(z_1, z_2) = |z_1 - z_2|\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z1</td><td>The first complex value </td></tr>
    <tr><td class="paramname">z2</td><td>The second complex value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between z1 and z2 </dd></dl>

</div>
</div>
<a id="a6e09c1648a8787bc459402860380dad4" name="a6e09c1648a8787bc459402860380dad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e09c1648a8787bc459402860380dad4">&#9670;&#160;</a></span>euclidean_distance() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::euclidean_distance </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distances. </p>
<p>Compute the Euclidean distance between two vectors: \(d(\vec v_1, \vec v_2) = \mathcal{l}^2(\vec v_1 - \vec v_2)\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first vector </td></tr>
    <tr><td class="paramname">v2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Euclidean distance between v1 and v2 </dd></dl>

</div>
</div>
<a id="a326d624702e7b8c7645f917e6e8df946" name="a326d624702e7b8c7645f917e6e8df946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326d624702e7b8c7645f917e6e8df946">&#9670;&#160;</a></span>euclidean_distance() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::euclidean_distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Euclidian distance between two real values: \(d(a, b) = |a - b|\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first real value </td></tr>
    <tr><td class="paramname">b</td><td>The second real value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Euclidean distance between a and b </dd></dl>

</div>
</div>
<a id="af63fa32f52f7801f0a2ab570d9ea5cd4" name="af63fa32f52f7801f0a2ab570d9ea5cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63fa32f52f7801f0a2ab570d9ea5cd4">&#9670;&#160;</a></span>hamming_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::hamming_distance </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#aa34d8798921a9b3b78e885a455ff4211">MACH_EPSILON</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Hamming distance between two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first vector </td></tr>
    <tr><td class="paramname">v2</td><td>The second vector </td></tr>
    <tr><td class="paramname">tolerance</td><td>The minimum absolute difference between elements to consider them different (defaults to MACH_EPSILON). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Hamming distance between v1 and v2 </dd></dl>

</div>
</div>
<a id="ab27e1f7cb91803bcaa589262d38e32e5" name="ab27e1f7cb91803bcaa589262d38e32e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27e1f7cb91803bcaa589262d38e32e5">&#9670;&#160;</a></span>hermitian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename MatrixT  = Matrix&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MatrixT theoretica::algebra::hermitian </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the hermitian of the given matrix. </p>
<p>Equivalent to the operation m^T </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to compute the hermitian of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hermitian of the matrix </dd></dl>

</div>
</div>
<a id="af0d8810ef51e6d38c45132998b481740" name="af0d8810ef51e6d38c45132998b481740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d8810ef51e6d38c45132998b481740">&#9670;&#160;</a></span>hermitian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix1 &amp; theoretica::algebra::hermitian </td>
          <td>(</td>
          <td class="paramtype">Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hermitian (conjugate transpose) of a matrix. </p>
<p>Equivalent to the operation dest = src^H. The base type of the matrix needs to have a compatible <a class="el" href="namespacetheoretica.html#a60d712fc2f7470e40f65fd470cbb6982" title="Return the conjugate of a second order dual number.">conjugate()</a> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The matrix to overwrite </td></tr>
    <tr><td class="paramname">src</td><td>The matrix to compute the hermitian of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten matrix </dd></dl>

</div>
</div>
<a id="a6d8959e6c5653f2a821935ca4a1d4cd2" name="a6d8959e6c5653f2a821935ca4a1d4cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8959e6c5653f2a821935ca4a1d4cd2">&#9670;&#160;</a></span>hilbert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix theoretica::algebra::hilbert </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rows</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the Hilbert matrix of arbitrary dimension. </p>
<p>The Hilbert matrices are square matrices with particularly high condition number, which makes them ill-conditioned for numerical calculations. The elements of the Hilbert matrix are given by \(H_{ij} = \frac{1}{i + j - 1}\) (for \(i,j\) starting from 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows (and columns) of the resulting matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Hilbert matrix of the given size </dd></dl>

</div>
</div>
<a id="acd28fad57af499af2e6684cb08bab273" name="acd28fad57af499af2e6684cb08bab273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd28fad57af499af2e6684cb08bab273">&#9670;&#160;</a></span>identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix theoretica::algebra::identity </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cols</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the identity matrix. </p>
<p>Size parameters are used only for dynamically allocated matrix types. </p><dl class="section return"><dt>Returns</dt><dd>The identity matrix of the given type </dd></dl>

</div>
</div>
<a id="aa5adc77960e5924940603eb503c12828" name="aa5adc77960e5924940603eb503c12828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5adc77960e5924940603eb503c12828">&#9670;&#160;</a></span>inverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename MatrixInv  = Matrix&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MatrixInv theoretica::algebra::inverse </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inverse of the given matrix. </p>
<p>Equivalent to the operation \(m^-1\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to invert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverted matrix </dd></dl>

</div>
</div>
<a id="ada5dca1646577df0e8f2c74ee007a032" name="ada5dca1646577df0e8f2c74ee007a032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5dca1646577df0e8f2c74ee007a032">&#9670;&#160;</a></span>inverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix1 &amp; theoretica::algebra::inverse </td>
          <td>(</td>
          <td class="paramtype">Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert the given matrix. </p>
<p>Equivalent to the operation dest = src^-1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The matrix to overwrite </td></tr>
    <tr><td class="paramname">src</td><td>The matrix to invert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the inverted matrix </dd></dl>

</div>
</div>
<a id="a1d8e7f8039577df122fd34d187792787" name="a1d8e7f8039577df122fd34d187792787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8e7f8039577df122fd34d187792787">&#9670;&#160;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix &amp; theoretica::algebra::invert </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert the given matrix and overwrite it. </p>
<p>Equivalent to the operation m = m^-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to invert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the inverted matrix </dd></dl>

</div>
</div>
<a id="a58f3fc72c395411ca964ef50dc6c8303" name="a58f3fc72c395411ca964ef50dc6c8303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f3fc72c395411ca964ef50dc6c8303">&#9670;&#160;</a></span>is_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool theoretica::algebra::is_diagonal </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>10&#160;*&#160;<a class="el" href="namespacetheoretica.html#aa34d8798921a9b3b78e885a455ff4211">MACH_EPSILON</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the matrix is diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to consider </td></tr>
    <tr><td class="paramname">tolerance</td><td>The tolerance to allow for in the comparison, defaults to 10 * MACH_EPSILON </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value </dd></dl>

</div>
</div>
<a id="a01182d050ae939b2fb0647806478882c" name="a01182d050ae939b2fb0647806478882c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01182d050ae939b2fb0647806478882c">&#9670;&#160;</a></span>is_lower_triangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool theoretica::algebra::is_lower_triangular </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a431f69ddc5ada0242f703284a54726f9">ALGEBRA_ELEMENT_TOL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the matrix is lower triangular. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to consider </td></tr>
    <tr><td class="paramname">tolerance</td><td>The tolerance to allow for in the comparison, defaults to ALGEBRA_ELEMENT_TOL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value </dd></dl>

</div>
</div>
<a id="a1ab552f2067f23dfab8473ff098810d1" name="a1ab552f2067f23dfab8473ff098810d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab552f2067f23dfab8473ff098810d1">&#9670;&#160;</a></span>is_square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool theoretica::algebra::is_square </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the matrix is square. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to consider </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value </dd></dl>

</div>
</div>
<a id="a4752e001d3198f3be8ae8f05f4fb06bf" name="a4752e001d3198f3be8ae8f05f4fb06bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4752e001d3198f3be8ae8f05f4fb06bf">&#9670;&#160;</a></span>is_symmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool theoretica::algebra::is_symmetric </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a431f69ddc5ada0242f703284a54726f9">ALGEBRA_ELEMENT_TOL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the matrix is symmetric. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to consider </td></tr>
    <tr><td class="paramname">tolerance</td><td>The tolerance to allow for in the comparison, defaults to ALGEBRA_ELEMENT_TOL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value </dd></dl>

</div>
</div>
<a id="a580a1460c4ab6eb87cd12d461e0ff675" name="a580a1460c4ab6eb87cd12d461e0ff675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580a1460c4ab6eb87cd12d461e0ff675">&#9670;&#160;</a></span>is_upper_triangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool theoretica::algebra::is_upper_triangular </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a431f69ddc5ada0242f703284a54726f9">ALGEBRA_ELEMENT_TOL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the matrix is upper triangular. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to consider </td></tr>
    <tr><td class="paramname">tolerance</td><td>The tolerance to allow for in the comparison, defaults to ALGEBRA_ELEMENT_TOL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value </dd></dl>

</div>
</div>
<a id="a517742cc82be888526f2e5c6f7836220" name="a517742cc82be888526f2e5c6f7836220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517742cc82be888526f2e5c6f7836220">&#9670;&#160;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::l1_norm </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the l1 norm of a vector: \(\mathcal{l}^1(\vec v) = \Sigma_i \ |v_i|\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to compute the norm of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The l1 norm of v </dd></dl>

</div>
</div>
<a id="a0ec28ec5a0ac0dc055108a9d37fd5326" name="a0ec28ec5a0ac0dc055108a9d37fd5326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec28ec5a0ac0dc055108a9d37fd5326">&#9670;&#160;</a></span>l2_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::l2_norm </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the l2 norm of a vector: \(\mathcal{l}^2(\vec v) = \sqrt{\Sigma_i \ v_i^2}\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to compute the norm of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The l2 norm of v </dd></dl>

</div>
</div>
<a id="abb07bbcc3f136d05ab51d06dc46052d9" name="abb07bbcc3f136d05ab51d06dc46052d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb07bbcc3f136d05ab51d06dc46052d9">&#9670;&#160;</a></span>linf_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::linf_norm </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the linf norm of a vector: \(\mathcal{l}^{\infty}(\vec v) = max(|v_i|)\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to compute the norm of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The linf norm of v </dd></dl>

</div>
</div>
<a id="add67a433fe0cbfca717f7556afaabdbf" name="add67a433fe0cbfca717f7556afaabdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add67a433fe0cbfca717f7556afaabdbf">&#9670;&#160;</a></span>lp_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::lp_norm </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Norms. </p>
<p>Compute the lp norm of a vector: \(\mathcal{l}^p(\vec v) = (\Sigma_i \ |v_i|^p)^{1/p}\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to compute the norm of </td></tr>
    <tr><td class="paramname">p</td><td>The power of the Lp norm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lp norm of v </dd></dl>

</div>
</div>
<a id="afc5ae85e773f42a3d4dca948067f5324" name="afc5ae85e773f42a3d4dca948067f5324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5ae85e773f42a3d4dca948067f5324">&#9670;&#160;</a></span>make_hermitian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix &amp; theoretica::algebra::make_hermitian </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hermitian of a given matrix and overwrite it. </p>
<p>Equivalent to the operation m = m^H </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to compute the hermitian of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten matrix </dd></dl>

</div>
</div>
<a id="a2fdbfbad332a15de0037edb0116b6023" name="a2fdbfbad332a15de0037edb0116b6023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdbfbad332a15de0037edb0116b6023">&#9670;&#160;</a></span>make_identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix &amp; theoretica::algebra::make_identity </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrite a matrix with the identity matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to overwrite </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten matrix </dd></dl>

</div>
</div>
<a id="a3b62d14e94e493460b4eb6b9c9b716ae" name="a3b62d14e94e493460b4eb6b9c9b716ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b62d14e94e493460b4eb6b9c9b716ae">&#9670;&#160;</a></span>make_normalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector &amp; theoretica::algebra::make_normalized </td>
          <td>(</td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalize a given vector overwriting it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to normalize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten vector </dd></dl>

</div>
</div>
<a id="ab60d6c05b8a2947cccc33d4dad1d8803" name="ab60d6c05b8a2947cccc33d4dad1d8803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60d6c05b8a2947cccc33d4dad1d8803">&#9670;&#160;</a></span>make_transposed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix &amp; theoretica::algebra::make_transposed </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose the given matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to transpose </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the transposed matrix </dd></dl>

</div>
</div>
<a id="a58980fd04564631dab6b2f76e0f0013c" name="a58980fd04564631dab6b2f76e0f0013c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58980fd04564631dab6b2f76e0f0013c">&#9670;&#160;</a></span>manhattan_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::manhattan_distance </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Manhattan distance between two vectors: \(d(\vec v_1, \vec v_2) = \mathcal{l}^1(\vec v_1 - \vec v_2)\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first vector </td></tr>
    <tr><td class="paramname">v2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Manhattan distance between v1 and v2 </dd></dl>

</div>
</div>
<a id="aa7340e67961ded04bd80d80771f353f4" name="aa7340e67961ded04bd80d80771f353f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7340e67961ded04bd80d80771f353f4">&#9670;&#160;</a></span>mat_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix1 &amp; theoretica::algebra::mat_copy </td>
          <td>(</td>
          <td class="paramtype">Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a matrix by overwriting another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The matrix to overwrite </td></tr>
    <tr><td class="paramname">src</td><td>The matrix to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten matrix </dd></dl>

</div>
</div>
<a id="a33ec73f2d73bc746501ed0b5a6ed377b" name="a33ec73f2d73bc746501ed0b5a6ed377b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ec73f2d73bc746501ed0b5a6ed377b">&#9670;&#160;</a></span>mat_diff() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix2 &amp; theoretica::algebra::mat_diff </td>
          <td>(</td>
          <td class="paramtype">Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract two matrices and store the result in the first matrix. </p>
<p>Equivalent to the operation A = A - B </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first matrix to store the result </td></tr>
    <tr><td class="paramname">B</td><td>The second matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten matrix </dd></dl>

</div>
</div>
<a id="af995b3382cb47c72000b14755d3eba76" name="af995b3382cb47c72000b14755d3eba76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af995b3382cb47c72000b14755d3eba76">&#9670;&#160;</a></span>mat_diff() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 , typename Matrix3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix1 &amp; theoretica::algebra::mat_diff </td>
          <td>(</td>
          <td class="paramtype">Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix3 &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract two matrices and store the result in another matrix Equivalent to the operation res = A - B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first matrix </td></tr>
    <tr><td class="paramname">B</td><td>The second matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten matrix </dd></dl>

</div>
</div>
<a id="a48ae546299bfa1f1e9c01af80ba48f43" name="a48ae546299bfa1f1e9c01af80ba48f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ae546299bfa1f1e9c01af80ba48f43">&#9670;&#160;</a></span>mat_equals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool theoretica::algebra::mat_equals </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>10&#160;*&#160;<a class="el" href="namespacetheoretica.html#aa34d8798921a9b3b78e885a455ff4211">MACH_EPSILON</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether two matrices are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first matrix </td></tr>
    <tr><td class="paramname">B</td><td>The second matrix </td></tr>
    <tr><td class="paramname">tolerance</td><td>The tolerance to allow for in the comparison, defaults to 10 * MACH_EPSILON </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value </dd></dl>

</div>
</div>
<a id="a70f8a0fa365f11722ac6ca9d0086d8ba" name="a70f8a0fa365f11722ac6ca9d0086d8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f8a0fa365f11722ac6ca9d0086d8ba">&#9670;&#160;</a></span>mat_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix &amp; theoretica::algebra::mat_error </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrite the given matrix with the error matrix with NaN values on the diagonal and zeroes everywhere else. </p>
<p>This function is used to signal an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to overwrite </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten matrix </dd></dl>

</div>
</div>
<a id="a9da43216b89e292e7e09248a5a64bbc7" name="a9da43216b89e292e7e09248a5a64bbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da43216b89e292e7e09248a5a64bbc7">&#9670;&#160;</a></span>mat_lincomb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Field1 , typename Matrix1 , typename Field2 , typename Matrix2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix2 &amp; theoretica::algebra::mat_lincomb </td>
          <td>(</td>
          <td class="paramtype">Field1&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Field2&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the linear combination of two matrices and store the result in the first matrix. </p>
<p>Equivalent to the operation A = alpha * A + beta * B </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first matrix to combine and store the result </td></tr>
    <tr><td class="paramname">B</td><td>The second matrix to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten matrix </dd></dl>

</div>
</div>
<a id="ac341a35e84e0817e9996cb1f68dc1d92" name="ac341a35e84e0817e9996cb1f68dc1d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac341a35e84e0817e9996cb1f68dc1d92">&#9670;&#160;</a></span>mat_lincomb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Field1 , typename Matrix2 , typename Field2 , typename Matrix3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix1 &amp; theoretica::algebra::mat_lincomb </td>
          <td>(</td>
          <td class="paramtype">Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Field1&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Field2&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix3 &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the linear combination of two matrices and store the result in the first matrix. </p>
<p>Equivalent to the operation res = alpha * A + beta * B </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The matrix to overwrite with the result </td></tr>
    <tr><td class="paramname">alpha</td><td>The first scalar parameter </td></tr>
    <tr><td class="paramname">A</td><td>The first matrix to combine </td></tr>
    <tr><td class="paramname">beta</td><td>The second scalar parameter </td></tr>
    <tr><td class="paramname">B</td><td>The second matrix to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten matrix </dd></dl>

</div>
</div>
<a id="a78fe225d79cff4f7b5b8edbdae04dd50" name="a78fe225d79cff4f7b5b8edbdae04dd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fe225d79cff4f7b5b8edbdae04dd50">&#9670;&#160;</a></span>mat_mul() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 , typename Matrix3  = Matrix1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix3 theoretica::algebra::mat_mul </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two matrices and store the result in the first matrix, equivalent to the operation \(R = A B\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first matrix to multiply and store the result </td></tr>
    <tr><td class="paramname">B</td><td>The second matrix to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix </dd></dl>

</div>
</div>
<a id="a47ee34d97b633e5075732524a85d0ce0" name="a47ee34d97b633e5075732524a85d0ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ee34d97b633e5075732524a85d0ce0">&#9670;&#160;</a></span>mat_mul() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 , typename Matrix3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix1 &amp; theoretica::algebra::mat_mul </td>
          <td>(</td>
          <td class="paramtype">Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix3 &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two matrices and store the result in another matrix, equivalent to the operation \(R = A B\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>The matrix to overwrite with the result </td></tr>
    <tr><td class="paramname">A</td><td>The first matrix to multiply </td></tr>
    <tr><td class="paramname">B</td><td>The second matrix to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the modified matrix </dd></dl>

</div>
</div>
<a id="aa5409959842e07390e2834cc99139a5d" name="aa5409959842e07390e2834cc99139a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5409959842e07390e2834cc99139a5d">&#9670;&#160;</a></span>mat_mul_transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 , typename Matrix3  = Matrix1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix3 theoretica::algebra::mat_mul_transpose </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a matrix by the transpose of another matrix, equivalent to the operation \(R = A B^T\). </p>
<dl class="section note"><dt>Note</dt><dd>This function is faster then writing A * algebra::transpose(B) and should be preferred.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first matrix to multiply </td></tr>
    <tr><td class="paramname">B</td><td>The second matrix to transpose and multiply by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the multiplication by the first matrix and the transpose of second matrix. </dd></dl>

</div>
</div>
<a id="a1757fff7a273fbebc8c10e658e36e747" name="a1757fff7a273fbebc8c10e658e36e747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1757fff7a273fbebc8c10e658e36e747">&#9670;&#160;</a></span>mat_scalmul() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Field , typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix &amp; theoretica::algebra::mat_scalmul </td>
          <td>(</td>
          <td class="paramtype">Field&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a matrix by a scalar of any compatible type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A scalar value </td></tr>
    <tr><td class="paramname">m</td><td>The matrix to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the multiplied matrix </dd></dl>

</div>
</div>
<a id="a53fd6e5c9bd2041ddc0d372f4fda6d70" name="a53fd6e5c9bd2041ddc0d372f4fda6d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fd6e5c9bd2041ddc0d372f4fda6d70">&#9670;&#160;</a></span>mat_scalmul() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Field , typename Matrix1 , typename Matrix2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix1 &amp; theoretica::algebra::mat_scalmul </td>
          <td>(</td>
          <td class="paramtype">Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Field&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a matrix by a scalar of any compatible type which can be cast to the type of element of the output matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The matrix to overwrite with the result </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value </td></tr>
    <tr><td class="paramname">src</td><td>The matrix to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the resulting matrix </dd></dl>

</div>
</div>
<a id="a92c5d22e34332185f2eea0b23de4a9ac" name="a92c5d22e34332185f2eea0b23de4a9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c5d22e34332185f2eea0b23de4a9ac">&#9670;&#160;</a></span>mat_shift_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Type  = matrix_element_t&lt;Matrix&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix &amp; theoretica::algebra::mat_shift_diagonal </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift the diagonal of a matrix by the given amount, overwriting the matrix itself, as \((A + \sigma I)\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to shift the diagonal of </td></tr>
    <tr><td class="paramname">sigma</td><td>The amount to shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the modified matrix </dd></dl>

</div>
</div>
<a id="a0e0fb9692dbe481cc96fc7dea38f5fc5" name="a0e0fb9692dbe481cc96fc7dea38f5fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0fb9692dbe481cc96fc7dea38f5fc5">&#9670;&#160;</a></span>mat_sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix2 &amp; theoretica::algebra::mat_sum </td>
          <td>(</td>
          <td class="paramtype">Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum two matrices and store the result in the first matrix. </p>
<p>Equivalent to the operation A = A + B </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first matrix to add and store the result </td></tr>
    <tr><td class="paramname">B</td><td>The second matrix to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten matrix </dd></dl>

</div>
</div>
<a id="a04d386e7bd52acd0ecea1a5923777254" name="a04d386e7bd52acd0ecea1a5923777254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d386e7bd52acd0ecea1a5923777254">&#9670;&#160;</a></span>mat_sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 , typename Matrix3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix1 &amp; theoretica::algebra::mat_sum </td>
          <td>(</td>
          <td class="paramtype">Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix3 &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum two matrices and store the result in another matrix Equivalent to the operation res = A + B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first matrix to add </td></tr>
    <tr><td class="paramname">B</td><td>The second matrix to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten matrix </dd></dl>

</div>
</div>
<a id="a3a1ea1fa7d1c6976640fceb455684b16" name="a3a1ea1fa7d1c6976640fceb455684b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1ea1fa7d1c6976640fceb455684b16">&#9670;&#160;</a></span>mat_swap_cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix &amp; theoretica::algebra::mat_swap_cols </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap two columns of a matrix, given the matrix and the two indices of the columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to swap the columns of </td></tr>
    <tr><td class="paramname">col1</td><td>The index of the first column to swap </td></tr>
    <tr><td class="paramname">col2</td><td>The index of the other column to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c75a96ed813cfbcb8b116024a318995" name="a6c75a96ed813cfbcb8b116024a318995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c75a96ed813cfbcb8b116024a318995">&#9670;&#160;</a></span>mat_swap_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix &amp; theoretica::algebra::mat_swap_rows </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap two rows of a matrix, given the matrix and the two indices of the rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to swap the rows of </td></tr>
    <tr><td class="paramname">row1</td><td>The index of the first row to swap </td></tr>
    <tr><td class="paramname">row2</td><td>The index of the other row to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e8c8a9cfcb525db569989486105e324" name="a0e8c8a9cfcb525db569989486105e324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8c8a9cfcb525db569989486105e324">&#9670;&#160;</a></span>mat_transpose_mul()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 , typename Matrix3  = Matrix1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix3 theoretica::algebra::mat_transpose_mul </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply the transpose of a matrix by another matrix, equivalent to the operation \(R = A^T B\). </p>
<dl class="section note"><dt>Note</dt><dd>This function is faster then writing algebra::transpose(A) * B and should be preferred.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to transpose and then multiply </td></tr>
    <tr><td class="paramname">B</td><td>The second matrix to multiply by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the multiplication by the transpose of the first matrix and the second matrix. </dd></dl>

</div>
</div>
<a id="a80a2f381c9e87d82b362982d910f2111" name="a80a2f381c9e87d82b362982d910f2111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a2f381c9e87d82b362982d910f2111">&#9670;&#160;</a></span>mat_zeroes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix &amp; theoretica::algebra::mat_zeroes </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrite a matrix with all zeroes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to overwrite </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten matrix </dd></dl>

</div>
</div>
<a id="adf68fe2919fe81fba86b870912dad30b" name="adf68fe2919fe81fba86b870912dad30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf68fe2919fe81fba86b870912dad30b">&#9670;&#160;</a></span>minkowski_distance() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::minkowski_distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Minkowski distance between two complex values: \(d(z_1, z_2) = \mathcal{l}^p(z_1 - z_2)\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z1</td><td>The first complex value </td></tr>
    <tr><td class="paramname">z2</td><td>The second complex value </td></tr>
    <tr><td class="paramname">p</td><td>The power of the distance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Minkowski distance of power p between z1 and z2 </dd></dl>

</div>
</div>
<a id="a520f67f6985860e7cf39b31141b7bc32" name="a520f67f6985860e7cf39b31141b7bc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520f67f6985860e7cf39b31141b7bc32">&#9670;&#160;</a></span>minkowski_distance() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::minkowski_distance </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Minkowski distance between two vectors: \(d(\vec v_1, \vec v_2) = \mathcal{l}^p(\vec v_1 - \vec v_2)\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first vector </td></tr>
    <tr><td class="paramname">v2</td><td>The second vector </td></tr>
    <tr><td class="paramname">p</td><td>The power of the distance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Minkowski distance of power p between v1 and v2 </dd></dl>

</div>
</div>
<a id="ae22507b333d714ba60bd5045ea3c3adf" name="ae22507b333d714ba60bd5045ea3c3adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22507b333d714ba60bd5045ea3c3adf">&#9670;&#160;</a></span>minkowski_distance() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::minkowski_distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Minkowski distance between two real values: \(d(a, b) = \mathcal{l}^p(a - b)\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first real value </td></tr>
    <tr><td class="paramname">b</td><td>The second real value </td></tr>
    <tr><td class="paramname">p</td><td>The power of the distance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Minkowski distance of power p between a and b </dd></dl>

</div>
</div>
<a id="ae1521a586075b668b4a8765dadcdd1a3" name="ae1521a586075b668b4a8765dadcdd1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1521a586075b668b4a8765dadcdd1a3">&#9670;&#160;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::algebra::norm </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Euclidean/Hermitian norm of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to compute the norm of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The norm of the given vector </dd></dl>

</div>
</div>
<a id="af3f76287e1f911f7223ebf865ee16eea" name="af3f76287e1f911f7223ebf865ee16eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f76287e1f911f7223ebf865ee16eea">&#9670;&#160;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector theoretica::algebra::normalize </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the normalized vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to normalize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized vector </dd></dl>

</div>
</div>
<a id="a7925dcde9e30aaf83965f094c79199ac" name="a7925dcde9e30aaf83965f094c79199ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7925dcde9e30aaf83965f094c79199ac">&#9670;&#160;</a></span>pair_inner_product() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::algebra::pair_inner_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>v_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>w_i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the contribution of the inner product between a pair of elements of two vectors, automatically selecting whether to compute the conjugate or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v_i</td><td>The first element of the pair </td></tr>
    <tr><td class="paramname">w_i</td><td>The second element of the pair, which will be conjugated if needed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contribution of the element pair </dd></dl>

</div>
</div>
<a id="a838277b2f0e59831f5f0b3f5d388c925" name="a838277b2f0e59831f5f0b3f5d388c925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838277b2f0e59831f5f0b3f5d388c925">&#9670;&#160;</a></span>pair_inner_product() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::algebra::pair_inner_product </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>w_i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the contribution of the inner product between a pair of elements of two vectors, automatically selecting whether to compute the conjugate or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v_i</td><td>The first element of the pair </td></tr>
    <tr><td class="paramname">w_i</td><td>The second element of the pair, which will be conjugated if needed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contribution of the element pair </dd></dl>

</div>
</div>
<a id="ae7ff5243f09e983bb1e391a80abfa2b1" name="ae7ff5243f09e983bb1e391a80abfa2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ff5243f09e983bb1e391a80abfa2b1">&#9670;&#160;</a></span>perspective()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix theoretica::algebra::perspective </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>near</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>far</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cols</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a perspective projection matrix with adjustable view volume boundaries. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>The type of matrix to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left boundary of the view volume. </td></tr>
    <tr><td class="paramname">right</td><td>The right boundary of the view volume. </td></tr>
    <tr><td class="paramname">bottom</td><td>The bottom boundary of the view volume. </td></tr>
    <tr><td class="paramname">top</td><td>The top boundary of the view volume. </td></tr>
    <tr><td class="paramname">near</td><td>The near clipping plane distance. </td></tr>
    <tr><td class="paramname">far</td><td>The far clipping plane distance. </td></tr>
    <tr><td class="paramname">rows</td><td>Optional number of rows to set for the matrix (default is 0). </td></tr>
    <tr><td class="paramname">cols</td><td>Optional number of columns to set for the matrix (default is 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A perspective projection matrix with dimensions at least 4x4.</dd></dl>
<p>This function creates a perspective projection matrix that maps a 3D frustum into a 2D plane. If the matrix dimensions are smaller than 4x4, an error is triggered. The matrix is initialized to zero, with values set to define the specified perspective projection parameters. </p>

</div>
</div>
<a id="a90657bcb7de860059ab5c52087c5d37b" name="a90657bcb7de860059ab5c52087c5d37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90657bcb7de860059ab5c52087c5d37b">&#9670;&#160;</a></span>rayleigh_quotient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::algebra::rayleigh_quotient </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Rayleigh quotient \(\frac{x^T A x}{x^T x}\) of a vector with respect to a matrix. </p>
<p>This value is particularly useful in the context of eigensolvers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix </td></tr>
    <tr><td class="paramname">x</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Rayleigh quotient of x with respect to A </dd></dl>

</div>
</div>
<a id="a38f892f84cf60902500fc4a4f114f8fe" name="a38f892f84cf60902500fc4a4f114f8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f892f84cf60902500fc4a4f114f8fe">&#9670;&#160;</a></span>rotation_2d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix theoretica::algebra::rotation_2d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cols</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a matrix representing a 2D rotation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The angle of rotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix </dd></dl>

</div>
</div>
<a id="abc19e58fd39649b8e9d2c48a2d7fa90e" name="abc19e58fd39649b8e9d2c48a2d7fa90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc19e58fd39649b8e9d2c48a2d7fa90e">&#9670;&#160;</a></span>rotation_3d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix theoretica::algebra::rotation_3d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cols</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a matrix representing a 3D rotation around a given axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>Angle of rotation </td></tr>
    <tr><td class="paramname">axis</td><td>Axis of rotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix representing the rotation of theta radians around the given axis. </dd></dl>

</div>
</div>
<a id="a7e41df03a4e0f1273b41aea2fc1dee3a" name="a7e41df03a4e0f1273b41aea2fc1dee3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e41df03a4e0f1273b41aea2fc1dee3a">&#9670;&#160;</a></span>rotation_3d_xaxis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix theoretica::algebra::rotation_3d_xaxis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cols</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a matrix representing a 3D rotation around the x axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>Angle of rotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix representing the rotation of theta radians around the x axis. </dd></dl>

</div>
</div>
<a id="ab5d11b57ca82a631907f4eb1b1d67438" name="ab5d11b57ca82a631907f4eb1b1d67438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d11b57ca82a631907f4eb1b1d67438">&#9670;&#160;</a></span>rotation_3d_yaxis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix theoretica::algebra::rotation_3d_yaxis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cols</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a matrix representing a 3D rotation around the y axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>Angle of rotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix representing the rotation of theta radians around the y axis. </dd></dl>

</div>
</div>
<a id="acfb980ed1301d1e78fc2232181d93b9a" name="acfb980ed1301d1e78fc2232181d93b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb980ed1301d1e78fc2232181d93b9a">&#9670;&#160;</a></span>rotation_3d_zaxis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix theoretica::algebra::rotation_3d_zaxis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cols</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a matrix representing a 3D rotation around the z axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>Angle of rotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix representing the rotation of theta radians around the z axis. </dd></dl>

</div>
</div>
<a id="a47d7736bbdcc4b5c721923592f6a65e4" name="a47d7736bbdcc4b5c721923592f6a65e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d7736bbdcc4b5c721923592f6a65e4">&#9670;&#160;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector theoretica::algebra::solve </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve the linear system \(A \vec x = \vec b\), finding \(\vec x\) using the best available algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix of the linear system </td></tr>
    <tr><td class="paramname">b</td><td>The known vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unknown vector \(\vec x\) </dd></dl>

</div>
</div>
<a id="ad6b885344f6ad8216871eae18dd0a1d1" name="ad6b885344f6ad8216871eae18dd0a1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b885344f6ad8216871eae18dd0a1d1">&#9670;&#160;</a></span>solve_cholesky()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector theoretica::algebra::solve_cholesky </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve a linear system \(A \vec x = \vec b\) defined by a symmetric positive definite matrix, using the Cholesky decomposition \(L\) constructed so that \(A = LL^T\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>The already computed Cholesky decomposition of the symmetric positive definite matrix describing the system. </td></tr>
    <tr><td class="paramname">b</td><td>The known vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unknown vector \(\vec x\) </dd></dl>

</div>
</div>
<a id="a8ea88b9c22e1b32d1a32519aa02ea4e4" name="a8ea88b9c22e1b32d1a32519aa02ea4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea88b9c22e1b32d1a32519aa02ea4e4">&#9670;&#160;</a></span>solve_lu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector theoretica::algebra::solve_lu </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the LU decomposition of a matrix to solve its associated linear system, solving \(A \vec x = \vec b\) for \(\vec b\). </p>
<p>When solving the same linear system over and over, it is advantageous to compute its LU decomposition using decompose_lu and then use the decomposition to solve the system for different known vectors, reducing the overall computational cost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>The lower triangular matrix </td></tr>
    <tr><td class="paramname">U</td><td>The upper triangular matrix </td></tr>
    <tr><td class="paramname">b</td><td>The known vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector solution \(\vec x\). </dd></dl>

</div>
</div>
<a id="a6dc8b5c2fa93053f3370b22b5fad2089" name="a6dc8b5c2fa93053f3370b22b5fad2089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc8b5c2fa93053f3370b22b5fad2089">&#9670;&#160;</a></span>solve_lu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector theoretica::algebra::solve_lu </td>
          <td>(</td>
          <td class="paramtype">Matrix&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve the linear system \(A \vec x = \vec b\), finding \(\vec x\). </p>
<p>In-place LU decomposition is used on A, followed by forward and backward elimination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix of the linear system </td></tr>
    <tr><td class="paramname">b</td><td>The known vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unknown vector </dd></dl>

</div>
</div>
<a id="a45de7be9adda20b8c9f59a578ff46937" name="a45de7be9adda20b8c9f59a578ff46937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45de7be9adda20b8c9f59a578ff46937">&#9670;&#160;</a></span>solve_lu_inplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector &amp; theoretica::algebra::solve_lu_inplace </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve the linear system \(A \vec x = \vec b\), finding \(\vec x\), where the matrix A has <b>already undergone in-place LU decomposition</b>. </p>
<p>Forward and backward elimination is used to solve the system in place. This routine is particularly efficient for solving linear systems multiple times with the same matrix but different vectors. The input vector is overwritten, as to not use any additional memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix of the linear system, after in-place LU decomposition </td></tr>
    <tr><td class="paramname">b</td><td>The known vector, to be overwritten with the solution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten vector solution </dd></dl>

</div>
</div>
<a id="a6fc85f89aafd490490d0a7b36bed8e15" name="a6fc85f89aafd490490d0a7b36bed8e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc85f89aafd490490d0a7b36bed8e15">&#9670;&#160;</a></span>solve_triangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector theoretica::algebra::solve_triangular </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve the linear system \(T \vec x = b\) for triangular \(T\). </p>
<p>The correct solver is selected depending on the elements of \(T\), if the property of the matrix is known a priori, calling the specific function is more efficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The triangular matrix. </td></tr>
    <tr><td class="paramname">b</td><td>The known vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b7074a581766dad1465f4ea1264c229" name="a9b7074a581766dad1465f4ea1264c229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7074a581766dad1465f4ea1264c229">&#9670;&#160;</a></span>solve_triangular_lower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector theoretica::algebra::solve_triangular_lower </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve the linear system \(L \vec x = b\) for lower triangular \(L\). </p>
<dl class="section note"><dt>Note</dt><dd>No check is performed on the triangularity of \(L\).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>The lower triangular matrix. </td></tr>
    <tr><td class="paramname">b</td><td>The known vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab64a6205ec3c0bbddcdd3aee26aec6dd" name="ab64a6205ec3c0bbddcdd3aee26aec6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64a6205ec3c0bbddcdd3aee26aec6dd">&#9670;&#160;</a></span>solve_triangular_upper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector theoretica::algebra::solve_triangular_upper </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve the linear system \(U \vec x = b\) for upper triangular \(U\). </p>
<dl class="section note"><dt>Note</dt><dd>No check is performed on the triangularity of \(U\).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>The upper triangular matrix. </td></tr>
    <tr><td class="paramname">b</td><td>The known vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ec388888fe8bed059d86349d80aa5f0" name="a6ec388888fe8bed059d86349d80aa5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec388888fe8bed059d86349d80aa5f0">&#9670;&#160;</a></span>sparsity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , enable_matrix&lt; Matrix &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::algebra::sparsity </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1<a class="el" href="namespacetheoretica.html#aa3c0a5082e6b4428b15b7b02d16eafc7">E</a>-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sparsity of a matrix, counting the proportion of zero (smaller in module than the given tolerance) elements with respect to the total number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to compute the sparsity of </td></tr>
    <tr><td class="paramname">tolerance</td><td>The minimum tolerance in absolute value to consider an element non-zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A real number between 0 and 1 representing the proportion of zero elements of the matrix. </dd></dl>

</div>
</div>
<a id="a517bdd1d7ac545a5f3ccfab6e627caca" name="a517bdd1d7ac545a5f3ccfab6e627caca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517bdd1d7ac545a5f3ccfab6e627caca">&#9670;&#160;</a></span>sphere_inversion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector1 , typename Vector2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector1 theoretica::algebra::sphere_inversion </td>
          <td>(</td>
          <td class="paramtype">const Vector1 &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>c</em> = <code>Vector2(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>r</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sphere inversion of a point with respect to a sphere of radius r centered at a point c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The vector to transform </td></tr>
    <tr><td class="paramname">c</td><td>The center of the sphere </td></tr>
    <tr><td class="paramname">r</td><td>The radius of the sphere </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90bea2f231e34937ede290fd070f7f21" name="a90bea2f231e34937ede290fd070f7f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bea2f231e34937ede290fd070f7f21">&#9670;&#160;</a></span>sqr_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::algebra::sqr_norm </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the square of the Euclidean/Hermitian norm of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to compute the norm of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The norm of the given vector </dd></dl>

</div>
</div>
<a id="a2dc18f1cdbcf6eef1e543a54eec0b004" name="a2dc18f1cdbcf6eef1e543a54eec0b004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc18f1cdbcf6eef1e543a54eec0b004">&#9670;&#160;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::algebra::trace </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the trace of the given matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A matrix of any type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The trace of the matrix </dd></dl>

</div>
</div>
<a id="a539f9f16151e9fad1e53c653c252f522" name="a539f9f16151e9fad1e53c653c252f522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539f9f16151e9fad1e53c653c252f522">&#9670;&#160;</a></span>transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector theoretica::algebra::transform </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the matrix transformation of a vector. </p>
<p>Equivalent to the operation A * v </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix transformation </td></tr>
    <tr><td class="paramname">v</td><td>The vector to transform </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed vector </dd></dl>

</div>
</div>
<a id="ab5867fd83e4589708adb02545564200d" name="ab5867fd83e4589708adb02545564200d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5867fd83e4589708adb02545564200d">&#9670;&#160;</a></span>transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector1 , typename Vector2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector1 &amp; theoretica::algebra::transform </td>
          <td>(</td>
          <td class="paramtype">Vector1 &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a matrix transformation to a vector and store the result in the vector. </p>
<p>Equivalent to the operation v = A * v </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The matrix to overwrite with the result </td></tr>
    <tr><td class="paramname">A</td><td>The matrix transformation </td></tr>
    <tr><td class="paramname">v</td><td>The vector to transform </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten vector </dd></dl>

</div>
</div>
<a id="aeea5d17fa90dc48629d2028208e4b8d1" name="aeea5d17fa90dc48629d2028208e4b8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea5d17fa90dc48629d2028208e4b8d1">&#9670;&#160;</a></span>translation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix theoretica::algebra::translation </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cols</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a translation matrix, that is, an NxN matrix which describes a translation in N-1 dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The translation vector of dimension N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The translation matrix </dd></dl>

</div>
</div>
<a id="afe362b810eac7593d63e67afaaf66836" name="afe362b810eac7593d63e67afaaf66836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe362b810eac7593d63e67afaaf66836">&#9670;&#160;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename MatrixT  = Matrix&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MatrixT theoretica::algebra::transpose </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the transpose of the given matrix. </p>
<p>Equivalent to the operation m^T </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to transpose </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transposed matrix </dd></dl>

</div>
</div>
<a id="ac5fb1b942d9ec2548b7677e67d2f9235" name="ac5fb1b942d9ec2548b7677e67d2f9235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fb1b942d9ec2548b7677e67d2f9235">&#9670;&#160;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix1 &amp; theoretica::algebra::transpose </td>
          <td>(</td>
          <td class="paramtype">Matrix1 &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the transpose matrix and write the result to another matrix. </p>
<p>Equivalent to the operation dest = src^T </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The matrix to overwrite </td></tr>
    <tr><td class="paramname">src</td><td>The matrix to transpose </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten matrix </dd></dl>

</div>
</div>
<a id="a425738669ab6decff8d928400d19c82f" name="a425738669ab6decff8d928400d19c82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425738669ab6decff8d928400d19c82f">&#9670;&#160;</a></span>vec_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector1 , typename Vector2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector1 &amp; theoretica::algebra::vec_copy </td>
          <td>(</td>
          <td class="paramtype">Vector1 &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a vector by overwriting another. </p>
<p>Equivalent to the operation dest = src </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The vector to overwrite </td></tr>
    <tr><td class="paramname">src</td><td>The vector to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten matrix </dd></dl>

</div>
</div>
<a id="a6afcd5de93f3c5bb57f7a1964a768075" name="a6afcd5de93f3c5bb57f7a1964a768075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6afcd5de93f3c5bb57f7a1964a768075">&#9670;&#160;</a></span>vec_diff() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector1 , typename Vector2 , typename Vector3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector1 &amp; theoretica::algebra::vec_diff </td>
          <td>(</td>
          <td class="paramtype">Vector1 &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract two vectors and store the result in another vector Equivalent to the operation res = v1 - v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first vector </td></tr>
    <tr><td class="paramname">v2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten vector </dd></dl>

</div>
</div>
<a id="aad4487895be628508f067a215df9de0e" name="aad4487895be628508f067a215df9de0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4487895be628508f067a215df9de0e">&#9670;&#160;</a></span>vec_diff() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector1 , typename Vector2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 &amp; theoretica::algebra::vec_diff </td>
          <td>(</td>
          <td class="paramtype">Vector1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract two vectors and store the result in the first vector. </p>
<p>Equivalent to the operation v1 = v1 - v2 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first vector to store the result </td></tr>
    <tr><td class="paramname">v2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten vector </dd></dl>

</div>
</div>
<a id="acedb7a30970499d5e6a1f7f6137b6451" name="acedb7a30970499d5e6a1f7f6137b6451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acedb7a30970499d5e6a1f7f6137b6451">&#9670;&#160;</a></span>vec_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector &amp; theoretica::algebra::vec_error </td>
          <td>(</td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrite the given vector with the error vector with NaN values. </p>
<p>This function is used to signal an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to overwrite </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten vector </dd></dl>

</div>
</div>
<a id="afceadb5165f258a031449bc262f66f73" name="afceadb5165f258a031449bc262f66f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afceadb5165f258a031449bc262f66f73">&#9670;&#160;</a></span>vec_scalmul() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Field , typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector &amp; theoretica::algebra::vec_scalmul </td>
          <td>(</td>
          <td class="paramtype">Field&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a vector by a scalar of any compatible type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A scalar value </td></tr>
    <tr><td class="paramname">v</td><td>The vector to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the multiplied vector </dd></dl>

</div>
</div>
<a id="a60b3fdeb09b24462b60c7b15cfcc1e2b" name="a60b3fdeb09b24462b60c7b15cfcc1e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b3fdeb09b24462b60c7b15cfcc1e2b">&#9670;&#160;</a></span>vec_scalmul() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Field , typename Vector1 , typename Vector2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector1 &amp; theoretica::algebra::vec_scalmul </td>
          <td>(</td>
          <td class="paramtype">Vector1 &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Field&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a vector by a scalar of any compatible type which can be cast to the type of element of the output vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The vector to overwrite with the result </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value </td></tr>
    <tr><td class="paramname">src</td><td>The vector to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the resulting vector </dd></dl>

</div>
</div>
<a id="a26d05776d64b85e0b2de6a6e3939c701" name="a26d05776d64b85e0b2de6a6e3939c701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d05776d64b85e0b2de6a6e3939c701">&#9670;&#160;</a></span>vec_sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector1 , typename Vector2 , typename Vector3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector1 &amp; theoretica::algebra::vec_sum </td>
          <td>(</td>
          <td class="paramtype">Vector1 &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum two vectors and store the result in another vector Equivalent to the operation res = v1 + v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first vector to add </td></tr>
    <tr><td class="paramname">v2</td><td>The second vector to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten vector </dd></dl>

</div>
</div>
<a id="aa3dfff35041d5071c7c44b10b3f00716" name="aa3dfff35041d5071c7c44b10b3f00716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3dfff35041d5071c7c44b10b3f00716">&#9670;&#160;</a></span>vec_sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector1 , typename Vector2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 &amp; theoretica::algebra::vec_sum </td>
          <td>(</td>
          <td class="paramtype">Vector1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum two vectors and store the result in the first vector. </p>
<p>Equivalent to the operation v1 = v1 + v2 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first vector to add and store the result </td></tr>
    <tr><td class="paramname">v2</td><td>The second vector to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten vector </dd></dl>

</div>
</div>
<a id="ac5e8fa43f30568039c57c3f2996fcc97" name="ac5e8fa43f30568039c57c3f2996fcc97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e8fa43f30568039c57c3f2996fcc97">&#9670;&#160;</a></span>vec_zeroes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector &amp; theoretica::algebra::vec_zeroes </td>
          <td>(</td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrite a vector with all zeroes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to overwrite </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the overwritten vector </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetheoretica.html">theoretica</a></li><li class="navelem"><a class="el" href="namespacetheoretica_1_1algebra.html">algebra</a></li>
    <li class="footer">Generated on Sat May 31 2025 14:28:39 for Theoretica by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
